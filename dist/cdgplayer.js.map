{"version":3,"file":"cdgplayer.js","sources":["../node_modules/style-inject/dist/style-inject.es.js","../src/cdg/constants.js","../src/cdg/CDGContext.js","../src/cdg/logger.js","../src/cdg/CDGInstruction.js","../src/cdg/CDGParser.js","../src/cdg/CDGPlayer.js","../src/utilities/deferred.js","../src/loader/CDGFileLoader.js","../node_modules/soundtouchjs/dist/soundtouch.js","../src/observable/pubsub.js","../src/observable/observable.js","../src/player/KaraokePlayer.js","../src/utilities/is.js","../src/controls/CDGControls.js"],"sourcesContent":["function styleInject(css, ref) {\n  if ( ref === void 0 ) ref = {};\n  var insertAt = ref.insertAt;\n\n  if (!css || typeof document === 'undefined') { return; }\n\n  var head = document.head || document.getElementsByTagName('head')[0];\n  var style = document.createElement('style');\n  style.type = 'text/css';\n\n  if (insertAt === 'top') {\n    if (head.firstChild) {\n      head.insertBefore(style, head.firstChild);\n    } else {\n      head.appendChild(style);\n    }\n  } else {\n    head.appendChild(style);\n  }\n\n  if (style.styleSheet) {\n    style.styleSheet.cssText = css;\n  } else {\n    style.appendChild(document.createTextNode(css));\n  }\n}\n\nexport default styleInject;\n","/**\n * CDG Context Constants\n * =====================\n *\n * These are used to set up the drawing context\n */\n\nexport const TILE_WIDTH = 6;\nexport const TILE_HEIGHT = 12;\nexport const TILES_X = 50;\nexport const TILES_Y = 18;\nexport const TILES_X_BORDER = 1;\nexport const TILES_Y_BORDER = 1;\nexport const WIDTH = TILE_WIDTH * TILES_X; // 300px\nexport const HEIGHT = TILE_HEIGHT * TILES_Y; // 216px\nexport const BORDER_WIDTH = TILE_WIDTH * TILES_X_BORDER;\nexport const BORDER_HEIGHT = TILE_HEIGHT * TILES_Y_BORDER;\nexport const DISPLAY_WIDTH = WIDTH - 2 * BORDER_WIDTH; // 288px\nexport const DISPLAY_HEIGHT = HEIGHT - 2 * BORDER_HEIGHT; // 192px\nexport const DISPLAY_BOUNDS = [\n  BORDER_WIDTH,\n  BORDER_HEIGHT,\n  BORDER_WIDTH + DISPLAY_WIDTH,\n  BORDER_HEIGHT + DISPLAY_HEIGHT\n];\nexport const DISPLAY_PIXELS = WIDTH * HEIGHT;\n\n/**\n * CDG Instruction Constants\n * =========================\n *\n * These are used for interpreting commands\n */\n\nexport const CDG_NOOP = 0;\nexport const CDG_MEMORY_PRESET = 1;\nexport const CDG_BORDER_PRESET = 2;\nexport const CDG_TILE_BLOCK = 6;\nexport const CDG_SCROLL_PRESET = 20;\nexport const CDG_SCROLL_COPY = 24;\nexport const CDG_SET_KEY_COLOR = 28;\nexport const CDG_LOAD_CLUT_LOW = 30;\nexport const CDG_LOAD_CLUT_HI = 31;\nexport const CDG_TILE_BLOCK_XOR = 38;\n\nexport const CDG_SCROLL_NONE = 0;\nexport const CDG_SCROLL_LEFT = 1;\nexport const CDG_SCROLL_RIGHT = 2;\nexport const CDG_SCROLL_UP = 1;\nexport const CDG_SCROLL_DOWN = 2;\n\nexport const CDG_DATA = 4;\n\nexport const COMMAND_MASK = 0x3f;\nexport const CDG_COMMAND = 0x09;\nexport const SECTORS_PER_SECOND = 75;\nexport const PACKETS_PER_SECTOR = 4;\nexport const PACKET_SIZE = 24;\n\n/**\n *  CDG Audio Constants\n */\n\nexport const GAIN_DEFAULT = 1.0;\nexport const PITCH_DEFAULT = 1;\n\n/**\n *  CDG Player Constants\n */\n\nexport const SCALE_DEFAULT = 1;\nexport const FILTER_PLAYBACK_OFFSET = 800;\nexport const START_TIME = '0:00';\n\n/**\n * CDG Controls Constants\n */\nexport const PANEL_POSITION = ['top', 'bottom'];\n","import { WIDTH, HEIGHT, DISPLAY_PIXELS } from './constants';\n\n/**\n * CDG Context\n * ===========\n *\n * CDG rendering context, maintaining the size and content of the screen and the color palette\n */\nexport default class CDGContext {\n  /**\n   * Horizontal offset\n   * @type {number}\n   */\n  hOffset = 0;\n\n  /**\n   * Vertical offset\n   * @type {number}\n   */\n  vOffset = 0;\n\n  /**\n   * Transparent index in the color lookup table\n   * @type {number}\n   */\n  keyColor = null;\n\n  /**\n   * Background index in the color lookup table\n   * @type {number}\n   */\n  backgroundContainer = null;\n\n  /**\n   * Last index in the color lookup table that was used as a border preset\n   * @type {number}\n   */\n  borderColor = null;\n\n  /**\n   * Last index in the color lookup table that was used as a memory preset\n   * @type {number}\n   */\n  memoryColor = null;\n\n  /**\n   * Color lookup table\n   * @type {Array}\n   */\n  clut = new Array(16).fill([0, 0, 0]);\n\n  /**\n   * Pixels\n   * @type {Array}\n   */\n  pixels = new Array(DISPLAY_PIXELS).fill(0);\n\n  /**\n   * Buffer\n   * @type {Array}\n   */\n  buffer = new Array(DISPLAY_PIXELS).fill(0);\n\n  /**\n   * Creates a CDG rendering context\n   *\n   * @constructor\n   * @param  {Object} [options] - context options\n   * @param  {number} [options.width] - width of the canvas\n   * @param  {number} [options.height] - height of the canvas\n   * @param  {HTMLCanvasElement} [options.canvas] - canvas element\n   * @param  {CanvasRenderingContext2D} [options.ctx] - canvas rendering context\n   * @param  {ImageData} [options.imageData] - pixel data\n   */\n  constructor({\n    width = WIDTH,\n    height = HEIGHT,\n    canvas = this.createCanvas(width, height),\n    ctx = this.createCanvasContext(canvas),\n    imageData = this.createImageData(canvas, ctx, width, height),\n  } = {}) {\n    this.canvas = canvas;\n    this.ctx = ctx;\n    this.imageData = imageData;\n  }\n\n  /**\n   * Creates a canvas at the given size\n   *\n   * @param  {number} width - width of the canvas\n   * @param  {number} height - height of the canvas\n   * @return {HTMLCanvasElement} created canvas\n   */\n  createCanvas(width, height) {\n    const canvas = document.createElement('canvas');\n    canvas.width = width;\n    canvas.height = height;\n    return canvas;\n  }\n\n  /**\n   * Creates a new 2D context for a canvas\n   *\n   * @param  {HTMLCanvasElement} canvas - canvas element\n   * @return {CanvasRenderingContext2D} created context\n   */\n  createCanvasContext(canvas) {\n    const ctx = canvas.getContext('2d');\n    ctx.mozImageSmoothingEnabled = false;\n    ctx.webkitImageSmoothingEnabled = false;\n    ctx.msImageSmoothingEnabled = false;\n    ctx.imageSmoothingEnabled = false;\n    return ctx;\n  }\n\n  /**\n   * Creates image data to dump the pixel data for canvas rendering\n   *\n   * @param  {HTMLCanvasElement} canvas - canvas element\n   * @param  {CanvasRenderingContext2D} ctx - 2D canvas rendering context\n   * @param  {number} width - width of the canvas\n   * @param  {number} height - height of the canvas\n   * @return {ImageData} created image data\n   */\n  createImageData(canvas, ctx, width = canvas.width, height = canvas.height) {\n    return ctx.createImageData(width, height);\n  }\n\n  /**\n   * Resets the offset and key color\n   */\n  reset() {\n    this.hOffset = 0;\n    this.vOffset = 0;\n    this.keyColor = null;\n    this.backgroundColor = null;\n    this.borderColor = null;\n    this.memoryColor = null;\n    this.pixels.fill(0);\n  }\n\n  /**\n   * Sets an entry in the color lookup table\n   *\n   * @param  {Number} index - index in the palette\n   * @param  {number} r - red component of the color\n   * @param  {number} g - green component of the color\n   * @param  {number} b - blue component of the color\n   */\n  setCLUTEntry(index, r, g, b) {\n    this.clut[index] = [r, g, b].map((c) => c * 17);\n  }\n\n  /**\n   * Sets a pixel's CLUT index value\n   *\n   * @param {number} x - x position of the pixel\n   * @param {number} y - y position of the pixel\n   * @param {number} colorIndex - CLUT index\n   */\n  setPixel(x, y, colorIndex) {\n    this.pixels[x + y * WIDTH] = colorIndex;\n  }\n\n  /**\n   * Gets a pixel's CLUT index value\n   *\n   * @param  {number} x - x position of the pixel\n   * @param  {number} y - y position of the pixel\n   * @return {number} CLUT index\n   */\n  getPixel(x, y) {\n    return this.pixels[x + y * WIDTH];\n  }\n\n  /**\n   * Gets the background color index from the CLUT based on the transparent or background color\n   *\n   * @return {number} CLUT index\n   */\n  getBackground() {\n    switch (true) {\n      case this.keyColor != null:\n        return this.keyColor;\n      case this.backgroundColor != null:\n        return this.backgroundColor;\n      case this.memoryColor != null:\n        return this.memoryColor;\n      case this.borderColor != null:\n        return this.borderColor;\n      default:\n        return 0;\n    }\n  }\n\n  /**\n   * Converts palette-based pixel data to image data\n   *\n   * @return {ImageData} generated imagedata\n   */\n  generateImageData() {\n    const [left, top, right, bottom] = [0, 0, WIDTH, HEIGHT];\n    for (let x = left; x < right; x++) {\n      for (let y = top; y < bottom; y++) {\n        // The offset is where we draw the pixel in the raster data\n        const offset = 4 * (x + y * WIDTH);\n        // Respect the horizontal and vertical offsets for grabbing the pixel color\n        const px = (x - this.hOffset + WIDTH) % WIDTH;\n        const py = (y - this.vOffset + HEIGHT) % HEIGHT;\n        const pixelIndex = px + py * WIDTH;\n        const colorIndex = this.pixels[pixelIndex];\n        const [r, g, b] = this.clut[colorIndex];\n        // Set the rgba values in the image data\n        this.imageData.data[offset] = r;\n        this.imageData.data[offset + 1] = g;\n        this.imageData.data[offset + 2] = b;\n        this.imageData.data[offset + 3] =\n          colorIndex === this.keyColor ? 0x00 : 0xff;\n      }\n    }\n    return this.imageData;\n  }\n\n  /**\n   * Renders the pixel buffer\n   */\n  renderFrame() {\n    this.ctx.putImageData(this.generateImageData(), 0, 0);\n  }\n}\n","/* eslint-disable no-console */\n\nexport function log(...args) {\n  console && console.log && console.log(...args);\n}\n\nexport function warn(...args) {\n  console && console.warn && console.warn(...args);\n}\n\nexport function error(...args) {\n  console && console.error && console.error(...args);\n}\n\nexport default {\n  log,\n  warn,\n  error,\n};\n","import {\n  TILE_WIDTH,\n  TILE_HEIGHT,\n  WIDTH,\n  HEIGHT,\n  DISPLAY_BOUNDS,\n  CDG_NOOP,\n  CDG_MEMORY_PRESET,\n  CDG_BORDER_PRESET,\n  CDG_TILE_BLOCK,\n  CDG_SCROLL_PRESET,\n  CDG_SCROLL_COPY,\n  CDG_SET_KEY_COLOR,\n  CDG_LOAD_CLUT_LOW,\n  CDG_LOAD_CLUT_HI,\n  CDG_TILE_BLOCK_XOR,\n  CDG_SCROLL_NONE,\n  CDG_SCROLL_LEFT,\n  CDG_SCROLL_RIGHT,\n  CDG_SCROLL_UP,\n  CDG_SCROLL_DOWN,\n  CDG_DATA,\n  PACKET_SIZE,\n} from './constants';\n\nimport { warn } from './logger';\n\n/**\n * CDG instruction base class\n * ==========================\n *\n * Does nothing\n */\nexport class CDGInstruction {\n  static instruction = '';\n  static opcode = null;\n\n  get instruction() {\n    return this.constructor.instruction;\n  }\n  get opcode() {\n    return this.constructor.opcode;\n  }\n\n  constructor(bytes, offset = 0) {\n    this.bytes = bytes.slice(offset, offset + PACKET_SIZE);\n  }\n\n  execute(/*context*/) {}\n\n  bytecodeToString() {\n    return this.bytes\n      .map((byte) => byte.toString(16).padStart(2, '0'))\n      .join('');\n  }\n\n  detailsToString() {\n    return '';\n  }\n\n  toString() {\n    return this.instruction;\n  }\n}\n\n/**\n * No-op instruction\n * =================\n *\n * Does nothing\n */\nexport class CDGNoopInstruction extends CDGInstruction {\n  static instruction = 'No-op';\n  static opcode = CDG_NOOP;\n}\n\n/**\n * Memory Preset instruction\n * =========================\n *\n * Set the screen to a particular color\n */\nexport class CDGMemoryPresetInstruction extends CDGInstruction {\n  static instruction = 'Memory Preset';\n  static opcode = CDG_MEMORY_PRESET;\n\n  constructor(bytes, offset = 0) {\n    super(bytes, offset);\n    const doff = offset + CDG_DATA;\n    this.color = bytes[doff] & 0x0f;\n    this.repeat = bytes[doff + 1] & 0x0f;\n  }\n\n  execute(context) {\n    context.memoryColor = this.color;\n    context.backgroundColor = this.color;\n    context.pixels.fill(this.color);\n  }\n\n  detailsToString() {\n    return `color index: ${this.color}`;\n  }\n}\n\n/**\n * Border Preset instruction\n * =========================\n *\n * Set the border of the screen to a particular color\n */\nexport class CDGBorderPresetInstruction extends CDGInstruction {\n  static instruction = 'Border Preset';\n  static opcode = CDG_BORDER_PRESET;\n\n  constructor(bytes, offset = 0) {\n    super(bytes, offset);\n    this.color = bytes[offset + CDG_DATA] & 0x0f;\n  }\n\n  execute(context) {\n    context.borderColor = this.color;\n    context.backgroundColor = this.color;\n    const [left, top, right, bottom] = DISPLAY_BOUNDS;\n    for (let x = 0; x < WIDTH; x++) {\n      for (let y = 0; y < top; y++) {\n        context.setPixel(x, y, this.color);\n      }\n      for (let y = bottom + 1; y < HEIGHT; y++) {\n        context.setPixel(x, y, this.color);\n      }\n    }\n    for (let y = top; y <= bottom; y++) {\n      for (let x = 0; x < left; x++) {\n        context.setPixel(x, y, this.color);\n      }\n      for (let x = right + 1; x < WIDTH; x++) {\n        context.setPixel(x, y, this.color);\n      }\n    }\n  }\n\n  detailsToString() {\n    return `color index: ${this.color}`;\n  }\n}\n\n/**\n * Tile Block (Normal) instruction\n * ===============================\n *\n * Load a 12 x 6, 2 color tile and display it normally.\n */\nexport class CDGTileBlockInstruction extends CDGInstruction {\n  static instruction = 'Tile Block';\n  static opcode = CDG_TILE_BLOCK;\n\n  constructor(bytes, offset = 0) {\n    super(bytes, offset);\n    const doff = offset + CDG_DATA;\n    // some players check bytes[doff+1] & 0x20 and ignores if it is set (?)\n    this.colors = [bytes[doff] & 0x0f, bytes[doff + 1] & 0x0f];\n    this.row = bytes[doff + 2] & 0x1f;\n    this.column = bytes[doff + 3] & 0x3f;\n    this.pixels = bytes.slice(doff + 4, doff + 16);\n  }\n\n  execute(context) {\n    /* blit a tile */\n    const x = this.column * TILE_WIDTH;\n    const y = this.row * TILE_HEIGHT;\n\n    // @TODO: These should be >= instead, I think...\n    if (x + TILE_WIDTH > WIDTH || y + TILE_HEIGHT > HEIGHT) {\n      warn(`TileBlock out of bounds (${this.row}, ${this.column})`);\n      return;\n    }\n\n    for (let i = 0; i < TILE_HEIGHT; i++) {\n      const curbyte = this.pixels[i];\n      for (let j = 0; j < TILE_WIDTH; j++) {\n        const color = this.colors[(curbyte >> (5 - j)) & 0x01];\n        this.op(context, x + j, y + i, color);\n      }\n    }\n  }\n\n  op(context, x, y, color) {\n    context.setPixel(x, y, color);\n  }\n\n  detailsToString() {\n    return `row: ${this.row}, column: ${\n      this.column\n    }, color indexes: [${this.colors.join(', ')}]`;\n  }\n}\n\n/**\n * Tile Block (XOR) instruction\n * ============================\n *\n * Load a 12 x 6, 2 color tile and display it using the XOR method\n */\nexport class CDGTileBlockXORInstruction extends CDGTileBlockInstruction {\n  static instruction = 'Tile Block (XOR)';\n  static opcode = CDG_TILE_BLOCK_XOR;\n\n  op(context, x, y, color) {\n    // context.pixels[offset] = context.pixels[offset] ^ color;\n    context.setPixel(x, y, context.getPixel(x, y) ^ color);\n  }\n}\n\n/**\n * Scroll Preset instruction\n * =========================\n *\n * Scroll the image, filling in the new area with a color\n */\nexport class CDGScrollPresetInstruction extends CDGInstruction {\n  static instruction = 'Scroll Preset';\n  static opcode = CDG_SCROLL_PRESET;\n\n  constructor(bytes, offset = 0) {\n    super(bytes, offset);\n    const doff = offset + CDG_DATA;\n    this.color = bytes[doff] & 0x0f;\n\n    const hScroll = bytes[doff + 1] & 0x3f;\n    this.hCmd = (hScroll & 0x30) >> 4;\n    this.hOffset = hScroll & 0x07;\n\n    const vScroll = bytes[doff + 2] & 0x3f;\n    this.vCmd = (vScroll & 0x30) >> 4;\n    this.vOffset = vScroll & 0x0f;\n  }\n\n  // eslint-disable-next-line complexity\n  execute(context) {\n    context.backgroundColor = this.color;\n    context.hOffset = Math.min(this.hOffset, TILE_WIDTH - 1);\n    context.vOffset = Math.min(this.vOffset, TILE_HEIGHT - 1);\n\n    let hScroll = 0;\n    switch (this.hCmd) {\n      case CDG_SCROLL_RIGHT:\n        hScroll = TILE_WIDTH;\n        break;\n      case CDG_SCROLL_LEFT:\n        hScroll = -TILE_WIDTH;\n        break;\n      case CDG_SCROLL_NONE:\n      default:\n        break;\n    }\n\n    let vScroll = 0;\n    switch (this.hCmd) {\n      case CDG_SCROLL_DOWN:\n        vScroll = TILE_HEIGHT;\n        break;\n      case CDG_SCROLL_UP:\n        vScroll = -TILE_HEIGHT;\n        break;\n      case CDG_SCROLL_NONE:\n      default:\n        break;\n    }\n\n    if (!hScroll && !vScroll) {\n      return;\n    }\n\n    for (let x = 0; x < WIDTH; x++) {\n      for (let y = 0; y < HEIGHT; y++) {\n        context.buffer[x + y * WIDTH] = this.getPixel(\n          context,\n          x + hScroll,\n          y + vScroll\n        );\n      }\n    }\n\n    // Swap buffers\n    [context.pixels, context.buffer] = [context.buffer, context.pixels];\n  }\n\n  getPixel(context, offx, offy) {\n    if (offx > 0 && offx < WIDTH && offy > 0 && offy < HEIGHT) {\n      return context.pixels[offx + offy * WIDTH];\n    }\n    return this.color;\n  }\n\n  detailsToString() {\n    let vScroll = false;\n    let hScroll = false;\n    if (this.vCmd === CDG_SCROLL_UP) {\n      vScroll = 'up';\n    } else if (this.vCmd === CDG_SCROLL_DOWN) {\n      vScroll = 'down';\n    }\n    if (this.vCmd === CDG_SCROLL_LEFT) {\n      hScroll = 'left';\n    } else if (this.vCmd === CDG_SCROLL_RIGHT) {\n      hScroll = 'right';\n    }\n    return [\n      vScroll,\n      hScroll,\n      `vOffset: ${this.vOffset}`,\n      `hOffset: ${this.hOffset}`,\n    ]\n      .filter((v) => v)\n      .join(' ');\n  }\n}\n\n/**\n * Scroll Copy instruction\n * =======================\n *\n * Scroll the image, rotating the bits back around\n */\nexport class CDGScrollCopyInstruction extends CDGScrollPresetInstruction {\n  static instruction = 'Scroll Copy';\n  static opcode = CDG_SCROLL_COPY;\n\n  getPixel(context, offx, offy) {\n    offx = (offx + WIDTH) % WIDTH;\n    offy = (offy + HEIGHT) % HEIGHT;\n    return context.pixels[offx + offy * WIDTH];\n  }\n}\n\n/**\n * Set Key Color instruction\n * =========================\n *\n * Define a specific color as being transparent\n */\nexport class CDGSetKeyColorInstruction extends CDGInstruction {\n  static instruction = 'Set Key Color';\n  static opcode = CDG_SET_KEY_COLOR;\n\n  constructor(bytes, offset = 0) {\n    super(bytes, offset);\n    this.color = bytes[offset + CDG_DATA] & 0x0f;\n  }\n\n  execute(context) {\n    context.keyColor = this.color;\n  }\n\n  detailsToString() {\n    return `color index: ${this.color}`;\n  }\n}\n\n/**\n * Load Color Table (Low) instruction\n * ==================================\n *\n * Load in the lower 8 entries of the color table\n */\nexport class CDGLoadCLUTLowInstruction extends CDGInstruction {\n  static instruction = 'Load CLUT (Low)';\n  static opcode = CDG_LOAD_CLUT_LOW;\n\n  get clutOffset() {\n    return 0;\n  }\n\n  constructor(bytes, offset = 0) {\n    super(bytes, offset);\n    const doff = offset + CDG_DATA;\n    this.colors = [];\n    for (let i = 0; i < 8; i++) {\n      const cur = doff + 2 * i;\n      const color = ((bytes[cur] & 0x3f) << 6) + (bytes[cur + 1] & 0x3f);\n\n      this.colors[i] = [\n        color >> 8, // red\n        (color & 0xf0) >> 4, // green\n        color & 0x0f, // blue\n      ];\n    }\n  }\n\n  execute(context) {\n    for (let i = 0; i < 8; i++) {\n      context.setCLUTEntry(\n        i + this.clutOffset,\n        this.colors[i][0],\n        this.colors[i][1],\n        this.colors[i][2]\n      );\n    }\n  }\n\n  detailsToString() {\n    return `colors: [${this.colors\n      .map(\n        (color, i) =>\n          `${i + this.clutOffset}: #${color\n            .map((c) => c.toString(16))\n            .join('')}`\n      )\n      .join(', ')}]`;\n  }\n}\n\n/**\n * Load Color Table (High) instruction\n * ==================================\n *\n * Load in the upper 8 entries of the color table\n */\nexport class CDGLoadCLUTHighInstruction extends CDGLoadCLUTLowInstruction {\n  static instruction = 'Load CLUT (High)';\n  static opcode = CDG_LOAD_CLUT_HI;\n\n  get clutOffset() {\n    return 8;\n  }\n}\n","import {\n  CDG_NOOP,\n  CDG_MEMORY_PRESET,\n  CDG_BORDER_PRESET,\n  CDG_TILE_BLOCK,\n  CDG_SCROLL_PRESET,\n  CDG_SCROLL_COPY,\n  CDG_SET_KEY_COLOR,\n  CDG_LOAD_CLUT_LOW,\n  CDG_LOAD_CLUT_HI,\n  CDG_TILE_BLOCK_XOR,\n  COMMAND_MASK,\n  CDG_COMMAND,\n  PACKET_SIZE,\n} from './constants';\n\nimport { warn } from './logger';\n\nimport {\n  CDGNoopInstruction,\n  CDGMemoryPresetInstruction,\n  CDGBorderPresetInstruction,\n  CDGTileBlockInstruction,\n  CDGScrollPresetInstruction,\n  CDGScrollCopyInstruction,\n  CDGSetKeyColorInstruction,\n  CDGLoadCLUTLowInstruction,\n  CDGLoadCLUTHighInstruction,\n  CDGTileBlockXORInstruction,\n} from './CDGInstruction';\n\n/**\n * CDG Parser\n * ==========\n *\n * Instruction parser, converting bytecodes to arrays of CDGInstructions\n */\nexport default class CDGParser {\n  static get instructionClassByType() {\n    return {\n      [CDG_NOOP]: CDGNoopInstruction,\n      [CDG_MEMORY_PRESET]: CDGMemoryPresetInstruction,\n      [CDG_BORDER_PRESET]: CDGBorderPresetInstruction,\n      [CDG_TILE_BLOCK]: CDGTileBlockInstruction,\n      [CDG_SCROLL_PRESET]: CDGScrollPresetInstruction,\n      [CDG_SCROLL_COPY]: CDGScrollCopyInstruction,\n      [CDG_SET_KEY_COLOR]: CDGSetKeyColorInstruction,\n      [CDG_LOAD_CLUT_LOW]: CDGLoadCLUTLowInstruction,\n      [CDG_LOAD_CLUT_HI]: CDGLoadCLUTHighInstruction,\n      [CDG_TILE_BLOCK_XOR]: CDGTileBlockXORInstruction,\n    };\n  }\n\n  /**\n   * Maps commands to instruction classes\n   * @type {Object}\n   */\n  instructionClassByType = this.constructor.instructionClassByType;\n\n  /**\n   * Registers an instruction type\n   *\n   * @param  {string} opcode - CDG instruction opcode\n   * @param  {CDGInstruction} InstructionClass - CDG instruction subclass\n   */\n  registerInstruction(opcode, InstructionClass) {\n    this.instructionClassByType[opcode] = InstructionClass;\n  }\n\n  /**\n   * Creates an instruction\n   *\n   * @param  {string} opcode - CDG instruction opcode\n   * @param  {string} bytes - bytes with CDG instruction\n   * @param  {number} offset - a little piece of heaven\n   * @return {CDGInstruction}\n   */\n  createInstruction(opcode, bytes, offset = 0) {\n    if (!(opcode in this.instructionClassByType)) {\n      warn(`Unknown CDG instruction (instruction = ${opcode})`);\n    }\n    const InstructionClass =\n      this.instructionClassByType[opcode] || CDGNoopInstruction;\n    return new InstructionClass(bytes, offset);\n  }\n\n  /**\n   * Parses a single CDG instruction packet\n   *\n   * @param  {string} bytes - bytes with CDG instruction\n   * @param  {number} offset - a little piece of heaven\n   * @return {CDGInstruction}\n   */\n  parseInstruction(bytes, offset = 0) {\n    const command = bytes[offset] & COMMAND_MASK;\n    if (command === CDG_COMMAND) {\n      const opcode = bytes[offset + 1] & COMMAND_MASK;\n      return this.createInstruction(opcode, bytes, offset);\n    }\n    return new CDGNoopInstruction(bytes, offset);\n  }\n\n  /**\n   * Parses all the CDG instruction packets\n   *\n   * @param {string} bytes - bytes with CDG instruction\n   * @return {CDGInstruction[]}\n   */\n  parseInstructions(bytes) {\n    const instructions = [];\n    const bytesLength = bytes.length;\n    for (let offset = 0; offset < bytesLength; offset += PACKET_SIZE) {\n      instructions.push(this.parseInstruction(bytes, offset));\n    }\n    return instructions.filter((instruction) => instruction);\n  }\n}\n","import { PACKETS_PER_SECTOR, SECTORS_PER_SECOND } from './constants';\n\nimport CDGContext from './CDGContext';\nimport CDGParser from './CDGParser';\n\n/**\n * Calculates current time for the sake of determining playback intervals\n *\n * @return {number} milliseconds\n */\nfunction now() {\n  if (\n    typeof performance !== 'undefined' &&\n    typeof performance.now === 'function'\n  ) {\n    return performance.now();\n  } else if (\n    typeof process !== 'undefined' &&\n    typeof process.hrtime === 'function'\n  ) {\n    const [seconds, microseconds] = process.hrtime();\n    return seconds * 1000 + microseconds / 1000000;\n  }\n  return Date.now();\n}\n\nfunction requestFrame(callback) {\n  if (typeof requestAnimationFrame === 'function') {\n    return window.requestAnimationFrame(callback);\n  }\n  return setTimeout(callback, 25);\n}\n\nfunction cancelFrame(id) {\n  if (typeof cancelAnimationFrame === 'function') {\n    return cancelAnimationFrame(id);\n  }\n  return clearTimeout(id);\n}\n\n/**\n * CDG Player\n * ==========\n *\n * Provides an interface for interpreting CDG instructions and rendering the results to a canvas\n */\nexport default class CDGPlayer {\n  /**\n   * CDG instructions\n   * @type {Array}\n   */\n  instructions = [];\n\n  /**\n   * Packet counter\n   * @type {Number}\n   */\n  pc = -1;\n\n  /**\n   * requestAnimationFrame unique ID\n   * @type {number}\n   */\n  frameId = null;\n\n  /**\n   * Current time (ms)\n   * @type {Number}\n   */\n  pos = 0;\n\n  /**\n   * Last sync time (ms)\n   * @type {number}\n   */\n  lastSyncPos = null;\n\n  /**\n   * Last sync timestamp\n   * @type {DOMHighResTimeStamp}\n   */\n  lastTimestamp = null;\n\n  /**\n   * Steps through however many frames are necessary to bring the context up-to-date with\n   *\n   * @param  {DOMHighResTimeStamp} timestamp\n   * @return {self}\n   */\n  update = (timestamp = now()) => {\n    // Packet counter says relax\n    if (this.pc === -1) {\n      return this;\n    }\n\n    // go ahead and request the next frame\n    this.frameId = requestFrame(this.update);\n\n    if (this.lastSyncPos) {\n      // last known audio position + time delta\n      this.pos = this.lastSyncPos + (timestamp - this.lastTimestamp);\n    } else {\n      // time delta only (unsynced)\n      this.pos += timestamp - this.lastTimestamp;\n      this.lastTimestamp = timestamp;\n    }\n\n    // determine packet we should be at, based on spec\n    // of 4 packets per sector @ 75 sectors per second\n    const newPc = Math.floor(\n      SECTORS_PER_SECOND * PACKETS_PER_SECTOR * (this.pos / 1000)\n    );\n\n    const ffAmt = newPc - this.pc;\n    if (ffAmt > 0) {\n      this.fastForward(ffAmt);\n      this.render();\n    }\n\n    return this;\n  };\n\n  /**\n   * Creates CDGPlayer instance\n   *\n   * @constructor\n   * @param  {Object} [options] - CDG player options\n   * @param  {Object} [options.contextOptions] - options for the CDG context\n   * @param  {function} [options.afterRender] - function to call after rendering a frame\n   */\n  constructor({\n    contextOptions = {},\n    context = this.createContext(contextOptions),\n    afterRender,\n  } = {}) {\n    this.context = context;\n    this.afterRender = afterRender;\n  }\n\n  /**\n   * Creates a CDG context instance for rendering\n   *\n   * @param  {Object} [options] - parameters passed to the context constructor\n   * @return {CDGContext} context instance\n   */\n  createContext(options = {}) {\n    return new CDGContext(options);\n  }\n\n  /**\n   * Loads CDG data and parses the instructions\n   *\n   * @param  {string} data - CDG instruction data\n   * @return {self}\n   */\n  load(data) {\n    const parser = new CDGParser();\n    this.instructions = parser.parseInstructions(data);\n    this.reset();\n    return this;\n  }\n\n  /**\n   * Resets the counters\n   *\n   * @return {self}\n   */\n  reset() {\n    this.pc = 0;\n    this.pos = 0;\n    this.lastSyncPos = null;\n    this.context.reset();\n    return this;\n  }\n\n  /**\n   * Renders the CDG context frame\n   * @return {self}\n   */\n  render() {\n    this.context.renderFrame();\n    this.afterRender && this.afterRender(this.context);\n    return this;\n  }\n\n  /**\n   * Executes an instruction on this player's context\n   *\n   * @param  {CDGInstruction} instruction - CDG instruction to run\n   * @return {self}\n   */\n  executeInstruction(instruction) {\n    if (instruction && typeof instruction.execute === 'function') {\n      instruction.execute(this.context);\n    }\n    return this;\n  }\n\n  /**\n   * Executes the next CDG instruction packet\n   *\n   * @return {self}\n   */\n  step() {\n    if (this.pc >= 0 && this.pc < this.instructions.length) {\n      this.executeInstruction(this.instructions[this.pc]);\n      this.pc += 1;\n    } else {\n      this.pc = -1;\n      this.stop();\n    }\n    return this;\n  }\n\n  /**\n   * Executes several CDG instructions\n   *\n   * @param  {number} [count]\n   * @return {self}\n   */\n  fastForward(count = 1) {\n    const max = this.pc + count;\n    while (this.pc >= 0 && this.pc < max) {\n      this.step();\n    }\n    return this;\n  }\n\n  /**\n   * Starts CDG playback\n   *\n   * @return {self}\n   */\n  play() {\n    if (!this.frameId) {\n      this.frameId = requestFrame(this.update);\n      this.lastTimestamp = now();\n    }\n    return this;\n  }\n\n  /**\n   * Stops CDG playback\n   *\n   * @return {self}\n   */\n  stop() {\n    cancelFrame(this.frameId);\n    this.frameId = null;\n    this.lastSyncPos = null;\n    return this;\n  }\n\n  /**\n   * Syncs playback with a timestamp\n   *\n   * This is used to sync with the current time of the audio track\n   *\n   * @param  {number} ms - sync timestamp\n   * @return {self}\n   */\n  sync(ms) {\n    this.lastSyncPos = ms;\n    this.lastTimestamp = now();\n    return this;\n  }\n}\n","/**\n * Deferred()\n * Is a shim, written by Mozilla. It's a backwards/forwards compatible helper object to account for the\n * elimination of the Deferred object while still having a need for the functionality.\n *\n * https://developer.mozilla.org/en-US/docs/Mozilla/JavaScript_code_modules/Promise.jsm/Deferred#backwards_forwards_compatible\n * (Usage example can be found at above link, but here's the basics)\n *\n * const deferred = new Deferred();\n * const promise = deferred.promise; // still just a promise\n */\n\nconst Deferred = function () {\n  // update 062115 for typeof\n  if (typeof Promise !== 'undefined' && Promise.defer) {\n    //need import of Promise.jsm for example: Cu.import('resource:/gree/modules/Promise.jsm');\n    return Promise.defer();\n  } else if (typeof PromiseUtils !== 'undefined' && PromiseUtils.defer) {\n    // eslint-disable-line no-undef\n    //need import of PromiseUtils.jsm for example: Cu.import('resource:/gree/modules/PromiseUtils.jsm');\n    return PromiseUtils.defer(); // eslint-disable-line no-undef\n  } else {\n    /* A method to resolve the associated Promise with the value passed.\n     * If the promise is already settled it does nothing.\n     *\n     * @param {anything} value : This value is used to resolve the promise\n     * If the value is a Promise then the associated promise assumes the state\n     * of Promise passed as value.\n     */\n    this.resolve = null;\n\n    /* A method to reject the assocaited Promise with the value passed.\n     * If the promise is already settled it does nothing.\n     *\n     * @param {anything} reason: The reason for the rejection of the Promise.\n     * Generally its an Error object. If however a Promise is passed, then the Promise\n     * itself will be the reason for rejection no matter the state of the Promise.\n     */\n    this.reject = null;\n\n    /* A newly created Promise object.\n     * Initially in pending state.\n     */\n    this.promise = new Promise(\n      function (resolve, reject) {\n        this.resolve = resolve;\n        this.reject = reject;\n      }.bind(this)\n    );\n    Object.freeze(this);\n  }\n};\n\nexport default Deferred;\n","// JSZip and JSZipUtils are external dependencies\n//import * as JSZip from 'jszip';\n//import JSZipUtils from 'jszip-utils';\nimport Deferred from '../utilities/deferred.js';\n// import jsmediatags from 'jsmediatags';\n\nconst getDataFile = function (filePath) {\n  const deferred = new Deferred();\n  JSZipUtils.getBinaryContent(filePath, (err, data) => {\n    if (err) {\n      deferred.reject(\n        new Error(`There was an error retrieving ${filePath}`, err)\n      );\n      return;\n    }\n    deferred.resolve(data);\n  });\n  return deferred.promise;\n};\n\nconst loadZipBuffer = function (fileBuffer) {\n  return JSZip.loadAsync(fileBuffer).catch((error) =>\n    Promise.reject(new Error('There was an error reading the zip file.', error))\n  );\n};\n\nconst loadAudio = function (zipEntry) {\n  return zipEntry\n    .async('arraybuffer')\n    .catch(() => Promise.reject(new Error('Unable to load the audio file')));\n};\n\nconst getFallbackTagData = function (name) {\n  const parts = name.split(' - ');\n  const tag = { tags: {} };\n  // most downloaded cdgs have filenames 'album - artist - songtitle\n  tag.tags.album = parts[0].trim();\n  tag.tags.artist = parts[1] ? parts[1].trim() : tag.tags.album;\n  tag.tags.title = parts[2] ? parts[2].trim() : tag.tags.artist;\n  return tag;\n};\n\nconst getTagData = function (zipEntry) {\n  return zipEntry\n    .async('blob')\n    .then(\n      (buffer) =>\n        new Promise((resolve) => {\n          new jsmediatags.Reader(buffer)\n            .setTagsToRead([\n              'title',\n              'artist',\n              'album',\n              'track',\n              'year',\n              'genre',\n              'picture',\n            ])\n            .read({\n              onSuccess: (tag) => resolve(tag),\n              onError: () => resolve(getFallbackTagData(zipEntry.name)),\n            });\n        })\n    )\n    .catch(() => Promise.reject(new Error('Unable to parse tag data')));\n};\n\nconst loadVideo = function (zipEntry) {\n  return zipEntry\n    .async('uint8array')\n    .catch(() => Promise.reject(new Error('Unable to load the video file')));\n};\n\nconst getKaraokeFiles = function (zipFile) {\n  const entries = zipFile.filter(\n    (relPath) => relPath.endsWith('.cdg') || relPath.endsWith('.mp3')\n  );\n  if (entries.length === 2) {\n    return Promise.resolve(entries);\n  }\n  return Promise.reject('The file is not a karaoke .zip file');\n};\n\nconst processZip = function (entries) {\n  const audio = entries.filter((entry) => entry.name.endsWith('.mp3'));\n  const video = entries.filter((entry) => entry.name.endsWith('.cdg'));\n  const process = [];\n  if (audio.length && video.length) {\n    process.push(loadAudio(audio[0]));\n    process.push(loadVideo(video[0]));\n    process.push(getTagData(audio[0]));\n    return Promise.all(process);\n  }\n  const errors = [];\n  if (!audio.length) {\n    errors.push('No mp3 audio file present.');\n  }\n  if (!video.length) {\n    errors.push('No cdg video file present.');\n  }\n  return Promise.reject(new Error(errors.join(' ')));\n};\n\nexport default class CDGFileLoader {\n  static loadZipFile(filePath) {\n    return getDataFile(filePath)\n      .then((fileBuffer) => loadZipBuffer(fileBuffer))\n      .then((zipFile) => getKaraokeFiles(zipFile))\n      .then((entries) => processZip(entries))\n      .catch((error) => Promise.reject(error));\n  }\n\n  static loadFileBuffer(fileBuffer) {\n    return loadZipBuffer(fileBuffer)\n      .then((zipFile) => getKaraokeFiles(zipFile))\n      .then((entries) => processZip(entries))\n      .catch((err) => Promise.reject(err));\n  }\n}\n","/*\n * SoundTouch JS v0.1.30 audio processing library\n * Copyright (c) Olli Parviainen\n * Copyright (c) Ryan Berdeen\n * Copyright (c) Jakub Fiala\n * Copyright (c) Steve 'Cutter' Blades\n *\n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n */\n\nclass FifoSampleBuffer {\n  constructor() {\n    this._vector = new Float32Array();\n    this._position = 0;\n    this._frameCount = 0;\n  }\n  get vector() {\n    return this._vector;\n  }\n  get position() {\n    return this._position;\n  }\n  get startIndex() {\n    return this._position * 2;\n  }\n  get frameCount() {\n    return this._frameCount;\n  }\n  get endIndex() {\n    return (this._position + this._frameCount) * 2;\n  }\n  clear() {\n    this.receive(this._frameCount);\n    this.rewind();\n  }\n  put(numFrames) {\n    this._frameCount += numFrames;\n  }\n  putSamples(samples, position, numFrames = 0) {\n    position = position || 0;\n    const sourceOffset = position * 2;\n    if (!(numFrames >= 0)) {\n      numFrames = (samples.length - sourceOffset) / 2;\n    }\n    const numSamples = numFrames * 2;\n    this.ensureCapacity(numFrames + this._frameCount);\n    const destOffset = this.endIndex;\n    this.vector.set(samples.subarray(sourceOffset, sourceOffset + numSamples), destOffset);\n    this._frameCount += numFrames;\n  }\n  putBuffer(buffer, position, numFrames = 0) {\n    position = position || 0;\n    if (!(numFrames >= 0)) {\n      numFrames = buffer.frameCount - position;\n    }\n    this.putSamples(buffer.vector, buffer.position + position, numFrames);\n  }\n  receive(numFrames) {\n    if (!(numFrames >= 0) || numFrames > this._frameCount) {\n      numFrames = this.frameCount;\n    }\n    this._frameCount -= numFrames;\n    this._position += numFrames;\n  }\n  receiveSamples(output, numFrames = 0) {\n    const numSamples = numFrames * 2;\n    const sourceOffset = this.startIndex;\n    output.set(this._vector.subarray(sourceOffset, sourceOffset + numSamples));\n    this.receive(numFrames);\n  }\n  extract(output, position = 0, numFrames = 0) {\n    const sourceOffset = this.startIndex + position * 2;\n    const numSamples = numFrames * 2;\n    output.set(this._vector.subarray(sourceOffset, sourceOffset + numSamples));\n  }\n  ensureCapacity(numFrames = 0) {\n    const minLength = parseInt(numFrames * 2);\n    if (this._vector.length < minLength) {\n      const newVector = new Float32Array(minLength);\n      newVector.set(this._vector.subarray(this.startIndex, this.endIndex));\n      this._vector = newVector;\n      this._position = 0;\n    } else {\n      this.rewind();\n    }\n  }\n  ensureAdditionalCapacity(numFrames = 0) {\n    this.ensureCapacity(this._frameCount + numFrames);\n  }\n  rewind() {\n    if (this._position > 0) {\n      this._vector.set(this._vector.subarray(this.startIndex, this.endIndex));\n      this._position = 0;\n    }\n  }\n}\n\nclass AbstractFifoSamplePipe {\n  constructor(createBuffers) {\n    if (createBuffers) {\n      this._inputBuffer = new FifoSampleBuffer();\n      this._outputBuffer = new FifoSampleBuffer();\n    } else {\n      this._inputBuffer = this._outputBuffer = null;\n    }\n  }\n  get inputBuffer() {\n    return this._inputBuffer;\n  }\n  set inputBuffer(inputBuffer) {\n    this._inputBuffer = inputBuffer;\n  }\n  get outputBuffer() {\n    return this._outputBuffer;\n  }\n  set outputBuffer(outputBuffer) {\n    this._outputBuffer = outputBuffer;\n  }\n  clear() {\n    this._inputBuffer.clear();\n    this._outputBuffer.clear();\n  }\n}\n\nclass RateTransposer extends AbstractFifoSamplePipe {\n  constructor(createBuffers) {\n    super(createBuffers);\n    this.reset();\n    this._rate = 1;\n  }\n  set rate(rate) {\n    this._rate = rate;\n  }\n  reset() {\n    this.slopeCount = 0;\n    this.prevSampleL = 0;\n    this.prevSampleR = 0;\n  }\n  clone() {\n    const result = new RateTransposer();\n    result.rate = this._rate;\n    return result;\n  }\n  process() {\n    const numFrames = this._inputBuffer.frameCount;\n    this._outputBuffer.ensureAdditionalCapacity(numFrames / this._rate + 1);\n    const numFramesOutput = this.transpose(numFrames);\n    this._inputBuffer.receive();\n    this._outputBuffer.put(numFramesOutput);\n  }\n  transpose(numFrames = 0) {\n    if (numFrames === 0) {\n      return 0;\n    }\n    const src = this._inputBuffer.vector;\n    const srcOffset = this._inputBuffer.startIndex;\n    const dest = this._outputBuffer.vector;\n    const destOffset = this._outputBuffer.endIndex;\n    let used = 0;\n    let i = 0;\n    while (this.slopeCount < 1.0) {\n      dest[destOffset + 2 * i] = (1.0 - this.slopeCount) * this.prevSampleL + this.slopeCount * src[srcOffset];\n      dest[destOffset + 2 * i + 1] = (1.0 - this.slopeCount) * this.prevSampleR + this.slopeCount * src[srcOffset + 1];\n      i = i + 1;\n      this.slopeCount += this._rate;\n    }\n    this.slopeCount -= 1.0;\n    if (numFrames !== 1) {\n      out: while (true) {\n        while (this.slopeCount > 1.0) {\n          this.slopeCount -= 1.0;\n          used = used + 1;\n          if (used >= numFrames - 1) {\n            break out;\n          }\n        }\n        const srcIndex = srcOffset + 2 * used;\n        dest[destOffset + 2 * i] = (1.0 - this.slopeCount) * src[srcIndex] + this.slopeCount * src[srcIndex + 2];\n        dest[destOffset + 2 * i + 1] = (1.0 - this.slopeCount) * src[srcIndex + 1] + this.slopeCount * src[srcIndex + 3];\n        i = i + 1;\n        this.slopeCount += this._rate;\n      }\n    }\n    this.prevSampleL = src[srcOffset + 2 * numFrames - 2];\n    this.prevSampleR = src[srcOffset + 2 * numFrames - 1];\n    return i;\n  }\n}\n\nclass FilterSupport {\n  constructor(pipe) {\n    this._pipe = pipe;\n  }\n  get pipe() {\n    return this._pipe;\n  }\n  get inputBuffer() {\n    return this._pipe.inputBuffer;\n  }\n  get outputBuffer() {\n    return this._pipe.outputBuffer;\n  }\n  fillInputBuffer() {\n    throw new Error('fillInputBuffer() not overridden');\n  }\n  fillOutputBuffer(numFrames = 0) {\n    while (this.outputBuffer.frameCount < numFrames) {\n      const numInputFrames = 8192 * 2 - this.inputBuffer.frameCount;\n      this.fillInputBuffer(numInputFrames);\n      if (this.inputBuffer.frameCount < 8192 * 2) {\n        break;\n      }\n      this._pipe.process();\n    }\n  }\n  clear() {\n    this._pipe.clear();\n  }\n}\n\nconst noop = function () {\n  return;\n};\n\nclass SimpleFilter extends FilterSupport {\n  constructor(sourceSound, pipe, callback = noop) {\n    super(pipe);\n    this.callback = callback;\n    this.sourceSound = sourceSound;\n    this.historyBufferSize = 22050;\n    this._sourcePosition = 0;\n    this.outputBufferPosition = 0;\n    this._position = 0;\n  }\n  get position() {\n    return this._position;\n  }\n  set position(position) {\n    if (position > this._position) {\n      throw new RangeError('New position may not be greater than current position');\n    }\n    const newOutputBufferPosition = this.outputBufferPosition - (this._position - position);\n    if (newOutputBufferPosition < 0) {\n      throw new RangeError('New position falls outside of history buffer');\n    }\n    this.outputBufferPosition = newOutputBufferPosition;\n    this._position = position;\n  }\n  get sourcePosition() {\n    return this._sourcePosition;\n  }\n  set sourcePosition(sourcePosition) {\n    this.clear();\n    this._sourcePosition = sourcePosition;\n  }\n  onEnd() {\n    this.callback();\n  }\n  fillInputBuffer(numFrames = 0) {\n    const samples = new Float32Array(numFrames * 2);\n    const numFramesExtracted = this.sourceSound.extract(samples, numFrames, this._sourcePosition);\n    this._sourcePosition += numFramesExtracted;\n    this.inputBuffer.putSamples(samples, 0, numFramesExtracted);\n  }\n  extract(target, numFrames = 0) {\n    this.fillOutputBuffer(this.outputBufferPosition + numFrames);\n    const numFramesExtracted = Math.min(numFrames, this.outputBuffer.frameCount - this.outputBufferPosition);\n    this.outputBuffer.extract(target, this.outputBufferPosition, numFramesExtracted);\n    const currentFrames = this.outputBufferPosition + numFramesExtracted;\n    this.outputBufferPosition = Math.min(this.historyBufferSize, currentFrames);\n    this.outputBuffer.receive(Math.max(currentFrames - this.historyBufferSize, 0));\n    this._position += numFramesExtracted;\n    return numFramesExtracted;\n  }\n  handleSampleData(event) {\n    this.extract(event.data, 4096);\n  }\n  clear() {\n    super.clear();\n    this.outputBufferPosition = 0;\n  }\n}\n\nconst USE_AUTO_SEQUENCE_LEN = 0;\nconst DEFAULT_SEQUENCE_MS = USE_AUTO_SEQUENCE_LEN;\nconst USE_AUTO_SEEKWINDOW_LEN = 0;\nconst DEFAULT_SEEKWINDOW_MS = USE_AUTO_SEEKWINDOW_LEN;\nconst DEFAULT_OVERLAP_MS = 8;\nconst _SCAN_OFFSETS = [[124, 186, 248, 310, 372, 434, 496, 558, 620, 682, 744, 806, 868, 930, 992, 1054, 1116, 1178, 1240, 1302, 1364, 1426, 1488, 0], [-100, -75, -50, -25, 25, 50, 75, 100, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [-20, -15, -10, -5, 5, 10, 15, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [-4, -3, -2, -1, 1, 2, 3, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]];\nconst AUTOSEQ_TEMPO_LOW = 0.5;\nconst AUTOSEQ_TEMPO_TOP = 2.0;\nconst AUTOSEQ_AT_MIN = 125.0;\nconst AUTOSEQ_AT_MAX = 50.0;\nconst AUTOSEQ_K = (AUTOSEQ_AT_MAX - AUTOSEQ_AT_MIN) / (AUTOSEQ_TEMPO_TOP - AUTOSEQ_TEMPO_LOW);\nconst AUTOSEQ_C = AUTOSEQ_AT_MIN - AUTOSEQ_K * AUTOSEQ_TEMPO_LOW;\nconst AUTOSEEK_AT_MIN = 25.0;\nconst AUTOSEEK_AT_MAX = 15.0;\nconst AUTOSEEK_K = (AUTOSEEK_AT_MAX - AUTOSEEK_AT_MIN) / (AUTOSEQ_TEMPO_TOP - AUTOSEQ_TEMPO_LOW);\nconst AUTOSEEK_C = AUTOSEEK_AT_MIN - AUTOSEEK_K * AUTOSEQ_TEMPO_LOW;\nclass Stretch extends AbstractFifoSamplePipe {\n  constructor(createBuffers) {\n    super(createBuffers);\n    this._quickSeek = true;\n    this.midBufferDirty = false;\n    this.midBuffer = null;\n    this.overlapLength = 0;\n    this.autoSeqSetting = true;\n    this.autoSeekSetting = true;\n    this._tempo = 1;\n    this.setParameters(44100, DEFAULT_SEQUENCE_MS, DEFAULT_SEEKWINDOW_MS, DEFAULT_OVERLAP_MS);\n  }\n  clear() {\n    super.clear();\n    this.clearMidBuffer();\n  }\n  clearMidBuffer() {\n    if (this.midBufferDirty) {\n      this.midBufferDirty = false;\n      this.midBuffer = null;\n    }\n  }\n  setParameters(sampleRate, sequenceMs, seekWindowMs, overlapMs) {\n    if (sampleRate > 0) {\n      this.sampleRate = sampleRate;\n    }\n    if (overlapMs > 0) {\n      this.overlapMs = overlapMs;\n    }\n    if (sequenceMs > 0) {\n      this.sequenceMs = sequenceMs;\n      this.autoSeqSetting = false;\n    } else {\n      this.autoSeqSetting = true;\n    }\n    if (seekWindowMs > 0) {\n      this.seekWindowMs = seekWindowMs;\n      this.autoSeekSetting = false;\n    } else {\n      this.autoSeekSetting = true;\n    }\n    this.calculateSequenceParameters();\n    this.calculateOverlapLength(this.overlapMs);\n    this.tempo = this._tempo;\n  }\n  set tempo(newTempo) {\n    let intskip;\n    this._tempo = newTempo;\n    this.calculateSequenceParameters();\n    this.nominalSkip = this._tempo * (this.seekWindowLength - this.overlapLength);\n    this.skipFract = 0;\n    intskip = Math.floor(this.nominalSkip + 0.5);\n    this.sampleReq = Math.max(intskip + this.overlapLength, this.seekWindowLength) + this.seekLength;\n  }\n  get tempo() {\n    return this._tempo;\n  }\n  get inputChunkSize() {\n    return this.sampleReq;\n  }\n  get outputChunkSize() {\n    return this.overlapLength + Math.max(0, this.seekWindowLength - 2 * this.overlapLength);\n  }\n  calculateOverlapLength(overlapInMsec = 0) {\n    let newOvl;\n    newOvl = this.sampleRate * overlapInMsec / 1000;\n    newOvl = newOvl < 16 ? 16 : newOvl;\n    newOvl -= newOvl % 8;\n    this.overlapLength = newOvl;\n    this.refMidBuffer = new Float32Array(this.overlapLength * 2);\n    this.midBuffer = new Float32Array(this.overlapLength * 2);\n  }\n  checkLimits(x, mi, ma) {\n    return x < mi ? mi : x > ma ? ma : x;\n  }\n  calculateSequenceParameters() {\n    let seq;\n    let seek;\n    if (this.autoSeqSetting) {\n      seq = AUTOSEQ_C + AUTOSEQ_K * this._tempo;\n      seq = this.checkLimits(seq, AUTOSEQ_AT_MAX, AUTOSEQ_AT_MIN);\n      this.sequenceMs = Math.floor(seq + 0.5);\n    }\n    if (this.autoSeekSetting) {\n      seek = AUTOSEEK_C + AUTOSEEK_K * this._tempo;\n      seek = this.checkLimits(seek, AUTOSEEK_AT_MAX, AUTOSEEK_AT_MIN);\n      this.seekWindowMs = Math.floor(seek + 0.5);\n    }\n    this.seekWindowLength = Math.floor(this.sampleRate * this.sequenceMs / 1000);\n    this.seekLength = Math.floor(this.sampleRate * this.seekWindowMs / 1000);\n  }\n  set quickSeek(enable) {\n    this._quickSeek = enable;\n  }\n  clone() {\n    const result = new Stretch();\n    result.tempo = this._tempo;\n    result.setParameters(this.sampleRate, this.sequenceMs, this.seekWindowMs, this.overlapMs);\n    return result;\n  }\n  seekBestOverlapPosition() {\n    return this._quickSeek ? this.seekBestOverlapPositionStereoQuick() : this.seekBestOverlapPositionStereo();\n  }\n  seekBestOverlapPositionStereo() {\n    let bestOffset;\n    let bestCorrelation;\n    let correlation;\n    let i = 0;\n    this.preCalculateCorrelationReferenceStereo();\n    bestOffset = 0;\n    bestCorrelation = Number.MIN_VALUE;\n    for (; i < this.seekLength; i = i + 1) {\n      correlation = this.calculateCrossCorrelationStereo(2 * i, this.refMidBuffer);\n      if (correlation > bestCorrelation) {\n        bestCorrelation = correlation;\n        bestOffset = i;\n      }\n    }\n    return bestOffset;\n  }\n  seekBestOverlapPositionStereoQuick() {\n    let bestOffset;\n    let bestCorrelation;\n    let correlation;\n    let scanCount = 0;\n    let correlationOffset;\n    let tempOffset;\n    this.preCalculateCorrelationReferenceStereo();\n    bestCorrelation = Number.MIN_VALUE;\n    bestOffset = 0;\n    correlationOffset = 0;\n    tempOffset = 0;\n    for (; scanCount < 4; scanCount = scanCount + 1) {\n      let j = 0;\n      while (_SCAN_OFFSETS[scanCount][j]) {\n        tempOffset = correlationOffset + _SCAN_OFFSETS[scanCount][j];\n        if (tempOffset >= this.seekLength) {\n          break;\n        }\n        correlation = this.calculateCrossCorrelationStereo(2 * tempOffset, this.refMidBuffer);\n        if (correlation > bestCorrelation) {\n          bestCorrelation = correlation;\n          bestOffset = tempOffset;\n        }\n        j = j + 1;\n      }\n      correlationOffset = bestOffset;\n    }\n    return bestOffset;\n  }\n  preCalculateCorrelationReferenceStereo() {\n    let i = 0;\n    let context;\n    let temp;\n    for (; i < this.overlapLength; i = i + 1) {\n      temp = i * (this.overlapLength - i);\n      context = i * 2;\n      this.refMidBuffer[context] = this.midBuffer[context] * temp;\n      this.refMidBuffer[context + 1] = this.midBuffer[context + 1] * temp;\n    }\n  }\n  calculateCrossCorrelationStereo(mixingPosition, compare) {\n    const mixing = this._inputBuffer.vector;\n    mixingPosition += this._inputBuffer.startIndex;\n    let correlation = 0;\n    let i = 2;\n    const calcLength = 2 * this.overlapLength;\n    let mixingOffset;\n    for (; i < calcLength; i = i + 2) {\n      mixingOffset = i + mixingPosition;\n      correlation += mixing[mixingOffset] * compare[i] + mixing[mixingOffset + 1] * compare[i + 1];\n    }\n    return correlation;\n  }\n  overlap(overlapPosition) {\n    this.overlapStereo(2 * overlapPosition);\n  }\n  overlapStereo(inputPosition) {\n    const input = this._inputBuffer.vector;\n    inputPosition += this._inputBuffer.startIndex;\n    const output = this._outputBuffer.vector;\n    const outputPosition = this._outputBuffer.endIndex;\n    let i = 0;\n    let context;\n    let tempFrame;\n    const frameScale = 1 / this.overlapLength;\n    let fi;\n    let inputOffset;\n    let outputOffset;\n    for (; i < this.overlapLength; i = i + 1) {\n      tempFrame = (this.overlapLength - i) * frameScale;\n      fi = i * frameScale;\n      context = 2 * i;\n      inputOffset = context + inputPosition;\n      outputOffset = context + outputPosition;\n      output[outputOffset + 0] = input[inputOffset + 0] * fi + this.midBuffer[context + 0] * tempFrame;\n      output[outputOffset + 1] = input[inputOffset + 1] * fi + this.midBuffer[context + 1] * tempFrame;\n    }\n  }\n  process() {\n    let offset;\n    let temp;\n    let overlapSkip;\n    if (this.midBuffer === null) {\n      if (this._inputBuffer.frameCount < this.overlapLength) {\n        return;\n      }\n      this.midBuffer = new Float32Array(this.overlapLength * 2);\n      this._inputBuffer.receiveSamples(this.midBuffer, this.overlapLength);\n    }\n    while (this._inputBuffer.frameCount >= this.sampleReq) {\n      offset = this.seekBestOverlapPosition();\n      this._outputBuffer.ensureAdditionalCapacity(this.overlapLength);\n      this.overlap(Math.floor(offset));\n      this._outputBuffer.put(this.overlapLength);\n      temp = this.seekWindowLength - 2 * this.overlapLength;\n      if (temp > 0) {\n        this._outputBuffer.putBuffer(this._inputBuffer, offset + this.overlapLength, temp);\n      }\n      const start = this._inputBuffer.startIndex + 2 * (offset + this.seekWindowLength - this.overlapLength);\n      this.midBuffer.set(this._inputBuffer.vector.subarray(start, start + 2 * this.overlapLength));\n      this.skipFract += this.nominalSkip;\n      overlapSkip = Math.floor(this.skipFract);\n      this.skipFract -= overlapSkip;\n      this._inputBuffer.receive(overlapSkip);\n    }\n  }\n}\n\nconst testFloatEqual = function (a, b) {\n  return (a > b ? a - b : b - a) > 1e-10;\n};\n\nclass SoundTouch {\n  constructor() {\n    this.transposer = new RateTransposer(false);\n    this.stretch = new Stretch(false);\n    this._inputBuffer = new FifoSampleBuffer();\n    this._intermediateBuffer = new FifoSampleBuffer();\n    this._outputBuffer = new FifoSampleBuffer();\n    this._rate = 0;\n    this._tempo = 0;\n    this.virtualPitch = 1.0;\n    this.virtualRate = 1.0;\n    this.virtualTempo = 1.0;\n    this.calculateEffectiveRateAndTempo();\n  }\n  clear() {\n    this.transposer.clear();\n    this.stretch.clear();\n  }\n  clone() {\n    const result = new SoundTouch();\n    result.rate = this.rate;\n    result.tempo = this.tempo;\n    return result;\n  }\n  get rate() {\n    return this._rate;\n  }\n  set rate(rate) {\n    this.virtualRate = rate;\n    this.calculateEffectiveRateAndTempo();\n  }\n  set rateChange(rateChange) {\n    this._rate = 1.0 + 0.01 * rateChange;\n  }\n  get tempo() {\n    return this._tempo;\n  }\n  set tempo(tempo) {\n    this.virtualTempo = tempo;\n    this.calculateEffectiveRateAndTempo();\n  }\n  set tempoChange(tempoChange) {\n    this.tempo = 1.0 + 0.01 * tempoChange;\n  }\n  set pitch(pitch) {\n    this.virtualPitch = pitch;\n    this.calculateEffectiveRateAndTempo();\n  }\n  set pitchOctaves(pitchOctaves) {\n    this.pitch = Math.exp(0.69314718056 * pitchOctaves);\n    this.calculateEffectiveRateAndTempo();\n  }\n  set pitchSemitones(pitchSemitones) {\n    this.pitchOctaves = pitchSemitones / 12.0;\n  }\n  get inputBuffer() {\n    return this._inputBuffer;\n  }\n  get outputBuffer() {\n    return this._outputBuffer;\n  }\n  calculateEffectiveRateAndTempo() {\n    const previousTempo = this._tempo;\n    const previousRate = this._rate;\n    this._tempo = this.virtualTempo / this.virtualPitch;\n    this._rate = this.virtualRate * this.virtualPitch;\n    if (testFloatEqual(this._tempo, previousTempo)) {\n      this.stretch.tempo = this._tempo;\n    }\n    if (testFloatEqual(this._rate, previousRate)) {\n      this.transposer.rate = this._rate;\n    }\n    if (this._rate > 1.0) {\n      if (this._outputBuffer != this.transposer.outputBuffer) {\n        this.stretch.inputBuffer = this._inputBuffer;\n        this.stretch.outputBuffer = this._intermediateBuffer;\n        this.transposer.inputBuffer = this._intermediateBuffer;\n        this.transposer.outputBuffer = this._outputBuffer;\n      }\n    } else {\n      if (this._outputBuffer != this.stretch.outputBuffer) {\n        this.transposer.inputBuffer = this._inputBuffer;\n        this.transposer.outputBuffer = this._intermediateBuffer;\n        this.stretch.inputBuffer = this._intermediateBuffer;\n        this.stretch.outputBuffer = this._outputBuffer;\n      }\n    }\n  }\n  process() {\n    if (this._rate > 1.0) {\n      this.stretch.process();\n      this.transposer.process();\n    } else {\n      this.transposer.process();\n      this.stretch.process();\n    }\n  }\n}\n\nclass WebAudioBufferSource {\n  constructor(buffer) {\n    this.buffer = buffer;\n    this._position = 0;\n  }\n  get dualChannel() {\n    return this.buffer.numberOfChannels > 1;\n  }\n  get position() {\n    return this._position;\n  }\n  set position(value) {\n    this._position = value;\n  }\n  extract(target, numFrames = 0, position = 0) {\n    this.position = position;\n    let left = this.buffer.getChannelData(0);\n    let right = this.dualChannel ? this.buffer.getChannelData(1) : this.buffer.getChannelData(0);\n    let i = 0;\n    for (; i < numFrames; i++) {\n      target[i * 2] = left[i + position];\n      target[i * 2 + 1] = right[i + position];\n    }\n    return Math.min(numFrames, left.length - position);\n  }\n}\n\nconst getWebAudioNode = function (context, filter, sourcePositionCallback = noop, bufferSize = 4096) {\n  const node = context.createScriptProcessor(bufferSize, 2, 2);\n  const samples = new Float32Array(bufferSize * 2);\n  node.onaudioprocess = event => {\n    let left = event.outputBuffer.getChannelData(0);\n    let right = event.outputBuffer.getChannelData(1);\n    let framesExtracted = filter.extract(samples, bufferSize);\n    sourcePositionCallback(filter.sourcePosition);\n    if (framesExtracted === 0) {\n      filter.onEnd();\n    }\n    let i = 0;\n    for (; i < framesExtracted; i++) {\n      left[i] = samples[i * 2];\n      right[i] = samples[i * 2 + 1];\n    }\n  };\n  return node;\n};\n\nconst pad = function (n, width, z) {\n  z = z || '0';\n  n = n + '';\n  return n.length >= width ? n : new Array(width - n.length + 1).join(z) + n;\n};\nconst minsSecs = function (secs) {\n  const mins = Math.floor(secs / 60);\n  const seconds = secs - mins * 60;\n  return `${mins}:${pad(parseInt(seconds), 2)}`;\n};\n\nconst onUpdate = function (sourcePosition) {\n  const currentTimePlayed = this.timePlayed;\n  const sampleRate = this.sampleRate;\n  this.sourcePosition = sourcePosition;\n  this.timePlayed = sourcePosition / sampleRate;\n  if (currentTimePlayed !== this.timePlayed) {\n    const timePlayed = new CustomEvent('play', {\n      detail: {\n        timePlayed: this.timePlayed,\n        formattedTimePlayed: this.formattedTimePlayed,\n        percentagePlayed: this.percentagePlayed\n      }\n    });\n    this._node.dispatchEvent(timePlayed);\n  }\n};\nclass PitchShifter {\n  constructor(context, buffer, bufferSize, onEnd = noop) {\n    this._soundtouch = new SoundTouch();\n    const source = new WebAudioBufferSource(buffer);\n    this.timePlayed = 0;\n    this.sourcePosition = 0;\n    this._filter = new SimpleFilter(source, this._soundtouch, onEnd);\n    this._node = getWebAudioNode(context, this._filter, sourcePostion => onUpdate.call(this, sourcePostion), bufferSize);\n    this.tempo = 1;\n    this.rate = 1;\n    this.duration = buffer.duration;\n    this.sampleRate = context.sampleRate;\n    this.listeners = [];\n  }\n  get formattedDuration() {\n    return minsSecs(this.duration);\n  }\n  get formattedTimePlayed() {\n    return minsSecs(this.timePlayed);\n  }\n  get percentagePlayed() {\n    return 100 * this._filter.sourcePosition / (this.duration * this.sampleRate);\n  }\n  set percentagePlayed(perc) {\n    this._filter.sourcePosition = parseInt(perc * this.duration * this.sampleRate);\n    this.sourcePosition = this._filter.sourcePosition;\n    this.timePlayed = this.sourcePosition / this.sampleRate;\n  }\n  get node() {\n    return this._node;\n  }\n  set pitch(pitch) {\n    this._soundtouch.pitch = pitch;\n  }\n  set pitchSemitones(semitone) {\n    this._soundtouch.pitchSemitones = semitone;\n  }\n  set rate(rate) {\n    this._soundtouch.rate = rate;\n  }\n  set tempo(tempo) {\n    this._soundtouch.tempo = tempo;\n  }\n  connect(toNode) {\n    this._node.connect(toNode);\n  }\n  disconnect() {\n    this._node.disconnect();\n  }\n  on(eventName, cb) {\n    this.listeners.push({\n      name: eventName,\n      cb: cb\n    });\n    this._node.addEventListener(eventName, event => cb(event.detail));\n  }\n  off(eventName = null) {\n    let listeners = this.listeners;\n    if (eventName) {\n      listeners = listeners.filter(e => e.name === eventName);\n    }\n    listeners.forEach(e => {\n      this._node.removeEventListener(e.name, event => e.cb(event.detail));\n    });\n  }\n}\n\nexport { AbstractFifoSamplePipe, PitchShifter, RateTransposer, SimpleFilter, SoundTouch, Stretch, WebAudioBufferSource, getWebAudioNode };\n//# sourceMappingURL=soundtouch.js.map\n","// From https://github.com/AntonLapshin/proxy-observable#readme\n/* eslint-disable */\nexport class PubSub {\n    /**\n     * Creates an instance of PubSub\n     */\n    constructor() {\n        this.fns = { any: [] };\n    }\n\n    /**\n     * Checks if a event has at least one subscription\n     *\n     * @param {string} e Event name\n     * @returns {boolean}\n     */\n    has(e) {\n        return (e in this.fns && this.fns[e].length > 0) || this.fns.any.length > 0;\n    }\n\n    /**\n     * Subscribes on event\n     *\n     * @param {string} e Event name\n     * @param {function} fn Callback\n     * @returns {function} Input callback\n     */\n    on(e, fn) {\n        if (e in this.fns === false) {\n            this.fns[e] = [];\n        }\n        this.fns[e].push(fn);\n        return fn;\n    }\n\n    /**\n     * Calls the event's callbacks\n     *\n     * @param {string} e Event name\n     * @param {any} value New value\n     * @param {any} prev Previous value\n     * @returns {object} Observable\n     */\n    fire(e, value, prev) {\n        this.fns.any.concat(e in this.fns ? this.fns[e] : []).forEach(fn => fn(value, prev, e));\n        return this;\n    }\n\n    /**\n     * Unsubscribes from event\n     *\n     * @param {function} fn Callback\n     * @returns {boolean} true if successfully unsubscribed\n     */\n    off(fn) {\n        for (const e in this.fns) {\n            const fns = this.fns[e];\n            for (let i = 0; i < fns.length; i++) {\n                if (fns[i] === fn) {\n                    fns.splice(i, 1);\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Subscribes on event once\n     *\n     * @param {string} e Event name\n     * @param {function} fn Callback\n     * @returns {function} Input callback\n     */\n    once(e, fn) {\n        const method = (value, prev, prop) => {\n            fn(value, prev, prop);\n            this.off(method);\n        };\n        this.on(e, method);\n        return fn;\n    }\n}\n","// From https://github.com/AntonLapshin/proxy-observable#readme\n/* eslint-disable */\nimport { PubSub } from './pubsub.js';\n\n/**\n * Creates a proxy observable for an object or array\n *\n * @param {object|Observable} target Input Object\n * @returns {Observable} Observable (ES6 Proxy)\n */\nexport default target => {\n    if (target.on && target.off) {\n        return target;\n    }\n    const pub = new PubSub();\n    const observable = new Proxy(target, {\n        get: (target, prop) => {\n            if (prop in target) {\n                if (target.constructor === Array) {\n                    let v = observable;\n                    if (prop === 'pop') {\n                        v = target[target.length - 1];\n                    } else if (prop === 'shift') {\n                        v = target[0];\n                    }\n                    if (prop !== 'push' && prop !== 'length') {\n                        pub.fire(prop, v);\n                    }\n                }\n                return target[prop];\n            } else if (prop === 'on') {\n                return pub.on.bind(pub);\n            } else if (prop === 'once') {\n                return pub.once.bind(pub);\n            } else if (prop === 'off') {\n                return pub.off.bind(pub);\n            }\n            return undefined;\n        },\n        set: (target, prop, v) => {\n            if (target.constructor === Array) {\n                if (prop !== 'length') {\n                    pub.fire('change', v);\n                }\n            } else if (pub.has(prop)) {\n                pub.fire(prop, v, target[prop]);\n            }\n            target[prop] = v;\n            return true;\n        }\n    });\n\n    return observable;\n};\n","import './karaokeplayer.scss';\nimport CDGPlayer from '../cdg/CDGPlayer.js';\nimport CDGFileLoader from '../loader/CDGFileLoader.js';\nimport { PitchShifter } from 'soundtouchjs';\nimport Deferred from '../utilities/deferred.js';\nimport {\n  WIDTH,\n  HEIGHT,\n  GAIN_DEFAULT,\n  SCALE_DEFAULT,\n  PITCH_DEFAULT,\n  START_TIME,\n  FILTER_PLAYBACK_OFFSET,\n} from '../cdg/constants';\nimport { isString } from '../utilities/is.js';\nimport observable from '../observable/observable.js';\n\nconst createDisplayCanvas = function (width, height) {\n  const canvas = document.createElement('canvas');\n  canvas.width = width;\n  canvas.height = height;\n  return canvas;\n};\n\nconst createCanvasContext = function (canvas) {\n  const ctx = canvas.getContext('2d');\n  ctx.webkitImageSmoothingEnabled = false;\n  ctx.mozImageSmoothingEnabled = false;\n  ctx.msImageSmoothingEnabled = false;\n  ctx.imageSmoothingEnabled = false;\n  return ctx;\n};\n\nconst copyContextToCanvas = function (context) {\n  // If there's transparency, clear the canvas first\n  if (context.keyColor >= 0) {\n    this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);\n  }\n  // Copy from source canvas to the target canvas\n  this.ctx.drawImage(\n    context.canvas,\n    0,\n    0,\n    context.canvas.width,\n    context.canvas.height,\n    0,\n    0,\n    this.canvas.width,\n    this.canvas.height\n  );\n};\n\nconst clearCanvas = function (context, canvas) {\n  context.clearRect(0, 0, canvas.width, canvas.height);\n};\n\nconst loadAudio = function (buffer) {\n  if (this.shifter) {\n    this.shifter.off();\n  }\n  return this.audio\n    .decodeAudioData(buffer)\n    .then((audioBuffer) => {\n      this.shifter = observable(\n        new PitchShifter(this.audio, audioBuffer, 1024, () => {\n          this.stop();\n        })\n      );\n      this.shifter.on('play', (detail) => {\n        this.props.timePlayed = detail.formattedTimePlayed;\n        this.props.percentagePlayed = detail.percentagePlayed;\n        this.player.sync(detail.timePlayed * 1000 - FILTER_PLAYBACK_OFFSET);\n      });\n      this.shifter.pitch = PITCH_DEFAULT;\n      this.props.trackLength = this.shifter.formattedDuration;\n    })\n    .catch((error) =>\n      Promise.reject(\n        new Error('There was an error decoding the audio file', error)\n      )\n    );\n};\n\nconst loadVideo = function (buffer) {\n  const deferred = new Deferred();\n  if (buffer) {\n    this.player.load(Array.from(buffer));\n    deferred.resolve();\n  } else {\n    deferred.reject(new Error('There was an error loading the video file'));\n  }\n  return deferred.promise;\n};\n\nconst wrapText = function (context, text, x, y, maxWidth, lineHeight) {\n  var words = text.split(' ');\n  var line = '';\n\n  for (var n = 0; n < words.length; n++) {\n    var testLine = line + words[n] + ' ';\n    var metrics = context.measureText(testLine);\n    var testWidth = metrics.width;\n    if (testWidth > maxWidth && n > 0) {\n      context.fillText(line.trim(), x, y);\n      line = words[n] + ' ';\n      y += lineHeight;\n    } else {\n      line = testLine;\n    }\n  }\n  context.fillText(line.trim(), x, y);\n};\n\nconst drawTag = function () {\n  const ctx = this.ctx;\n  const cvs = this.canvas;\n  const maxWidth = cvs.width - 10;\n  let lineHeight = 30;\n  const x = maxWidth / 2;\n  let y = 60;\n  ctx.font = '30px sans-serif';\n  ctx.fillStyle = '#fff';\n  ctx.textAlign = 'center';\n  wrapText(ctx, this.tag.title, x, y, maxWidth, lineHeight);\n  ctx.font = '20px sans-serif';\n  y = cvs.height - 60;\n  wrapText(ctx, `by ${this.tag.artist}`, x, y, maxWidth, lineHeight);\n};\n\nconst loadTag = function (tag) {\n  this.tag = tag && tag.tags;\n  if (this.tag) {\n    return drawTag.call(this);\n  }\n};\n\nconst handleExtractedZip = function (responseArr) {\n  const process = [];\n  process.push(loadAudio.call(this, responseArr[0])); // audio is always first\n  process.push(loadVideo.call(this, responseArr[1])); // video is always second\n  return Promise.all(process)\n    .then(() => {\n      this.props.status = 'File Loaded';\n      this.props.loaded = true;\n      // Display tag after marking player loaded\n      loadTag.call(this, responseArr[2]); // mp3 tag data is always last\n    })\n    .catch((error) => {\n      this.props.status = 'File Loading Failed';\n      return Promise.reject(error);\n    })\n    .then(() => {\n      this.props.loading = false;\n    });\n};\n\nconst setVolume = function (val) {\n  this.gainNode.gain.value = val;\n};\n\nexport class KaraokePlayer {\n  audio = null;\n  gainNode = null;\n  shifter = null;\n\n  wrapper = null;\n  player = null;\n  currentSize = SCALE_DEFAULT;\n  canvas = null;\n  ctx = null;\n\n  props = observable({\n    status: '',\n    loaded: false,\n    loading: false,\n    isPlaying: false,\n    timePlayed: START_TIME,\n    trackLength: START_TIME,\n    percentagePlayed: 0,\n    songVolume: 1,\n    destroy: false,\n  });\n\n  constructor(selector) {\n    this.wrapper = document.querySelector(selector);\n    if (!this.wrapper) {\n      throw new Error(\n        `CDGPlayer: and element was not found with the \"${selector}\" selector`\n      );\n    }\n    this.wrapper.classList.add('cdg-video-wrapper');\n    this.canvas = createDisplayCanvas(WIDTH, HEIGHT);\n    this.canvas.classList.add('cdg-video-player');\n    this.ctx = createCanvasContext(this.canvas);\n    this.player = new CDGPlayer({\n      afterRender: (context) => copyContextToCanvas.call(this, context),\n    });\n    this.wrapper.appendChild(this.canvas);\n    const titleImage = document.createElement('div');\n    titleImage.classList.add('titleImage');\n    this.wrapper.appendChild(titleImage);\n    this.onloaded = this.props.on('loaded', (val) => {\n      if (val) {\n        titleImage.classList.add('hide');\n        return;\n      }\n      titleImage.classList.remove('hide');\n    });\n\n    this.audio = new (window.AudioContext || window.webkitAudioContext)();\n    this.gainNode = this.audio.createGain();\n    this.onvolume = this.props.on('songVolume', (val) => {\n      setVolume.call(this, val);\n    });\n    this.props.songVolume = GAIN_DEFAULT;\n  }\n\n  destroy() {\n    this.wrapper.classList.remove('cdg-video-wrapper');\n    this.stop();\n    this.gainNode.disconnect();\n    if (this.shifter) {\n      this.shifter.off();\n    }\n    this.shifter = null;\n    this.gainNode = null;\n    this.audio = null;\n    this.canvas.remove();\n    this.props.destroy = true;\n    this.props.off('onvolume');\n  }\n\n  load(filePath) {\n    this.stop();\n    clearCanvas(this.ctx, this.canvas);\n    this.props.loading = true;\n    let promise;\n    if (isString(filePath)) {\n      if (!filePath.toLowerCase().endsWith('.zip')) {\n        this.props.loading = false;\n        this.props.status = `${filePath} doesn't appear to be a \".zip\" file.`;\n\n        return Promise.reject(this.props.status);\n      }\n      this.props.status = 'Retrieving File...';\n      promise = CDGFileLoader.loadZipFile(filePath);\n    } else {\n      this.props.status = 'Loading File...';\n      promise = CDGFileLoader.loadFileBuffer(filePath);\n    }\n    return promise\n      .then((zipResponse) => handleExtractedZip.call(this, zipResponse))\n      .catch((error) => Promise.reject(error));\n  }\n\n  togglePlay() {\n    if (this.props.isPlaying) {\n      this.pause();\n    } else {\n      this.start();\n    }\n  }\n\n  start() {\n    clearCanvas.call(this, this.ctx, this.canvas);\n    this.shifter.connect(this.gainNode);\n    this.gainNode.connect(this.audio.destination);\n    // updates for autoplay issues\n    this.audio.resume().then(() => {\n      this.props.isPlaying = true;\n      this.player.play();\n    });\n  }\n\n  pause(playing = false) {\n    this.props.isPlaying = playing;\n    this.shifter.disconnect();\n    /*if (this.timeInterval) {\n      clearInterval(this.timeInterval);\n      this.timeInterval = null;\n    }*/\n    this.player.stop();\n  }\n\n  stop() {\n    if (this.shifter) {\n      this.pause();\n      this.changePlayerPosition(0);\n      drawTag.call(this);\n    }\n  }\n\n  changePlayerPosition(perc) {\n    perc = perc < 0 ? 0 : perc > 100 ? 100 : perc;\n    this.shifter.percentagePlayed = perc;\n    this.props.percentagePlayed = this.shifter.percentagePlayed;\n    this.props.timePlayed = this.shifter.formattedTimePlayed;\n    this.player.reset();\n    if (!perc) {\n      this.props.isPlaying = false;\n      this.props.timePlayed = START_TIME;\n    }\n  }\n\n  changeKey(pitchChange) {\n    pitchChange = pitchChange < -7 ? -7 : pitchChange > 7 ? 7 : pitchChange;\n    this.shifter.pitchSemitones = pitchChange;\n    this.shifter.tempo = 1; // keep the tempo straight\n  }\n\n  volume(change) {\n    const current = this.gainNode.gain.value;\n    const newValue = +(current + change).toFixed(2);\n    this.props.songVolume = newValue < 0 ? 0 : newValue > 1 ? 1 : newValue;\n  }\n\n  toggleMute() {\n    const fallback = this.gainNode.gain.value;\n    this.props.songVolume = fallback ? 0 : this.fallbackVolume;\n    this.fallbackVolume = fallback;\n  }\n}\n","export const isString = function (value) {\n  return typeof value === 'string';\n};\n\nexport const isNumber = function (value) {\n  return typeof value === 'number';\n};\n\nexport const isDate = function (value) {\n  return toString.call(value) === '[object Date]';\n};\n\nexport const isArray = function (arr) {\n  return Array.isArray(arr);\n};\n\nexport const isFunction = function (value) {\n  return typeof value === 'function';\n};\n\nexport const isBoolean = function (value) {\n  return typeof value === 'boolean';\n};\n\nexport const isDefined = function (value) {\n  return typeof value !== 'undefined';\n};\n\nexport const isUndefined = function (value) {\n  return typeof value === 'undefined';\n};\n\nexport const isObject = function (value) {\n  return value !== null && typeof value === 'object';\n};\n\nexport const isPromise = function (obj) {\n  return (\n    !!obj &&\n    (typeof obj === 'object' || typeof obj === 'function') &&\n    typeof obj.then === 'function'\n  );\n};\n\nexport const isError = function (value) {\n  const tag = toString.call(value);\n  switch (tag) {\n    case '[object Error]':\n      return true;\n    case '[object Exception]':\n      return true;\n    case '[object DOMException]':\n      return true;\n    default:\n      return value instanceof Error;\n  }\n};\n","import ctrlTemplate from './cdgcontrols.html';\nimport './cdgcontrols.scss';\nimport { PANEL_POSITION } from '../cdg/constants.js';\n\nconst playIcon = 'icofont-play-alt-1';\nconst pauseIcon = 'icofont-pause';\n\nconst htmlToElement = function(html) {\n  let template = document.createElement('template');\n  html = html.trim();\n  template.innerHTML = html;\n  return template.content.firstChild;\n};\n\nconst setupListeners = function() {\n  const props = this.player.props;\n  this.onloaded = props.on('loaded', val => {\n    if (val) {\n      this.playBtn.removeAttribute('disabled');\n      this.pitch.removeAttribute('disabled');\n      this.volumeBtn.removeAttribute('disabled');\n    } else {\n      this.playBtn.setAttribute('disabled', 'disabled');\n      this.pitch.setAttribute('disabled', 'disabled');\n      this.volumeBtn.setAttribute('disabled', 'disabled');\n    }\n  });\n  this.ontimeplayed = props.on('timePlayed', (val, prev) => {\n    if (val !== prev) {\n      this.timePlayed.innerHTML = val;\n    }\n  });\n  this.onpercentageplayed = props.on('percentagePlayed', (val, prev) => {\n    if (val !== prev) {\n      this.progress.value = val;\n    }\n  });\n  this.ontracklength = props.on('trackLength', (val, prev) => {\n    if (val !== prev) {\n      this.trackLength.innerHTML = val;\n    }\n  });\n  this.ondestroy = props.on('destroy', val => {\n    if (val) {\n      removeListeners.call(this);\n    }\n  });\n  this.onplay = props.on('isPlaying', val => {\n    this.playIcn.classList.remove(playIcon, pauseIcon);\n    this.playIcn.classList.add(val ? pauseIcon : playIcon);\n  });\n\n  this.onvolume = props.on('songVolume', val => {\n    const icn = this.volumeIcn;\n    this.volumeSlider.value = val;\n    if (val) {\n      if (icn.classList.contains('mute')) {\n        icn.classList.remove('mute');\n        return;\n      }\n      return;\n    }\n    icn.classList.add('mute');\n  });\n\n  this.playBtn.addEventListener('click', () => this.player.togglePlay());\n  this.progress.addEventListener('click', event => changePosition.call(this, event));\n  this.pitch.addEventListener('change', () => changeKey.call(this));\n  this.volumeSlider.addEventListener('change', () => changeVolume.call(this));\n};\n\nconst removeListeners = function() {\n  const props = this.player.props;\n  props.off(this.onloaded);\n  props.off(this.ontimeplayed);\n  props.off(this.onpercentageplayed);\n  props.off(this.ontracklength);\n  props.off(this.ondestroy);\n  props.off(this.onplay);\n  props.off(this.onvolume);\n  this.playBtn.removeEventListener('click', () => this.player.togglePlay());\n  this.progress.removeEventListener('click', event => changePosition.call(this, event));\n  this.pitch.removeEventListener('change', () => changeKey.call(this));\n  this.volumeSlider.removeEventListener('change', () => changeVolume.call(this));\n};\n\nconst changePosition = function(event) {\n  const pos = event.target.getBoundingClientRect();\n  const relX = event.pageX - pos.x;\n  const perc = relX / event.target.offsetWidth;\n  this.player.changePlayerPosition(perc);\n};\n\nconst changeKey = function() {\n  const val = this.pitch.value;\n  if (isNaN(val)) {\n    this.pitch.value = this.fallbackPitch;\n    return;\n  }\n  this.fallbackPitch = val < -7 ? -7 : val > 7 ? 7 : val;\n  this.player.changeKey(this.fallbackPitch);\n};\n\nconst changeVolume = function() {\n  this.player.props.songVolume = +(parseFloat(this.volumeSlider.value) + 0).toFixed(2);\n};\n\nexport default class CDGControls {\n  controls = htmlToElement(ctrlTemplate);\n  player = null;\n\n  playBtn = null;\n  playIcn = null;\n  timePlayed = null;\n  progress = null;\n  trackLength = null;\n  pitch = null;\n\n  constructor(selector, player, options = { position: 'bottom' }) {\n    const wrapper = document.querySelector(selector);\n    wrapper.appendChild(this.controls);\n    this.player = player;\n    const props = this.player.props;\n    this.playBtn = this.controls.querySelector('.playButton');\n    this.playIcn = this.playBtn.querySelector('i');\n    this.timePlayed = this.controls.querySelector('.timePlayed');\n    this.timePlayed.innerHTML = props.timePlayed;\n    this.progress = this.controls.querySelector('.progressMeter');\n    this.progress.value = props.percentagePlayed;\n    this.trackLength = this.controls.querySelector('.trackLength');\n    this.trackLength.innerHTML = props.trackLength;\n    this.pitch = this.controls.querySelector('.pitch');\n    this.fallbackPitch = 0;\n    if (!PANEL_POSITION.includes(options.position)) {\n      throw new Error(`Panel Position must be either 'top' or 'bottom'.`);\n    }\n    this.volumeBtn = this.controls.querySelector('#song_volume_button');\n    this.volumeIcn = this.volumeBtn.querySelector('i');\n    this.volumeSlider = this.controls.querySelector('#song_volume');\n    this.volumeSlider.value = props.songVolume;\n    if (options.position === 'top') {\n      const sliderContainer = this.controls.querySelector('.volumeSlider');\n      sliderContainer.classList.add('under');\n    }\n    setupListeners.call(this);\n  }\n}\n"],"names":["styleInject","css","ref","insertAt","document","head","getElementsByTagName","style","createElement","type","firstChild","insertBefore","appendChild","styleSheet","cssText","createTextNode","DISPLAY_BOUNDS","TILE_WIDTH","TILE_HEIGHT","BORDER_WIDTH","BORDER_HEIGHT","PANEL_POSITION","CDGContext","_ref","arguments","length","undefined","_ref$width","width","_ref$height","height","_ref$canvas","canvas","this","createCanvas","_ref$ctx","ctx","createCanvasContext","_ref$imageData","imageData","createImageData","_classCallCheck","_defineProperty","Array","fill","WIDTH","value","getContext","mozImageSmoothingEnabled","webkitImageSmoothingEnabled","msImageSmoothingEnabled","imageSmoothingEnabled","hOffset","vOffset","keyColor","backgroundColor","borderColor","memoryColor","pixels","index","r","g","b","clut","map","c","x","y","colorIndex","offset","pixelIndex","_this$clut$colorIndex","_slicedToArray","data","putImageData","generateImageData","warn","_console2","console","apply","CDGInstruction","bytes","slice","_createClass","key","get","constructor","instruction","opcode","byte","toString","padStart","join","CDGNoopInstruction","_CDGInstruction","_inherits","_super","_createSuper","CDGMemoryPresetInstruction","_CDGInstruction2","_super2","_this","doff","color","repeat","context","concat","CDGBorderPresetInstruction","_CDGInstruction3","_super3","_this2","_DISPLAY_BOUNDS","left","top","right","bottom","setPixel","CDGTileBlockInstruction","_CDGInstruction4","_super4","_this3","colors","row","column","i","curbyte","j","op","CDGTileBlockXORInstruction","_CDGTileBlockInstruct","_super5","getPixel","CDGScrollPresetInstruction","_CDGInstruction5","_super6","_this4","hScroll","hCmd","vScroll","vCmd","Math","min","buffer","offx","offy","filter","v","CDGScrollCopyInstruction","_CDGScrollPresetInstr","_super7","CDGSetKeyColorInstruction","_CDGInstruction6","_super8","_this5","CDGLoadCLUTLowInstruction","_CDGInstruction7","_super9","_this6","cur","setCLUTEntry","clutOffset","_this7","CDGLoadCLUTHighInstruction","_CDGLoadCLUTLowInstru","_super10","CDGParser","instructionClassByType","InstructionClass","command","createInstruction","instructions","bytesLength","push","parseInstruction","CDG_MEMORY_PRESET","CDG_TILE_BLOCK","CDG_SCROLL_COPY","CDG_LOAD_CLUT_LOW","CDG_TILE_BLOCK_XOR","now","performance","process","hrtime","_process$hrtime2","Date","requestFrame","callback","requestAnimationFrame","window","setTimeout","CDGPlayer","_ref$contextOptions","contextOptions","_ref$context","createContext","afterRender","timestamp","pc","frameId","update","lastSyncPos","pos","lastTimestamp","newPc","floor","SECTORS_PER_SECOND","ffAmt","fastForward","render","options","parser","parseInstructions","reset","renderFrame","execute","executeInstruction","stop","count","max","step","id","cancelAnimationFrame","clearTimeout","ms","Deferred","Promise","defer","PromiseUtils","resolve","reject","promise","bind","Object","freeze","loadZipBuffer","fileBuffer","JSZip","loadAsync","catch","error","Error","getKaraokeFiles","zipFile","entries","relPath","endsWith","processZip","audio","entry","name","video","async","zipEntry","loadVideo","then","jsmediatags","Reader","setTagsToRead","read","onSuccess","tag","onError","parts","split","tags","album","trim","artist","title","getTagData","all","errors","CDGFileLoader","filePath","deferred","JSZipUtils","getBinaryContent","err","getDataFile","FifoSampleBuffer","_vector","Float32Array","_position","_frameCount","clear","receive","rewind","put","numFrames","putSamples","samples","position","sourceOffset","numSamples","ensureCapacity","destOffset","endIndex","vector","set","subarray","putBuffer","frameCount","receiveSamples","output","startIndex","extract","minLength","parseInt","newVector","ensureAdditionalCapacity","PubSub","fns","any","e","fn","prev","forEach","splice","on","method","prop","off","observable","target","pub","Proxy","fire","once","has","copyContextToCanvas","clearRect","drawImage","clearCanvas","loadAudio","shifter","decodeAudioData","audioBuffer","PitchShifter","detail","props","timePlayed","formattedTimePlayed","percentagePlayed","player","sync","pitch","trackLength","formattedDuration","load","from","wrapText","text","maxWidth","lineHeight","words","line","n","testLine","measureText","fillText","drawTag","cvs","font","fillStyle","textAlign","loadTag","call","handleExtractedZip","responseArr","status","loaded","loading","setVolume","val","gainNode","gain","KaraokePlayer","selector","isPlaying","songVolume","destroy","wrapper","querySelector","classList","add","titleImage","onloaded","remove","AudioContext","webkitAudioContext","createGain","onvolume","disconnect","toLowerCase","loadZipFile","loadFileBuffer","zipResponse","pause","start","connect","destination","resume","play","playing","changePlayerPosition","perc","pitchChange","pitchSemitones","tempo","change","newValue","toFixed","fallback","fallbackVolume","htmlToElement","html","template","innerHTML","content","setupListeners","playBtn","removeAttribute","volumeBtn","setAttribute","ontimeplayed","onpercentageplayed","progress","ontracklength","ondestroy","removeListeners","onplay","playIcn","icn","volumeIcn","volumeSlider","contains","addEventListener","togglePlay","event","changePosition","changeKey","changeVolume","removeEventListener","getBoundingClientRect","pageX","offsetWidth","isNaN","fallbackPitch","parseFloat","CDGControls","ctrlTemplate","controls","includes","sliderContainer"],"mappings":"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"}