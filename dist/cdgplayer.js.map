{"version":3,"file":"cdgplayer.js","sources":["../node_modules/style-inject/dist/style-inject.es.js","../src/cdg/constants.js","../src/cdg/CDGContext.js","../src/cdg/logger.js","../src/cdg/CDGInstruction.js","../src/cdg/CDGParser.js","../src/cdg/CDGPlayer.js","../src/utilities/deferred.js","../src/loader/CDGFileLoader.js","../node_modules/soundtouchjs/dist/soundtouch.js","../src/utilities/is.js","../src/observable/pubsub.js","../src/observable/observable.js","../src/player/KaraokePlayer.js","../src/controls/CDGControls.js"],"sourcesContent":["function styleInject(css, ref) {\n  if ( ref === void 0 ) ref = {};\n  var insertAt = ref.insertAt;\n\n  if (!css || typeof document === 'undefined') { return; }\n\n  var head = document.head || document.getElementsByTagName('head')[0];\n  var style = document.createElement('style');\n  style.type = 'text/css';\n\n  if (insertAt === 'top') {\n    if (head.firstChild) {\n      head.insertBefore(style, head.firstChild);\n    } else {\n      head.appendChild(style);\n    }\n  } else {\n    head.appendChild(style);\n  }\n\n  if (style.styleSheet) {\n    style.styleSheet.cssText = css;\n  } else {\n    style.appendChild(document.createTextNode(css));\n  }\n}\n\nexport default styleInject;\n","/**\n * CDG Context Constants\n * =====================\n *\n * These are used to set up the drawing context\n */\n\nexport const TILE_WIDTH = 6;\nexport const TILE_HEIGHT = 12;\nexport const TILES_X = 50;\nexport const TILES_Y = 18;\nexport const TILES_X_BORDER = 1;\nexport const TILES_Y_BORDER = 1;\nexport const WIDTH = TILE_WIDTH * TILES_X; // 300px\nexport const HEIGHT = TILE_HEIGHT * TILES_Y; // 216px\nexport const BORDER_WIDTH = TILE_WIDTH * TILES_X_BORDER;\nexport const BORDER_HEIGHT = TILE_HEIGHT * TILES_Y_BORDER;\nexport const DISPLAY_WIDTH = WIDTH - 2 * BORDER_WIDTH; // 288px\nexport const DISPLAY_HEIGHT = HEIGHT - 2 * BORDER_HEIGHT; // 192px\nexport const DISPLAY_BOUNDS = [\n  BORDER_WIDTH,\n  BORDER_HEIGHT,\n  BORDER_WIDTH + DISPLAY_WIDTH,\n  BORDER_HEIGHT + DISPLAY_HEIGHT\n];\nexport const DISPLAY_PIXELS = WIDTH * HEIGHT;\n\n/**\n * CDG Instruction Constants\n * =========================\n *\n * These are used for interpreting commands\n */\n\nexport const CDG_NOOP = 0;\nexport const CDG_MEMORY_PRESET = 1;\nexport const CDG_BORDER_PRESET = 2;\nexport const CDG_TILE_BLOCK = 6;\nexport const CDG_SCROLL_PRESET = 20;\nexport const CDG_SCROLL_COPY = 24;\nexport const CDG_SET_KEY_COLOR = 28;\nexport const CDG_LOAD_CLUT_LOW = 30;\nexport const CDG_LOAD_CLUT_HI = 31;\nexport const CDG_TILE_BLOCK_XOR = 38;\n\nexport const CDG_SCROLL_NONE = 0;\nexport const CDG_SCROLL_LEFT = 1;\nexport const CDG_SCROLL_RIGHT = 2;\nexport const CDG_SCROLL_UP = 1;\nexport const CDG_SCROLL_DOWN = 2;\n\nexport const CDG_DATA = 4;\n\nexport const COMMAND_MASK = 0x3f;\nexport const CDG_COMMAND = 0x09;\nexport const SECTORS_PER_SECOND = 75;\nexport const PACKETS_PER_SECTOR = 4;\nexport const PACKET_SIZE = 24;\n\n/**\n *  CDG Audio Constants\n */\n\nexport const GAIN_DEFAULT = 1.0;\nexport const PITCH_DEFAULT = 1;\n\n/**\n *  CDG Player Constants\n */\n\nexport const SCALE_DEFAULT = 1;\nexport const FILTER_PLAYBACK_OFFSET = 800;\nexport const START_TIME = '0:00';\n\n/**\n * CDG Controls Constants\n */\nexport const PANEL_POSITION = ['top', 'bottom'];\n","import {\n    WIDTH,\n    HEIGHT,\n    DISPLAY_PIXELS,\n} from './constants';\n\n/**\n * CDG Context\n * ===========\n *\n * CDG rendering context, maintaining the size and content of the screen and the color palette\n */\nexport default class CDGContext {\n    /**\n     * Horizontal offset\n     * @type {number}\n     */\n    hOffset = 0;\n\n    /**\n     * Vertical offset\n     * @type {number}\n     */\n    vOffset = 0;\n\n    /**\n     * Transparent index in the color lookup table\n     * @type {number}\n     */\n    keyColor = null;\n\n    /**\n     * Background index in the color lookup table\n     * @type {number}\n     */\n    backgroundContainer = null;\n\n    /**\n     * Last index in the color lookup table that was used as a border preset\n     * @type {number}\n     */\n    borderColor = null;\n\n    /**\n     * Last index in the color lookup table that was used as a memory preset\n     * @type {number}\n     */\n    memoryColor = null;\n\n    /**\n     * Color lookup table\n     * @type {Array}\n     */\n    clut = (new Array(16)).fill([0, 0, 0]);\n\n    /**\n     * Pixels\n     * @type {Array}\n     */\n    pixels = (new Array(DISPLAY_PIXELS)).fill(0);\n\n    /**\n     * Buffer\n     * @type {Array}\n     */\n    buffer = (new Array(DISPLAY_PIXELS)).fill(0);\n\n    /**\n     * Creates a CDG rendering context\n     *\n     * @constructor\n     * @param  {Object} [options] - context options\n     * @param  {number} [options.width] - width of the canvas\n     * @param  {number} [options.height] - height of the canvas\n     * @param  {HTMLCanvasElement} [options.canvas] - canvas element\n     * @param  {CanvasRenderingContext2D} [options.ctx] - canvas rendering context\n     * @param  {ImageData} [options.imageData] - pixel data\n     */\n    constructor({\n                    width = WIDTH,\n                    height = HEIGHT,\n                    canvas = this.createCanvas(width, height),\n                    ctx = this.createCanvasContext(canvas),\n                    imageData = this.createImageData(canvas, ctx, width, height),\n                } = {}) {\n        this.canvas = canvas;\n        this.ctx = ctx;\n        this.imageData = imageData;\n    }\n\n    /**\n     * Creates a canvas at the given size\n     *\n     * @param  {number} width - width of the canvas\n     * @param  {number} height - height of the canvas\n     * @return {HTMLCanvasElement} created canvas\n     */\n    createCanvas(width, height) {\n        const canvas = document.createElement('canvas');\n        canvas.width = width;\n        canvas.height = height;\n        return canvas;\n    }\n\n    /**\n     * Creates a new 2D context for a canvas\n     *\n     * @param  {HTMLCanvasElement} canvas - canvas element\n     * @return {CanvasRenderingContext2D} created context\n     */\n    createCanvasContext(canvas) {\n        const ctx = canvas.getContext('2d');\n        ctx.mozImageSmoothingEnabled = false;\n        ctx.webkitImageSmoothingEnabled = false;\n        ctx.msImageSmoothingEnabled = false;\n        ctx.imageSmoothingEnabled = false;\n        return ctx;\n    }\n\n    /**\n     * Creates image data to dump the pixel data for canvas rendering\n     *\n     * @param  {HTMLCanvasElement} canvas - canvas element\n     * @param  {CanvasRenderingContext2D} ctx - 2D canvas rendering context\n     * @param  {number} width - width of the canvas\n     * @param  {number} height - height of the canvas\n     * @return {ImageData} created image data\n     */\n    createImageData(canvas, ctx, width = canvas.width, height = canvas.height) {\n        return ctx.createImageData(width, height);\n    }\n\n    /**\n     * Resets the offset and key color\n     */\n    reset() {\n        this.hOffset = 0;\n        this.vOffset = 0;\n        this.keyColor = null;\n        this.backgroundColor = null;\n        this.borderColor = null;\n        this.memoryColor = null;\n        this.pixels.fill(0);\n    }\n\n    /**\n     * Sets an entry in the color lookup table\n     *\n     * @param  {Number} index - index in the palette\n     * @param  {number} r - red component of the color\n     * @param  {number} g - green component of the color\n     * @param  {number} b - blue component of the color\n     */\n    setCLUTEntry(index, r, g, b) {\n        this.clut[index] = [r, g, b].map(c => c * 17);\n    }\n\n    /**\n     * Sets a pixel's CLUT index value\n     *\n     * @param {number} x - x position of the pixel\n     * @param {number} y - y position of the pixel\n     * @param {number} colorIndex - CLUT index\n     */\n    setPixel(x, y, colorIndex) {\n        this.pixels[x + (y * WIDTH)] = colorIndex;\n    }\n\n    /**\n     * Gets a pixel's CLUT index value\n     *\n     * @param  {number} x - x position of the pixel\n     * @param  {number} y - y position of the pixel\n     * @return {number} CLUT index\n     */\n    getPixel(x, y) {\n        return this.pixels[x + (y * WIDTH)];\n    }\n\n    /**\n     * Gets the background color index from the CLUT based on the transparent or background color\n     *\n     * @return {number} CLUT index\n     */\n    getBackground() {\n        switch (true) {\n            case this.keyColor != null:\n                return this.keyColor;\n            case this.backgroundColor != null:\n                return this.backgroundColor;\n            case this.memoryColor != null:\n                return this.memoryColor;\n            case this.borderColor != null:\n                return this.borderColor;\n            default:\n                return 0;\n        }\n    }\n\n    /**\n     * Converts palette-based pixel data to image data\n     *\n     * @return {ImageData} generated imagedata\n     */\n    generateImageData() {\n        const [left, top, right, bottom] = [0, 0, WIDTH, HEIGHT];\n        for (let x = left; x < right; x++) {\n            for (let y = top; y < bottom; y++) {\n                // The offset is where we draw the pixel in the raster data\n                const offset = 4 * (x + (y * WIDTH));\n                // Respect the horizontal and vertical offsets for grabbing the pixel color\n                const px = ((x - this.hOffset) + WIDTH) % WIDTH;\n                const py = ((y - this.vOffset) + HEIGHT) % HEIGHT;\n                const pixelIndex = px + (py * WIDTH);\n                const colorIndex = this.pixels[pixelIndex];\n                const [r, g, b] = this.clut[colorIndex];\n                // Set the rgba values in the image data\n                this.imageData.data[offset] = r;\n                this.imageData.data[offset + 1] = g;\n                this.imageData.data[offset + 2] = b;\n                this.imageData.data[offset + 3] = colorIndex === this.keyColor ? 0x00 : 0xff;\n            }\n        }\n        return this.imageData;\n    }\n\n    /**\n     * Renders the pixel buffer\n     */\n    renderFrame() {\n        this.ctx.putImageData(this.generateImageData(), 0, 0);\n    }\n}\n","/* eslint-disable no-console */\n\nexport function log(...args) {\n    console && console.log && console.log(...args);\n}\n\nexport function warn(...args) {\n    console && console.warn && console.warn(...args);\n}\n\nexport function error(...args) {\n    console && console.error && console.error(...args);\n}\n\nexport default {\n    log,\n    warn,\n    error,\n};\n","import {\n    TILE_WIDTH,\n    TILE_HEIGHT,\n    WIDTH,\n    HEIGHT,\n    DISPLAY_BOUNDS,\n    CDG_NOOP,\n    CDG_MEMORY_PRESET,\n    CDG_BORDER_PRESET,\n    CDG_TILE_BLOCK,\n    CDG_SCROLL_PRESET,\n    CDG_SCROLL_COPY,\n    CDG_SET_KEY_COLOR,\n    CDG_LOAD_CLUT_LOW,\n    CDG_LOAD_CLUT_HI,\n    CDG_TILE_BLOCK_XOR,\n    CDG_SCROLL_NONE,\n    CDG_SCROLL_LEFT,\n    CDG_SCROLL_RIGHT,\n    CDG_SCROLL_UP,\n    CDG_SCROLL_DOWN,\n    CDG_DATA,\n    PACKET_SIZE\n} from './constants';\n\nimport { warn } from './logger';\n\n/**\n * CDG instruction base class\n * ==========================\n *\n * Does nothing\n */\nexport class CDGInstruction {\n    static instruction = '';\n    static opcode = null;\n\n    get instruction() {\n        return this.constructor.instruction;\n    }\n    get opcode() {\n        return this.constructor.opcode;\n    }\n\n    constructor(bytes, offset = 0) {\n        this.bytes = bytes.slice(offset, offset + PACKET_SIZE);\n    }\n\n    execute(/*context*/) {}\n\n    bytecodeToString() {\n        return this.bytes.map(byte => byte.toString(16).padStart(2, '0')).join('');\n    }\n\n    detailsToString() {\n        return '';\n    }\n\n    toString() {\n        return this.instruction;\n    }\n}\n\n/**\n * No-op instruction\n * =================\n *\n * Does nothing\n */\nexport class CDGNoopInstruction extends CDGInstruction {\n    static instruction = 'No-op';\n    static opcode = CDG_NOOP;\n}\n\n/**\n * Memory Preset instruction\n * =========================\n *\n * Set the screen to a particular color\n */\nexport class CDGMemoryPresetInstruction extends CDGInstruction {\n    static instruction = 'Memory Preset';\n    static opcode = CDG_MEMORY_PRESET;\n\n    constructor(bytes, offset = 0) {\n        super(bytes, offset);\n        const doff = offset + CDG_DATA;\n        this.color = bytes[doff] & 0x0f;\n        this.repeat = bytes[doff + 1] & 0x0f;\n    }\n\n    execute(context) {\n        context.memoryColor = this.color;\n        context.backgroundColor = this.color;\n        context.pixels.fill(this.color);\n    }\n\n    detailsToString() {\n        return `color index: ${this.color}`;\n    }\n}\n\n/**\n * Border Preset instruction\n * =========================\n *\n * Set the border of the screen to a particular color\n */\nexport class CDGBorderPresetInstruction extends CDGInstruction {\n    static instruction = 'Border Preset';\n    static opcode = CDG_BORDER_PRESET;\n\n    constructor(bytes, offset = 0) {\n        super(bytes, offset);\n        this.color = bytes[offset + CDG_DATA] & 0x0f;\n    }\n\n    execute(context) {\n        context.borderColor = this.color;\n        context.backgroundColor = this.color;\n        const [left, top, right, bottom] = DISPLAY_BOUNDS;\n        for (let x = 0; x < WIDTH; x++) {\n            for (let y = 0; y < top; y++) {\n                context.setPixel(x, y, this.color);\n            }\n            for (let y = bottom + 1; y < HEIGHT; y++) {\n                context.setPixel(x, y, this.color);\n            }\n        }\n        for (let y = top; y <= bottom; y++) {\n            for (let x = 0; x < left; x++) {\n                context.setPixel(x, y, this.color);\n            }\n            for (let x = right + 1; x < WIDTH; x++) {\n                context.setPixel(x, y, this.color);\n            }\n        }\n    }\n\n    detailsToString() {\n        return `color index: ${this.color}`;\n    }\n}\n\n/**\n * Tile Block (Normal) instruction\n * ===============================\n *\n * Load a 12 x 6, 2 color tile and display it normally.\n */\nexport class CDGTileBlockInstruction extends CDGInstruction {\n    static instruction = 'Tile Block';\n    static opcode = CDG_TILE_BLOCK;\n\n    constructor(bytes, offset = 0) {\n        super(bytes, offset);\n        const doff = offset + CDG_DATA;\n        // some players check bytes[doff+1] & 0x20 and ignores if it is set (?)\n        this.colors = [bytes[doff] & 0x0f, bytes[doff + 1] & 0x0f];\n        this.row = bytes[doff + 2] & 0x1f;\n        this.column = bytes[doff + 3] & 0x3f;\n        this.pixels = bytes.slice(doff + 4, doff + 16);\n    }\n\n    execute(context) {\n        /* blit a tile */\n        const x = this.column * TILE_WIDTH;\n        const y = this.row * TILE_HEIGHT;\n\n        // @TODO: These should be >= instead, I think...\n        if (x + TILE_WIDTH > WIDTH || y + TILE_HEIGHT > HEIGHT) {\n            warn(`TileBlock out of bounds (${this.row}, ${this.column})`);\n            return;\n        }\n\n        for (let i = 0; i < TILE_HEIGHT; i++) {\n            const curbyte = this.pixels[i];\n            for (let j = 0; j < TILE_WIDTH; j++) {\n                const color = this.colors[(curbyte >> (5 - j)) & 0x01];\n                this.op(context, x + j, y + i, color);\n            }\n        }\n    }\n\n    op(context, x, y, color) {\n        context.setPixel(x, y, color);\n    }\n\n    detailsToString() {\n        return `row: ${this.row}, column: ${this.column}, color indexes: [${this.colors.join(\n            ', '\n        )}]`;\n    }\n}\n\n/**\n * Tile Block (XOR) instruction\n * ============================\n *\n * Load a 12 x 6, 2 color tile and display it using the XOR method\n */\nexport class CDGTileBlockXORInstruction extends CDGTileBlockInstruction {\n    static instruction = 'Tile Block (XOR)';\n    static opcode = CDG_TILE_BLOCK_XOR;\n\n    op(context, x, y, color) {\n        // context.pixels[offset] = context.pixels[offset] ^ color;\n        context.setPixel(x, y, context.getPixel(x, y) ^ color);\n    }\n}\n\n/**\n * Scroll Preset instruction\n * =========================\n *\n * Scroll the image, filling in the new area with a color\n */\nexport class CDGScrollPresetInstruction extends CDGInstruction {\n    static instruction = 'Scroll Preset';\n    static opcode = CDG_SCROLL_PRESET;\n\n    constructor(bytes, offset = 0) {\n        super(bytes, offset);\n        const doff = offset + CDG_DATA;\n        this.color = bytes[doff] & 0x0f;\n\n        const hScroll = bytes[doff + 1] & 0x3f;\n        this.hCmd = (hScroll & 0x30) >> 4;\n        this.hOffset = hScroll & 0x07;\n\n        const vScroll = bytes[doff + 2] & 0x3f;\n        this.vCmd = (vScroll & 0x30) >> 4;\n        this.vOffset = vScroll & 0x0f;\n    }\n\n    // eslint-disable-next-line complexity\n    execute(context) {\n        context.backgroundColor = this.color;\n        context.hOffset = Math.min(this.hOffset, TILE_WIDTH - 1);\n        context.vOffset = Math.min(this.vOffset, TILE_HEIGHT - 1);\n\n        let hScroll = 0;\n        switch (this.hCmd) {\n            case CDG_SCROLL_RIGHT:\n                hScroll = TILE_WIDTH;\n                break;\n            case CDG_SCROLL_LEFT:\n                hScroll = -TILE_WIDTH;\n                break;\n            case CDG_SCROLL_NONE:\n            default:\n                break;\n        }\n\n        let vScroll = 0;\n        switch (this.hCmd) {\n            case CDG_SCROLL_DOWN:\n                vScroll = TILE_HEIGHT;\n                break;\n            case CDG_SCROLL_UP:\n                vScroll = -TILE_HEIGHT;\n                break;\n            case CDG_SCROLL_NONE:\n            default:\n                break;\n        }\n\n        if (!hScroll && !vScroll) {\n            return;\n        }\n\n        for (let x = 0; x < WIDTH; x++) {\n            for (let y = 0; y < HEIGHT; y++) {\n                context.buffer[x + y * WIDTH] = this.getPixel(context, x + hScroll, y + vScroll);\n            }\n        }\n\n        // Swap buffers\n        [context.pixels, context.buffer] = [context.buffer, context.pixels];\n    }\n\n    getPixel(context, offx, offy) {\n        if (offx > 0 && offx < WIDTH && offy > 0 && offy < HEIGHT) {\n            return context.pixels[offx + offy * WIDTH];\n        }\n        return this.color;\n    }\n\n    detailsToString() {\n        let vScroll = false;\n        let hScroll = false;\n        if (this.vCmd === CDG_SCROLL_UP) {\n            vScroll = 'up';\n        } else if (this.vCmd === CDG_SCROLL_DOWN) {\n            vScroll = 'down';\n        }\n        if (this.vCmd === CDG_SCROLL_LEFT) {\n            hScroll = 'left';\n        } else if (this.vCmd === CDG_SCROLL_RIGHT) {\n            hScroll = 'right';\n        }\n        return [vScroll, hScroll, `vOffset: ${this.vOffset}`, `hOffset: ${this.hOffset}`]\n            .filter(v => v)\n            .join(' ');\n    }\n}\n\n/**\n * Scroll Copy instruction\n * =======================\n *\n * Scroll the image, rotating the bits back around\n */\nexport class CDGScrollCopyInstruction extends CDGScrollPresetInstruction {\n    static instruction = 'Scroll Copy';\n    static opcode = CDG_SCROLL_COPY;\n\n    getPixel(context, offx, offy) {\n        offx = (offx + WIDTH) % WIDTH;\n        offy = (offy + HEIGHT) % HEIGHT;\n        return context.pixels[offx + offy * WIDTH];\n    }\n}\n\n/**\n * Set Key Color instruction\n * =========================\n *\n * Define a specific color as being transparent\n */\nexport class CDGSetKeyColorInstruction extends CDGInstruction {\n    static instruction = 'Set Key Color';\n    static opcode = CDG_SET_KEY_COLOR;\n\n    constructor(bytes, offset = 0) {\n        super(bytes, offset);\n        this.color = bytes[offset + CDG_DATA] & 0x0f;\n    }\n\n    execute(context) {\n        context.keyColor = this.color;\n    }\n\n    detailsToString() {\n        return `color index: ${this.color}`;\n    }\n}\n\n/**\n * Load Color Table (Low) instruction\n * ==================================\n *\n * Load in the lower 8 entries of the color table\n */\nexport class CDGLoadCLUTLowInstruction extends CDGInstruction {\n    static instruction = 'Load CLUT (Low)';\n    static opcode = CDG_LOAD_CLUT_LOW;\n\n    get clutOffset() {\n        return 0;\n    }\n\n    constructor(bytes, offset = 0) {\n        super(bytes, offset);\n        const doff = offset + CDG_DATA;\n        this.colors = [];\n        for (let i = 0; i < 8; i++) {\n            const cur = doff + 2 * i;\n            const color = ((bytes[cur] & 0x3f) << 6) + (bytes[cur + 1] & 0x3f);\n\n            this.colors[i] = [\n                color >> 8, // red\n                (color & 0xf0) >> 4, // green\n                color & 0x0f // blue\n            ];\n        }\n    }\n\n    execute(context) {\n        for (let i = 0; i < 8; i++) {\n            context.setCLUTEntry(\n                i + this.clutOffset,\n                this.colors[i][0],\n                this.colors[i][1],\n                this.colors[i][2]\n            );\n        }\n    }\n\n    detailsToString() {\n        return `colors: [${this.colors\n            .map(\n                (color, i) => `${i + this.clutOffset}: #${color.map(c => c.toString(16)).join('')}`\n            )\n            .join(', ')}]`;\n    }\n}\n\n/**\n * Load Color Table (High) instruction\n * ==================================\n *\n * Load in the upper 8 entries of the color table\n */\nexport class CDGLoadCLUTHighInstruction extends CDGLoadCLUTLowInstruction {\n    static instruction = 'Load CLUT (High)';\n    static opcode = CDG_LOAD_CLUT_HI;\n\n    get clutOffset() {\n        return 8;\n    }\n}\n","import {\n    CDG_NOOP,\n    CDG_MEMORY_PRESET,\n    CDG_BORDER_PRESET,\n    CDG_TILE_BLOCK,\n    CDG_SCROLL_PRESET,\n    CDG_SCROLL_COPY,\n    CDG_SET_KEY_COLOR,\n    CDG_LOAD_CLUT_LOW,\n    CDG_LOAD_CLUT_HI,\n    CDG_TILE_BLOCK_XOR,\n    COMMAND_MASK,\n    CDG_COMMAND,\n    PACKET_SIZE,\n} from './constants';\n\nimport { warn } from './logger';\n\nimport {\n    CDGNoopInstruction,\n    CDGMemoryPresetInstruction,\n    CDGBorderPresetInstruction,\n    CDGTileBlockInstruction,\n    CDGScrollPresetInstruction,\n    CDGScrollCopyInstruction,\n    CDGSetKeyColorInstruction,\n    CDGLoadCLUTLowInstruction,\n    CDGLoadCLUTHighInstruction,\n    CDGTileBlockXORInstruction,\n} from './CDGInstruction';\n\n/**\n * CDG Parser\n * ==========\n *\n * Instruction parser, converting bytecodes to arrays of CDGInstructions\n */\nexport default class CDGParser {\n    static get instructionClassByType() {\n        return {\n            [CDG_NOOP]: CDGNoopInstruction,\n            [CDG_MEMORY_PRESET]: CDGMemoryPresetInstruction,\n            [CDG_BORDER_PRESET]: CDGBorderPresetInstruction,\n            [CDG_TILE_BLOCK]: CDGTileBlockInstruction,\n            [CDG_SCROLL_PRESET]: CDGScrollPresetInstruction,\n            [CDG_SCROLL_COPY]: CDGScrollCopyInstruction,\n            [CDG_SET_KEY_COLOR]: CDGSetKeyColorInstruction,\n            [CDG_LOAD_CLUT_LOW]: CDGLoadCLUTLowInstruction,\n            [CDG_LOAD_CLUT_HI]: CDGLoadCLUTHighInstruction,\n            [CDG_TILE_BLOCK_XOR]: CDGTileBlockXORInstruction,\n        };\n    }\n\n    /**\n     * Maps commands to instruction classes\n     * @type {Object}\n     */\n    instructionClassByType = this.constructor.instructionClassByType;\n\n    /**\n     * Registers an instruction type\n     *\n     * @param  {string} opcode - CDG instruction opcode\n     * @param  {CDGInstruction} InstructionClass - CDG instruction subclass\n     */\n    registerInstruction(opcode, InstructionClass) {\n        this.instructionClassByType[opcode] = InstructionClass;\n    }\n\n    /**\n     * Creates an instruction\n     *\n     * @param  {string} opcode - CDG instruction opcode\n     * @param  {string} bytes - bytes with CDG instruction\n     * @param  {number} offset - a little piece of heaven\n     * @return {CDGInstruction}\n     */\n    createInstruction(opcode, bytes, offset = 0) {\n        if (!(opcode in this.instructionClassByType)) {\n            warn(`Unknown CDG instruction (instruction = ${opcode})`);\n        }\n        const InstructionClass = this.instructionClassByType[opcode] || CDGNoopInstruction;\n        return new InstructionClass(bytes, offset);\n    }\n\n    /**\n     * Parses a single CDG instruction packet\n     *\n     * @param  {string} bytes - bytes with CDG instruction\n     * @param  {number} offset - a little piece of heaven\n     * @return {CDGInstruction}\n     */\n    parseInstruction(bytes, offset = 0) {\n        const command = bytes[offset] & COMMAND_MASK;\n        if (command === CDG_COMMAND) {\n            const opcode = bytes[offset + 1] & COMMAND_MASK;\n            return this.createInstruction(opcode, bytes, offset);\n        }\n        return new CDGNoopInstruction(bytes, offset);\n    }\n\n    /**\n     * Parses all the CDG instruction packets\n     *\n     * @param {string} bytes - bytes with CDG instruction\n     * @return {CDGInstruction[]}\n     */\n    parseInstructions(bytes) {\n        const instructions = [];\n        const bytesLength = bytes.length;\n        for (let offset = 0; offset < bytesLength; offset += PACKET_SIZE) {\n            instructions.push(this.parseInstruction(bytes, offset));\n        }\n        return instructions.filter(instruction => instruction);\n    }\n}\n","import {\n    PACKETS_PER_SECTOR,\n    SECTORS_PER_SECOND,\n} from './constants';\n\nimport CDGContext from './CDGContext';\nimport CDGParser from './CDGParser';\n\n/**\n * Calculates current time for the sake of determining playback intervals\n *\n * @return {number} milliseconds\n */\nfunction now() {\n    if (typeof performance !== 'undefined' && typeof performance.now === 'function') {\n        return performance.now();\n    } else if (typeof process !== 'undefined' && typeof process.hrtime === 'function') {\n        const [seconds, microseconds] = process.hrtime();\n        return (seconds * 1000) + (microseconds / 1000000);\n    }\n    return Date.now();\n}\n\nfunction requestFrame(callback) {\n    if (typeof requestAnimationFrame === 'function') {\n        return window.requestAnimationFrame(callback);\n    }\n    return setTimeout(callback, 25);\n}\n\nfunction cancelFrame(id) {\n    if (typeof cancelAnimationFrame === 'function') {\n        return cancelAnimationFrame(id);\n    }\n    return clearTimeout(id);\n}\n\n/**\n * CDG Player\n * ==========\n *\n * Provides an interface for interpreting CDG instructions and rendering the results to a canvas\n */\nexport default class CDGPlayer {\n    /**\n     * CDG instructions\n     * @type {Array}\n     */\n    instructions = [];\n\n    /**\n     * Packet counter\n     * @type {Number}\n     */\n    pc = -1;\n\n    /**\n     * requestAnimationFrame unique ID\n     * @type {number}\n     */\n    frameId = null;\n\n    /**\n     * Current time (ms)\n     * @type {Number}\n     */\n    pos = 0;\n\n    /**\n     * Last sync time (ms)\n     * @type {number}\n     */\n    lastSyncPos = null;\n\n    /**\n     * Last sync timestamp\n     * @type {DOMHighResTimeStamp}\n     */\n    lastTimestamp = null;\n\n    /**\n     * Steps through however many frames are necessary to bring the context up-to-date with\n     *\n     * @param  {DOMHighResTimeStamp} timestamp\n     * @return {self}\n     */\n    update = (timestamp = now()) => {\n        // Packet counter says relax\n        if (this.pc === -1) {\n            return this;\n        }\n\n        // go ahead and request the next frame\n        this.frameId = requestFrame(this.update);\n\n        if (this.lastSyncPos) {\n            // last known audio position + time delta\n            this.pos = this.lastSyncPos + (timestamp - this.lastTimestamp);\n        } else {\n            // time delta only (unsynced)\n            this.pos += timestamp - this.lastTimestamp;\n            this.lastTimestamp = timestamp;\n        }\n\n        // determine packet we should be at, based on spec\n        // of 4 packets per sector @ 75 sectors per second\n        const newPc = Math.floor(SECTORS_PER_SECOND * PACKETS_PER_SECTOR * (this.pos / 1000));\n\n        const ffAmt = newPc - this.pc;\n        if (ffAmt > 0) {\n            this.fastForward(ffAmt);\n            this.render();\n        }\n\n        return this;\n    };\n\n    /**\n     * Creates CDGPlayer instance\n     *\n     * @constructor\n     * @param  {Object} [options] - CDG player options\n     * @param  {Object} [options.contextOptions] - options for the CDG context\n     * @param  {function} [options.afterRender] - function to call after rendering a frame\n     */\n    constructor({\n                    contextOptions = {},\n                    context = this.createContext(contextOptions),\n                    afterRender,\n                } = {}) {\n        this.context = context;\n        this.afterRender = afterRender;\n    }\n\n    /**\n     * Creates a CDG context instance for rendering\n     *\n     * @param  {Object} [options] - parameters passed to the context constructor\n     * @return {CDGContext} context instance\n     */\n    createContext(options = {}) {\n        return new CDGContext(options);\n    }\n\n    /**\n     * Loads CDG data and parses the instructions\n     *\n     * @param  {string} data - CDG instruction data\n     * @return {self}\n     */\n    load(data) {\n        const parser = new CDGParser();\n        this.instructions = parser.parseInstructions(data);\n        this.reset();\n        return this;\n    }\n\n    /**\n     * Resets the counters\n     *\n     * @return {self}\n     */\n    reset() {\n        this.pc = 0;\n        this.pos = 0;\n        this.lastSyncPos = null;\n        this.context.reset();\n        return this;\n    }\n\n    /**\n     * Renders the CDG context frame\n     * @return {self}\n     */\n    render() {\n        this.context.renderFrame();\n        this.afterRender && this.afterRender(this.context);\n        return this;\n    }\n\n    /**\n     * Executes an instruction on this player's context\n     *\n     * @param  {CDGInstruction} instruction - CDG instruction to run\n     * @return {self}\n     */\n    executeInstruction(instruction) {\n        if (instruction && typeof instruction.execute === 'function') {\n            instruction.execute(this.context);\n        }\n        return this;\n    }\n\n    /**\n     * Executes the next CDG instruction packet\n     *\n     * @return {self}\n     */\n    step() {\n        if (this.pc >= 0 && this.pc < this.instructions.length) {\n            this.executeInstruction(this.instructions[this.pc]);\n            this.pc += 1;\n        } else {\n            this.pc = -1;\n            this.stop();\n        }\n        return this;\n    }\n\n    /**\n     * Executes several CDG instructions\n     *\n     * @param  {number} [count]\n     * @return {self}\n     */\n    fastForward(count = 1) {\n        const max = this.pc + count;\n        while (this.pc >= 0 && this.pc < max) {\n            this.step();\n        }\n        return this;\n    }\n\n    /**\n     * Starts CDG playback\n     *\n     * @return {self}\n     */\n    play() {\n        if (!this.frameId) {\n            this.frameId = requestFrame(this.update);\n            this.lastTimestamp = now();\n        }\n        return this;\n    }\n\n    /**\n     * Stops CDG playback\n     *\n     * @return {self}\n     */\n    stop() {\n        cancelFrame(this.frameId);\n        this.frameId = null;\n        this.lastSyncPos = null;\n        return this;\n    }\n\n    /**\n     * Syncs playback with a timestamp\n     *\n     * This is used to sync with the current time of the audio track\n     *\n     * @param  {number} ms - sync timestamp\n     * @return {self}\n     */\n    sync(ms) {\n        this.lastSyncPos = ms;\n        this.lastTimestamp = now();\n        return this;\n    }\n}\n","/**\n * Deferred()\n * Is a shim, written by Mozilla. It's a backwards/forwards compatible helper object to account for the\n * elimination of the Deferred object while still having a need for the functionality.\n *\n * https://developer.mozilla.org/en-US/docs/Mozilla/JavaScript_code_modules/Promise.jsm/Deferred#backwards_forwards_compatible\n * (Usage example can be found at above link, but here's the basics)\n *\n * const deferred = new Deferred();\n * const promise = deferred.promise; // still just a promise\n */\n\nconst Deferred = function () {\n    // update 062115 for typeof\n    if (typeof(Promise) !== 'undefined' && Promise.defer) {\n        //need import of Promise.jsm for example: Cu.import('resource:/gree/modules/Promise.jsm');\n        return Promise.defer();\n    } else if (typeof(PromiseUtils) !== 'undefined'  && PromiseUtils.defer) { // eslint-disable-line no-undef\n        //need import of PromiseUtils.jsm for example: Cu.import('resource:/gree/modules/PromiseUtils.jsm');\n        return PromiseUtils.defer(); // eslint-disable-line no-undef\n    } else {\n        /* A method to resolve the associated Promise with the value passed.\n         * If the promise is already settled it does nothing.\n         *\n         * @param {anything} value : This value is used to resolve the promise\n         * If the value is a Promise then the associated promise assumes the state\n         * of Promise passed as value.\n         */\n        this.resolve = null;\n\n        /* A method to reject the assocaited Promise with the value passed.\n         * If the promise is already settled it does nothing.\n         *\n         * @param {anything} reason: The reason for the rejection of the Promise.\n         * Generally its an Error object. If however a Promise is passed, then the Promise\n         * itself will be the reason for rejection no matter the state of the Promise.\n         */\n        this.reject = null;\n\n        /* A newly created Promise object.\n         * Initially in pending state.\n         */\n        this.promise = new Promise(function(resolve, reject) {\n            this.resolve = resolve;\n            this.reject = reject;\n        }.bind(this));\n        Object.freeze(this);\n    }\n};\n\nexport default Deferred;","// JSZip and JSZipUtils are external dependencies\n//import * as JSZip from 'jszip';\n//import JSZipUtils from 'jszip-utils';\nimport Deferred from '../utilities/deferred.js';\n// import jsmediatags from 'jsmediatags';\n\nconst getDataFile = function(filePath) {\n  const deferred = new Deferred();\n  JSZipUtils.getBinaryContent(filePath, (err, data) => {\n    if (err) {\n      deferred.reject(new Error(`There was an error retrieving ${filePath}`, err));\n      return;\n    }\n    deferred.resolve(data);\n  });\n  return deferred.promise;\n};\n\nconst loadZipBuffer = function(fileBuffer) {\n  return JSZip.loadAsync(fileBuffer).catch(error =>\n    Promise.reject(new Error(`There was an error reading the zip file.`, error))\n  );\n};\n\nconst loadAudio = function(zipEntry) {\n  return zipEntry\n    .async('arraybuffer')\n    .catch(() => Promise.reject(new Error(`Unable to load the audio file`)));\n};\n\nconst getFallbackTagData = function(name) {\n  const parts = name.split(' - ');\n  const tag = { tags: {} };\n  // most downloaded cdgs have filenames 'album - artist - songtitle\n  tag.tags.album = parts[0].trim();\n  tag.tags.artist = parts[1] ? parts[1].trim() : tag.tags.album;\n  tag.tags.title = parts[2] ? parts[2].trim() : tag.tags.artist;\n  return tag;\n};\n\nconst getTagData = function(zipEntry) {\n  return zipEntry\n    .async('blob')\n    .then(\n      buffer =>\n        new Promise(resolve => {\n          new jsmediatags.Reader(buffer)\n            .setTagsToRead(['title', 'artist', 'album', 'track', 'year', 'genre', 'picture'])\n            .read({\n              onSuccess: tag => resolve(tag),\n              onError: () => resolve(getFallbackTagData(zipEntry.name))\n            });\n        })\n    )\n    .catch(() => Promise.reject(new Error('Unable to parse tag data')));\n};\n\nconst loadVideo = function(zipEntry) {\n  return zipEntry\n    .async('uint8array')\n    .catch(() => Promise.reject(new Error(`Unable to load the video file`)));\n};\n\nconst getKaraokeFiles = function(zipFile) {\n  const entries = zipFile.filter(relPath => relPath.endsWith('.cdg') || relPath.endsWith('.mp3'));\n  if (entries.length === 2) {\n    return Promise.resolve(entries);\n  }\n  return Promise.reject(`The file is not a karaoke .zip file`);\n};\n\nconst processZip = function(entries) {\n  const audio = entries.filter(entry => entry.name.endsWith('.mp3'));\n  const video = entries.filter(entry => entry.name.endsWith('.cdg'));\n  const process = [];\n  if (audio.length && video.length) {\n    process.push(loadAudio(audio[0]));\n    process.push(loadVideo(video[0]));\n    process.push(getTagData(audio[0]));\n    return Promise.all(process).catch(() =>\n      Promise.reject(new Error(`Processing audio and video failed`))\n    );\n  }\n  const errors = [];\n  if (!audio.length) {\n    errors.push('No mp3 audio file present.');\n  }\n  if (!video.length) {\n    errors.push('No cdg video file present.');\n  }\n  return Promise.reject(new Error(errors.join(' ')));\n};\n\nexport default class CDGFileLoader {\n  static loadZipFile(filePath) {\n    return getDataFile(filePath)\n      .then(fileBuffer => loadZipBuffer(fileBuffer))\n      .then(zipFile => getKaraokeFiles(zipFile))\n      .then(entries => processZip(entries))\n      .catch(error => Promise.reject(error));\n  }\n\n  static loadFileBuffer(fileBuffer) {\n    return loadZipBuffer(fileBuffer)\n      .then(zipFile => getKaraokeFiles(zipFile))\n      .then(entries => processZip(entries))\n      .catch(err => Promise.reject(err));\n  }\n}\n","/*\n * SoundTouch JS v0.1.21 audio processing library\n * Copyright (c) Olli Parviainen\n * Copyright (c) Ryan Berdeen\n * Copyright (c) Jakub Fiala\n * Copyright (c) Steve 'Cutter' Blades\n *\n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n */\n\nclass FifoSampleBuffer {\n  constructor() {\n    this._vector = new Float32Array();\n    this._position = 0;\n    this._frameCount = 0;\n  }\n  get vector() {\n    return this._vector;\n  }\n  get position() {\n    return this._position;\n  }\n  get startIndex() {\n    return this._position * 2;\n  }\n  get frameCount() {\n    return this._frameCount;\n  }\n  get endIndex() {\n    return (this._position + this._frameCount) * 2;\n  }\n  clear() {\n    this.receive(this._frameCount);\n    this.rewind();\n  }\n  put(numFrames) {\n    this._frameCount += numFrames;\n  }\n  putSamples(samples, position, numFrames = 0) {\n    position = position || 0;\n    const sourceOffset = position * 2;\n    if (!(numFrames >= 0)) {\n      numFrames = (samples.length - sourceOffset) / 2;\n    }\n    const numSamples = numFrames * 2;\n    this.ensureCapacity(numFrames + this._frameCount);\n    const destOffset = this.endIndex;\n    this.vector.set(samples.subarray(sourceOffset, sourceOffset + numSamples), destOffset);\n    this._frameCount += numFrames;\n  }\n  putBuffer(buffer, position, numFrames = 0) {\n    position = position || 0;\n    if (!(numFrames >= 0)) {\n      numFrames = buffer.frameCount - position;\n    }\n    this.putSamples(buffer.vector, buffer.position + position, numFrames);\n  }\n  receive(numFrames) {\n    if (!(numFrames >= 0) || numFrames > this._frameCount) {\n      numFrames = this.frameCount;\n    }\n    this._frameCount -= numFrames;\n    this._position += numFrames;\n  }\n  receiveSamples(output, numFrames = 0) {\n    const numSamples = numFrames * 2;\n    const sourceOffset = this.startIndex;\n    output.set(this._vector.subarray(sourceOffset, sourceOffset + numSamples));\n    this.receive(numFrames);\n  }\n  extract(output, position = 0, numFrames = 0) {\n    const sourceOffset = this.startIndex + position * 2;\n    const numSamples = numFrames * 2;\n    output.set(this._vector.subarray(sourceOffset, sourceOffset + numSamples));\n  }\n  ensureCapacity(numFrames = 0) {\n    const minLength = parseInt(numFrames * 2);\n    if (this._vector.length < minLength) {\n      const newVector = new Float32Array(minLength);\n      newVector.set(this._vector.subarray(this.startIndex, this.endIndex));\n      this._vector = newVector;\n      this._position = 0;\n    } else {\n      this.rewind();\n    }\n  }\n  ensureAdditionalCapacity(numFrames = 0) {\n    this.ensureCapacity(this._frameCount + numFrames);\n  }\n  rewind() {\n    if (this._position > 0) {\n      this._vector.set(this._vector.subarray(this.startIndex, this.endIndex));\n      this._position = 0;\n    }\n  }\n}\n\nclass AbstractFifoSamplePipe {\n  constructor(createBuffers) {\n    if (createBuffers) {\n      this._inputBuffer = new FifoSampleBuffer();\n      this._outputBuffer = new FifoSampleBuffer();\n    } else {\n      this._inputBuffer = this._outputBuffer = null;\n    }\n  }\n  get inputBuffer() {\n    return this._inputBuffer;\n  }\n  set inputBuffer(inputBuffer) {\n    this._inputBuffer = inputBuffer;\n  }\n  get outputBuffer() {\n    return this._outputBuffer;\n  }\n  set outputBuffer(outputBuffer) {\n    this._outputBuffer = outputBuffer;\n  }\n  clear() {\n    this._inputBuffer.clear();\n    this._outputBuffer.clear();\n  }\n}\n\nclass RateTransposer extends AbstractFifoSamplePipe {\n  constructor(createBuffers) {\n    super(createBuffers);\n    this.reset();\n    this._rate = 1;\n  }\n  set rate(rate) {\n    this._rate = rate;\n  }\n  reset() {\n    this.slopeCount = 0;\n    this.prevSampleL = 0;\n    this.prevSampleR = 0;\n  }\n  clone() {\n    const result = new RateTransposer();\n    result.rate = this._rate;\n    return result;\n  }\n  process() {\n    const numFrames = this._inputBuffer.frameCount;\n    this._outputBuffer.ensureAdditionalCapacity(numFrames / this._rate + 1);\n    const numFramesOutput = this.transpose(numFrames);\n    this._inputBuffer.receive();\n    this._outputBuffer.put(numFramesOutput);\n  }\n  transpose(numFrames = 0) {\n    if (numFrames === 0) {\n      return 0;\n    }\n    const src = this._inputBuffer.vector;\n    const srcOffset = this._inputBuffer.startIndex;\n    const dest = this._outputBuffer.vector;\n    const destOffset = this._outputBuffer.endIndex;\n    let used = 0;\n    let i = 0;\n    while (this.slopeCount < 1.0) {\n      dest[destOffset + 2 * i] = (1.0 - this.slopeCount) * this.prevSampleL + this.slopeCount * src[srcOffset];\n      dest[destOffset + 2 * i + 1] = (1.0 - this.slopeCount) * this.prevSampleR + this.slopeCount * src[srcOffset + 1];\n      i = i + 1;\n      this.slopeCount += this._rate;\n    }\n    this.slopeCount -= 1.0;\n    if (numFrames !== 1) {\n      out: while (true) {\n        while (this.slopeCount > 1.0) {\n          this.slopeCount -= 1.0;\n          used = used + 1;\n          if (used >= numFrames - 1) {\n            break out;\n          }\n        }\n        const srcIndex = srcOffset + 2 * used;\n        dest[destOffset + 2 * i] = (1.0 - this.slopeCount) * src[srcIndex] + this.slopeCount * src[srcIndex + 2];\n        dest[destOffset + 2 * i + 1] = (1.0 - this.slopeCount) * src[srcIndex + 1] + this.slopeCount * src[srcIndex + 3];\n        i = i + 1;\n        this.slopeCount += this._rate;\n      }\n    }\n    this.prevSampleL = src[srcOffset + 2 * numFrames - 2];\n    this.prevSampleR = src[srcOffset + 2 * numFrames - 1];\n    return i;\n  }\n}\n\nclass FilterSupport {\n  constructor(pipe) {\n    this._pipe = pipe;\n  }\n  get pipe() {\n    return this._pipe;\n  }\n  get inputBuffer() {\n    return this._pipe.inputBuffer;\n  }\n  get outputBuffer() {\n    return this._pipe.outputBuffer;\n  }\n  fillInputBuffer()\n  {\n    throw new Error('fillInputBuffer() not overridden');\n  }\n  fillOutputBuffer(numFrames = 0) {\n    while (this.outputBuffer.frameCount < numFrames) {\n      const numInputFrames = 8192 * 2 - this.inputBuffer.frameCount;\n      this.fillInputBuffer(numInputFrames);\n      if (this.inputBuffer.frameCount < 8192 * 2) {\n        break;\n      }\n      this._pipe.process();\n    }\n  }\n  clear() {\n    this._pipe.clear();\n  }\n}\n\nconst noop = function () {\n  return;\n};\n\nclass SimpleFilter extends FilterSupport {\n  constructor(sourceSound, pipe, callback = noop) {\n    super(pipe);\n    this.callback = callback;\n    this.sourceSound = sourceSound;\n    this.historyBufferSize = 22050;\n    this._sourcePosition = 0;\n    this.outputBufferPosition = 0;\n    this._position = 0;\n  }\n  get position() {\n    return this._position;\n  }\n  set position(position) {\n    if (position > this._position) {\n      throw new RangeError('New position may not be greater than current position');\n    }\n    const newOutputBufferPosition = this.outputBufferPosition - (this._position - position);\n    if (newOutputBufferPosition < 0) {\n      throw new RangeError('New position falls outside of history buffer');\n    }\n    this.outputBufferPosition = newOutputBufferPosition;\n    this._position = position;\n  }\n  get sourcePosition() {\n    return this._sourcePosition;\n  }\n  set sourcePosition(sourcePosition) {\n    this.clear();\n    this._sourcePosition = sourcePosition;\n  }\n  onEnd() {\n    this.callback();\n  }\n  fillInputBuffer(numFrames = 0) {\n    const samples = new Float32Array(numFrames * 2);\n    const numFramesExtracted = this.sourceSound.extract(samples, numFrames, this._sourcePosition);\n    this._sourcePosition += numFramesExtracted;\n    this.inputBuffer.putSamples(samples, 0, numFramesExtracted);\n  }\n  extract(target, numFrames = 0) {\n    this.fillOutputBuffer(this.outputBufferPosition + numFrames);\n    const numFramesExtracted = Math.min(numFrames, this.outputBuffer.frameCount - this.outputBufferPosition);\n    this.outputBuffer.extract(target, this.outputBufferPosition, numFramesExtracted);\n    const currentFrames = this.outputBufferPosition + numFramesExtracted;\n    this.outputBufferPosition = Math.min(this.historyBufferSize, currentFrames);\n    this.outputBuffer.receive(Math.max(currentFrames - this.historyBufferSize, 0));\n    this._position += numFramesExtracted;\n    return numFramesExtracted;\n  }\n  handleSampleData(event) {\n    this.extract(event.data, 4096);\n  }\n  clear() {\n    super.clear();\n    this.outputBufferPosition = 0;\n  }\n}\n\nconst USE_AUTO_SEQUENCE_LEN = 0;\nconst DEFAULT_SEQUENCE_MS = USE_AUTO_SEQUENCE_LEN;\nconst USE_AUTO_SEEKWINDOW_LEN = 0;\nconst DEFAULT_SEEKWINDOW_MS = USE_AUTO_SEEKWINDOW_LEN;\nconst DEFAULT_OVERLAP_MS = 8;\nconst _SCAN_OFFSETS = [[124, 186, 248, 310, 372, 434, 496, 558, 620, 682, 744, 806, 868, 930, 992, 1054, 1116, 1178, 1240, 1302, 1364, 1426, 1488, 0], [-100, -75, -50, -25, 25, 50, 75, 100, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [-20, -15, -10, -5, 5, 10, 15, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [-4, -3, -2, -1, 1, 2, 3, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]];\nconst AUTOSEQ_TEMPO_LOW = 0.5;\nconst AUTOSEQ_TEMPO_TOP = 2.0;\nconst AUTOSEQ_AT_MIN = 125.0;\nconst AUTOSEQ_AT_MAX = 50.0;\nconst AUTOSEQ_K = (AUTOSEQ_AT_MAX - AUTOSEQ_AT_MIN) / (AUTOSEQ_TEMPO_TOP - AUTOSEQ_TEMPO_LOW);\nconst AUTOSEQ_C = AUTOSEQ_AT_MIN - AUTOSEQ_K * AUTOSEQ_TEMPO_LOW;\nconst AUTOSEEK_AT_MIN = 25.0;\nconst AUTOSEEK_AT_MAX = 15.0;\nconst AUTOSEEK_K = (AUTOSEEK_AT_MAX - AUTOSEEK_AT_MIN) / (AUTOSEQ_TEMPO_TOP - AUTOSEQ_TEMPO_LOW);\nconst AUTOSEEK_C = AUTOSEEK_AT_MIN - AUTOSEEK_K * AUTOSEQ_TEMPO_LOW;\nclass Stretch extends AbstractFifoSamplePipe {\n  constructor(createBuffers) {\n    super(createBuffers);\n    this._quickSeek = true;\n    this.midBufferDirty = false;\n    this.midBuffer = null;\n    this.overlapLength = 0;\n    this.autoSeqSetting = true;\n    this.autoSeekSetting = true;\n    this._tempo = 1;\n    this.setParameters(44100, DEFAULT_SEQUENCE_MS, DEFAULT_SEEKWINDOW_MS, DEFAULT_OVERLAP_MS);\n  }\n  clear() {\n    super.clear();\n    this.clearMidBuffer();\n  }\n  clearMidBuffer() {\n    if (this.midBufferDirty) {\n      this.midBufferDirty = false;\n      this.midBuffer = null;\n    }\n  }\n  setParameters(sampleRate, sequenceMs, seekWindowMs, overlapMs) {\n    if (sampleRate > 0) {\n      this.sampleRate = sampleRate;\n    }\n    if (overlapMs > 0) {\n      this.overlapMs = overlapMs;\n    }\n    if (sequenceMs > 0) {\n      this.sequenceMs = sequenceMs;\n      this.autoSeqSetting = false;\n    } else {\n      this.autoSeqSetting = true;\n    }\n    if (seekWindowMs > 0) {\n      this.seekWindowMs = seekWindowMs;\n      this.autoSeekSetting = false;\n    } else {\n      this.autoSeekSetting = true;\n    }\n    this.calculateSequenceParameters();\n    this.calculateOverlapLength(this.overlapMs);\n    this.tempo = this._tempo;\n  }\n  set tempo(newTempo) {\n    let intskip;\n    this._tempo = newTempo;\n    this.calculateSequenceParameters();\n    this.nominalSkip = this._tempo * (this.seekWindowLength - this.overlapLength);\n    this.skipFract = 0;\n    intskip = Math.floor(this.nominalSkip + 0.5);\n    this.sampleReq = Math.max(intskip + this.overlapLength, this.seekWindowLength) + this.seekLength;\n  }\n  get tempo() {\n    return this._tempo;\n  }\n  get inputChunkSize() {\n    return this.sampleReq;\n  }\n  get outputChunkSize() {\n    return this.overlapLength + Math.max(0, this.seekWindowLength - 2 * this.overlapLength);\n  }\n  calculateOverlapLength(overlapInMsec = 0) {\n    let newOvl;\n    newOvl = this.sampleRate * overlapInMsec / 1000;\n    newOvl = newOvl < 16 ? 16 : newOvl;\n    newOvl -= newOvl % 8;\n    this.overlapLength = newOvl;\n    this.refMidBuffer = new Float32Array(this.overlapLength * 2);\n    this.midBuffer = new Float32Array(this.overlapLength * 2);\n  }\n  checkLimits(x, mi, ma) {\n    return x < mi ? mi : x > ma ? ma : x;\n  }\n  calculateSequenceParameters() {\n    let seq;\n    let seek;\n    if (this.autoSeqSetting) {\n      seq = AUTOSEQ_C + AUTOSEQ_K * this._tempo;\n      seq = this.checkLimits(seq, AUTOSEQ_AT_MAX, AUTOSEQ_AT_MIN);\n      this.sequenceMs = Math.floor(seq + 0.5);\n    }\n    if (this.autoSeekSetting) {\n      seek = AUTOSEEK_C + AUTOSEEK_K * this._tempo;\n      seek = this.checkLimits(seek, AUTOSEEK_AT_MAX, AUTOSEEK_AT_MIN);\n      this.seekWindowMs = Math.floor(seek + 0.5);\n    }\n    this.seekWindowLength = Math.floor(this.sampleRate * this.sequenceMs / 1000);\n    this.seekLength = Math.floor(this.sampleRate * this.seekWindowMs / 1000);\n  }\n  set quickSeek(enable) {\n    this._quickSeek = enable;\n  }\n  clone() {\n    const result = new Stretch();\n    result.tempo = this._tempo;\n    result.setParameters(this.sampleRate, this.sequenceMs, this.seekWindowMs, this.overlapMs);\n    return result;\n  }\n  seekBestOverlapPosition() {\n    return this._quickSeek ? this.seekBestOverlapPositionStereoQuick() : this.seekBestOverlapPositionStereo();\n  }\n  seekBestOverlapPositionStereo() {\n    let bestOffset;\n    let bestCorrelation;\n    let correlation;\n    let i = 0;\n    this.preCalculateCorrelationReferenceStereo();\n    bestOffset = 0;\n    bestCorrelation = Number.MIN_VALUE;\n    for (; i < this.seekLength; i = i + 1) {\n      correlation = this.calculateCrossCorrelationStereo(2 * i, this.refMidBuffer);\n      if (correlation > bestCorrelation) {\n        bestCorrelation = correlation;\n        bestOffset = i;\n      }\n    }\n    return bestOffset;\n  }\n  seekBestOverlapPositionStereoQuick() {\n    let bestOffset;\n    let bestCorrelation;\n    let correlation;\n    let scanCount = 0;\n    let correlationOffset;\n    let tempOffset;\n    this.preCalculateCorrelationReferenceStereo();\n    bestCorrelation = Number.MIN_VALUE;\n    bestOffset = 0;\n    correlationOffset = 0;\n    tempOffset = 0;\n    for (; scanCount < 4; scanCount = scanCount + 1) {\n      let j = 0;\n      while (_SCAN_OFFSETS[scanCount][j]) {\n        tempOffset = correlationOffset + _SCAN_OFFSETS[scanCount][j];\n        if (tempOffset >= this.seekLength) {\n          break;\n        }\n        correlation = this.calculateCrossCorrelationStereo(2 * tempOffset, this.refMidBuffer);\n        if (correlation > bestCorrelation) {\n          bestCorrelation = correlation;\n          bestOffset = tempOffset;\n        }\n        j = j + 1;\n      }\n      correlationOffset = bestOffset;\n    }\n    return bestOffset;\n  }\n  preCalculateCorrelationReferenceStereo() {\n    let i = 0;\n    let context;\n    let temp;\n    for (; i < this.overlapLength; i = i + 1) {\n      temp = i * (this.overlapLength - i);\n      context = i * 2;\n      this.refMidBuffer[context] = this.midBuffer[context] * temp;\n      this.refMidBuffer[context + 1] = this.midBuffer[context + 1] * temp;\n    }\n  }\n  calculateCrossCorrelationStereo(mixingPosition, compare) {\n    const mixing = this._inputBuffer.vector;\n    mixingPosition += this._inputBuffer.startIndex;\n    let correlation = 0;\n    let i = 2;\n    const calcLength = 2 * this.overlapLength;\n    let mixingOffset;\n    for (; i < calcLength; i = i + 2) {\n      mixingOffset = i + mixingPosition;\n      correlation += mixing[mixingOffset] * compare[i] + mixing[mixingOffset + 1] * compare[i + 1];\n    }\n    return correlation;\n  }\n  overlap(overlapPosition) {\n    this.overlapStereo(2 * overlapPosition);\n  }\n  overlapStereo(inputPosition) {\n    const input = this._inputBuffer.vector;\n    inputPosition += this._inputBuffer.startIndex;\n    const output = this._outputBuffer.vector;\n    const outputPosition = this._outputBuffer.endIndex;\n    let i = 0;\n    let context;\n    let tempFrame;\n    const frameScale = 1 / this.overlapLength;\n    let fi;\n    let inputOffset;\n    let outputOffset;\n    for (; i < this.overlapLength; i = i + 1) {\n      tempFrame = (this.overlapLength - i) * frameScale;\n      fi = i * frameScale;\n      context = 2 * i;\n      inputOffset = context + inputPosition;\n      outputOffset = context + outputPosition;\n      output[outputOffset + 0] = input[inputOffset + 0] * fi + this.midBuffer[context + 0] * tempFrame;\n      output[outputOffset + 1] = input[inputOffset + 1] * fi + this.midBuffer[context + 1] * tempFrame;\n    }\n  }\n  process() {\n    let offset;\n    let temp;\n    let overlapSkip;\n    if (this.midBuffer === null) {\n      if (this._inputBuffer.frameCount < this.overlapLength) {\n        return;\n      }\n      this.midBuffer = new Float32Array(this.overlapLength * 2);\n      this._inputBuffer.receiveSamples(this.midBuffer, this.overlapLength);\n    }\n    while (this._inputBuffer.frameCount >= this.sampleReq) {\n      offset = this.seekBestOverlapPosition();\n      this._outputBuffer.ensureAdditionalCapacity(this.overlapLength);\n      this.overlap(Math.floor(offset));\n      this._outputBuffer.put(this.overlapLength);\n      temp = this.seekWindowLength - 2 * this.overlapLength;\n      if (temp > 0) {\n        this._outputBuffer.putBuffer(this._inputBuffer, offset + this.overlapLength, temp);\n      }\n      const start = this._inputBuffer.startIndex + 2 * (offset + this.seekWindowLength - this.overlapLength);\n      this.midBuffer.set(this._inputBuffer.vector.subarray(start, start + 2 * this.overlapLength));\n      this.skipFract += this.nominalSkip;\n      overlapSkip = Math.floor(this.skipFract);\n      this.skipFract -= overlapSkip;\n      this._inputBuffer.receive(overlapSkip);\n    }\n  }\n}\n\nconst testFloatEqual = function (a, b) {\n  return (a > b ? a - b : b - a) > 1e-10;\n};\n\nclass SoundTouch {\n  constructor() {\n    this.transposer = new RateTransposer(false);\n    this.stretch = new Stretch(false);\n    this._inputBuffer = new FifoSampleBuffer();\n    this._intermediateBuffer = new FifoSampleBuffer();\n    this._outputBuffer = new FifoSampleBuffer();\n    this._rate = 0;\n    this._tempo = 0;\n    this.virtualPitch = 1.0;\n    this.virtualRate = 1.0;\n    this.virtualTempo = 1.0;\n    this.calculateEffectiveRateAndTempo();\n  }\n  clear() {\n    this.transposer.clear();\n    this.stretch.clear();\n  }\n  clone() {\n    const result = new SoundTouch();\n    result.rate = this.rate;\n    result.tempo = this.tempo;\n    return result;\n  }\n  get rate() {\n    return this._rate;\n  }\n  set rate(rate) {\n    this.virtualRate = rate;\n    this.calculateEffectiveRateAndTempo();\n  }\n  set rateChange(rateChange) {\n    this._rate = 1.0 + 0.01 * rateChange;\n  }\n  get tempo() {\n    return this._tempo;\n  }\n  set tempo(tempo) {\n    this.virtualTempo = tempo;\n    this.calculateEffectiveRateAndTempo();\n  }\n  set tempoChange(tempoChange) {\n    this.tempo = 1.0 + 0.01 * tempoChange;\n  }\n  set pitch(pitch) {\n    this.virtualPitch = pitch;\n    this.calculateEffectiveRateAndTempo();\n  }\n  set pitchOctaves(pitchOctaves) {\n    this.pitch = Math.exp(0.69314718056 * pitchOctaves);\n    this.calculateEffectiveRateAndTempo();\n  }\n  set pitchSemitones(pitchSemitones) {\n    this.pitchOctaves = pitchSemitones / 12.0;\n  }\n  get inputBuffer() {\n    return this._inputBuffer;\n  }\n  get outputBuffer() {\n    return this._outputBuffer;\n  }\n  calculateEffectiveRateAndTempo() {\n    const previousTempo = this._tempo;\n    const previousRate = this._rate;\n    this._tempo = this.virtualTempo / this.virtualPitch;\n    this._rate = this.virtualRate * this.virtualPitch;\n    if (testFloatEqual(this._tempo, previousTempo)) {\n      this.stretch.tempo = this._tempo;\n    }\n    if (testFloatEqual(this._rate, previousRate)) {\n      this.transposer.rate = this._rate;\n    }\n    if (this._rate > 1.0) {\n      if (this._outputBuffer != this.transposer.outputBuffer) {\n        this.stretch.inputBuffer = this._inputBuffer;\n        this.stretch.outputBuffer = this._intermediateBuffer;\n        this.transposer.inputBuffer = this._intermediateBuffer;\n        this.transposer.outputBuffer = this._outputBuffer;\n      }\n    } else {\n      if (this._outputBuffer != this.stretch.outputBuffer) {\n        this.transposer.inputBuffer = this._inputBuffer;\n        this.transposer.outputBuffer = this._intermediateBuffer;\n        this.stretch.inputBuffer = this._intermediateBuffer;\n        this.stretch.outputBuffer = this._outputBuffer;\n      }\n    }\n  }\n  process() {\n    if (this._rate > 1.0) {\n      this.stretch.process();\n      this.transposer.process();\n    } else {\n      this.transposer.process();\n      this.stretch.process();\n    }\n  }\n}\n\nclass WebAudioBufferSource {\n  constructor(buffer) {\n    this.buffer = buffer;\n    this._position = 0;\n  }\n  get dualChannel() {\n    return this.buffer.numberOfChannels > 1;\n  }\n  get position() {\n    return this._position;\n  }\n  set position(value) {\n    this._position = value;\n  }\n  extract(target, numFrames = 0, position = 0) {\n    this.position = position;\n    let left = this.buffer.getChannelData(0);\n    let right = this.dualChannel ? this.buffer.getChannelData(1) : this.buffer.getChannelData(0);\n    let i = 0;\n    for (; i < numFrames; i++) {\n      target[i * 2] = left[i + position];\n      target[i * 2 + 1] = right[i + position];\n    }\n    return Math.min(numFrames, left.length - position);\n  }\n}\n\nconst getWebAudioNode = function (context, filter, sourcePositionCallback = noop, bufferSize = 4096) {\n  const node = context.createScriptProcessor(bufferSize, 2, 2);\n  const samples = new Float32Array(bufferSize * 2);\n  node.onaudioprocess = event => {\n    let left = event.outputBuffer.getChannelData(0);\n    let right = event.outputBuffer.getChannelData(1);\n    let framesExtracted = filter.extract(samples, bufferSize);\n    sourcePositionCallback(filter.sourcePosition);\n    if (framesExtracted === 0) {\n      filter.onEnd();\n    }\n    let i = 0;\n    for (; i < framesExtracted; i++) {\n      left[i] = samples[i * 2];\n      right[i] = samples[i * 2 + 1];\n    }\n  };\n  return node;\n};\n\nconst pad = function (n, width, z) {\n  z = z || '0';\n  n = n + '';\n  return n.length >= width ? n : new Array(width - n.length + 1).join(z) + n;\n};\nconst minsSecs = function (secs) {\n  const mins = Math.floor(secs / 60);\n  const seconds = secs - mins * 60;\n  return `${mins}:${pad(parseInt(seconds), 2)}`;\n};\n\nconst onUpdate = function (sourcePosition) {\n  const currentTimePlayed = this.timePlayed;\n  const sampleRate = this.sampleRate;\n  this.sourcePosition = sourcePosition;\n  this.timePlayed = sourcePosition / sampleRate;\n  if (currentTimePlayed !== this.timePlayed) {\n    const timePlayed = new CustomEvent('play', {\n      detail: {\n        timePlayed: this.timePlayed,\n        formattedTimePlayed: this.formattedTimePlayed,\n        percentagePlayed: this.percentagePlayed\n      }\n    });\n    this._node.dispatchEvent(timePlayed);\n  }\n};\nclass PitchShifter {\n  constructor(context, buffer, bufferSize, onEnd = noop) {\n    this._soundtouch = new SoundTouch();\n    const source = new WebAudioBufferSource(buffer);\n    this.timePlayed = 0;\n    this.sourcePosition = 0;\n    this._filter = new SimpleFilter(source, this._soundtouch, onEnd);\n    this._node = getWebAudioNode(context, this._filter, sourcePostion => onUpdate.call(this, sourcePostion), bufferSize);\n    this.tempo = 1;\n    this.rate = 1;\n    this.duration = buffer.duration;\n    this.sampleRate = context.sampleRate;\n    this.listeners = [];\n  }\n  get formattedDuration() {\n    return minsSecs(this.duration);\n  }\n  get formattedTimePlayed() {\n    return minsSecs(this.timePlayed);\n  }\n  get percentagePlayed() {\n    return 100 * this._filter.sourcePosition / (this.duration * this.sampleRate);\n  }\n  set percentagePlayed(perc) {\n    this._filter.sourcePosition = parseInt(perc * this.duration * this.sampleRate);\n    this.sourcePosition = this._filter.sourcePosition;\n    this.timePlayed = this.sourcePosition / this.sampleRate;\n  }\n  get node() {\n    return this._node;\n  }\n  set pitch(pitch) {\n    this._soundtouch.pitch = pitch;\n  }\n  set pitchSemitones(semitone) {\n    this._soundtouch.pitchSemitones = semitone;\n  }\n  set rate(rate) {\n    this._soundtouch.rate = rate;\n  }\n  set tempo(tempo) {\n    this._soundtouch.tempo = tempo;\n  }\n  connect(toNode) {\n    this._node.connect(toNode);\n  }\n  disconnect() {\n    this._node.disconnect();\n  }\n  on(eventName, cb) {\n    this.listeners.push({\n      name: eventName,\n      cb: cb\n    });\n    this._node.addEventListener(eventName, event => cb(event.detail));\n  }\n  off(eventName = null) {\n    let listeners = this.listeners;\n    if (eventName) {\n      listeners = listeners.filter(e => e.name === eventName);\n    }\n    listeners.forEach(e => {\n      this._node.removeEventListener(e.name, event => e.cb(event.detail));\n    });\n  }\n}\n\nexport { AbstractFifoSamplePipe, PitchShifter, RateTransposer, SimpleFilter, SoundTouch, Stretch, WebAudioBufferSource, getWebAudioNode };\n//# sourceMappingURL=soundtouch.js.map\n","export const isString = function(value) {\n    return typeof value === 'string';\n};\n\nexport const isNumber = function(value) {\n    return typeof value === 'number';\n};\n\nexport const isDate = function(value) {\n    return toString.call(value) === '[object Date]';\n};\n\nexport const isArray = function(arr) {\n    return Array.isArray(arr);\n};\n\nexport const isFunction = function(value) {\n    return typeof value === 'function';\n};\n\nexport const isBoolean = function(value) {\n    return typeof value === 'boolean';\n};\n\nexport const isDefined = function(value) {\n    return typeof value !== 'undefined';\n};\n\nexport const isUndefined = function(value) {\n    return typeof value === 'undefined';\n};\n\nexport const isObject = function(value) {\n    return value !== null && typeof value === 'object';\n};\n\nexport const isPromise = function(obj) {\n    return (\n        !!obj &&\n        (typeof obj === 'object' || typeof obj === 'function') &&\n        typeof obj.then === 'function'\n    );\n};\n\nexport const isError = function(value) {\n    const tag = toString.call(value);\n    switch (tag) {\n        case '[object Error]':\n            return true;\n        case '[object Exception]':\n            return true;\n        case '[object DOMException]':\n            return true;\n        default:\n            return value instanceof Error;\n    }\n};\n","// From https://github.com/AntonLapshin/proxy-observable#readme\n/* eslint-disable */\nexport class PubSub {\n    /**\n     * Creates an instance of PubSub\n     */\n    constructor() {\n        this.fns = { any: [] };\n    }\n\n    /**\n     * Checks if a event has at least one subscription\n     *\n     * @param {string} e Event name\n     * @returns {boolean}\n     */\n    has(e) {\n        return (e in this.fns && this.fns[e].length > 0) || this.fns.any.length > 0;\n    }\n\n    /**\n     * Subscribes on event\n     *\n     * @param {string} e Event name\n     * @param {function} fn Callback\n     * @returns {function} Input callback\n     */\n    on(e, fn) {\n        if (e in this.fns === false) {\n            this.fns[e] = [];\n        }\n        this.fns[e].push(fn);\n        return fn;\n    }\n\n    /**\n     * Calls the event's callbacks\n     *\n     * @param {string} e Event name\n     * @param {any} value New value\n     * @param {any} prev Previous value\n     * @returns {object} Observable\n     */\n    fire(e, value, prev) {\n        this.fns.any.concat(e in this.fns ? this.fns[e] : []).forEach(fn => fn(value, prev, e));\n        return this;\n    }\n\n    /**\n     * Unsubscribes from event\n     *\n     * @param {function} fn Callback\n     * @returns {boolean} true if successfully unsubscribed\n     */\n    off(fn) {\n        for (const e in this.fns) {\n            const fns = this.fns[e];\n            for (let i = 0; i < fns.length; i++) {\n                if (fns[i] === fn) {\n                    fns.splice(i, 1);\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Subscribes on event once\n     *\n     * @param {string} e Event name\n     * @param {function} fn Callback\n     * @returns {function} Input callback\n     */\n    once(e, fn) {\n        const method = (value, prev, prop) => {\n            fn(value, prev, prop);\n            this.off(method);\n        };\n        this.on(e, method);\n        return fn;\n    }\n}\n","// From https://github.com/AntonLapshin/proxy-observable#readme\n/* eslint-disable */\nimport { PubSub } from './pubsub.js';\n\n/**\n * Creates a proxy observable for an object or array\n *\n * @param {object|Observable} target Input Object\n * @returns {Observable} Observable (ES6 Proxy)\n */\nexport default target => {\n    if (target.on && target.off) {\n        return target;\n    }\n    const pub = new PubSub();\n    const observable = new Proxy(target, {\n        get: (target, prop) => {\n            if (prop in target) {\n                if (target.constructor === Array) {\n                    let v = observable;\n                    if (prop === 'pop') {\n                        v = target[target.length - 1];\n                    } else if (prop === 'shift') {\n                        v = target[0];\n                    }\n                    if (prop !== 'push' && prop !== 'length') {\n                        pub.fire(prop, v);\n                    }\n                }\n                return target[prop];\n            } else if (prop === 'on') {\n                return pub.on.bind(pub);\n            } else if (prop === 'once') {\n                return pub.once.bind(pub);\n            } else if (prop === 'off') {\n                return pub.off.bind(pub);\n            }\n            return undefined;\n        },\n        set: (target, prop, v) => {\n            if (target.constructor === Array) {\n                if (prop !== 'length') {\n                    pub.fire('change', v);\n                }\n            } else if (pub.has(prop)) {\n                pub.fire(prop, v, target[prop]);\n            }\n            target[prop] = v;\n            return true;\n        }\n    });\n\n    return observable;\n};\n","import './karaokeplayer.scss';\nimport CDGPlayer from '../cdg/CDGPlayer.js';\nimport CDGFileLoader from '../loader/CDGFileLoader.js';\nimport { PitchShifter } from 'soundtouchjs';\nimport Deferred from '../utilities/deferred.js';\nimport {\n  WIDTH,\n  HEIGHT,\n  GAIN_DEFAULT,\n  SCALE_DEFAULT,\n  PITCH_DEFAULT,\n  START_TIME,\n  FILTER_PLAYBACK_OFFSET\n} from '../cdg/constants';\nimport { isString } from '../utilities/is.js';\nimport observable from '../observable/observable.js';\n\nconst createDisplayCanvas = function(width, height) {\n  const canvas = document.createElement('canvas');\n  canvas.width = width;\n  canvas.height = height;\n  return canvas;\n};\n\nconst createCanvasContext = function(canvas) {\n  const ctx = canvas.getContext('2d');\n  ctx.webkitImageSmoothingEnabled = false;\n  ctx.mozImageSmoothingEnabled = false;\n  ctx.msImageSmoothingEnabled = false;\n  ctx.imageSmoothingEnabled = false;\n  return ctx;\n};\n\nconst copyContextToCanvas = function(context) {\n  // If there's transparency, clear the canvas first\n  if (context.keyColor >= 0) {\n    this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);\n  }\n  // Copy from source canvas to the target canvas\n  this.ctx.drawImage(\n    context.canvas,\n    0,\n    0,\n    context.canvas.width,\n    context.canvas.height,\n    0,\n    0,\n    this.canvas.width,\n    this.canvas.height\n  );\n};\n\nconst clearCanvas = function(context, canvas) {\n  context.clearRect(0, 0, canvas.width, canvas.height);\n};\n\nconst loadAudio = function(buffer) {\n  if (this.shifter) {\n    this.shifter.off();\n  }\n  return this.audio\n    .decodeAudioData(buffer)\n    .then(audioBuffer => {\n      this.shifter = observable(\n        new PitchShifter(this.audio, audioBuffer, 1024, () => {\n          this.stop();\n        })\n      );\n      this.shifter.on('play', detail => {\n        this.props.timePlayed = detail.formattedTimePlayed;\n        this.props.percentagePlayed = detail.percentagePlayed;\n        this.player.sync(detail.timePlayed * 1000 - FILTER_PLAYBACK_OFFSET);\n      });\n      this.shifter.pitch = PITCH_DEFAULT;\n      this.props.trackLength = this.shifter.formattedDuration;\n    })\n    .catch(error => Promise.reject(new Error(`There was an error decoding the audio file`, error)));\n};\n\nconst loadVideo = function(buffer) {\n  const deferred = new Deferred();\n  if (buffer) {\n    this.player.load(Array.from(buffer));\n    deferred.resolve();\n  } else {\n    deferred.reject(new Error('There was an error loading the video file'));\n  }\n  return deferred.promise;\n};\n\nconst wrapText = function(context, text, x, y, maxWidth, lineHeight) {\n  var words = text.split(' ');\n  var line = '';\n\n  for (var n = 0; n < words.length; n++) {\n    var testLine = line + words[n] + ' ';\n    var metrics = context.measureText(testLine);\n    var testWidth = metrics.width;\n    if (testWidth > maxWidth && n > 0) {\n      context.fillText(line.trim(), x, y);\n      line = words[n] + ' ';\n      y += lineHeight;\n    } else {\n      line = testLine;\n    }\n  }\n  context.fillText(line.trim(), x, y);\n};\n\nconst drawTag = function() {\n  const ctx = this.ctx;\n  const cvs = this.canvas;\n  const maxWidth = cvs.width - 10;\n  let lineHeight = 30;\n  const x = maxWidth / 2;\n  let y = 60;\n  ctx.font = '30px sans-serif';\n  ctx.fillStyle = '#fff';\n  ctx.textAlign = 'center';\n  wrapText(ctx, this.tag.title, x, y, maxWidth, lineHeight);\n  ctx.font = '20px sans-serif';\n  y = cvs.height - 60;\n  wrapText(ctx, `by ${this.tag.artist}`, x, y, maxWidth, lineHeight);\n};\n\nconst loadTag = function(tag) {\n  this.tag = tag && tag.tags;\n  if (this.tag) {\n    return drawTag.call(this);\n  }\n};\n\nconst handleExtractedZip = function(responseArr) {\n  const process = [];\n  process.push(loadAudio.call(this, responseArr[0])); // audio is always first\n  process.push(loadVideo.call(this, responseArr[1])); // video is always second\n  return Promise.all(process)\n    .then(() => {\n      this.props.status = 'File Loaded';\n      this.props.loaded = true;\n      // Display tag after marking player loaded\n      loadTag.call(this, responseArr[2]); // mp3 tag data is always last\n    })\n    .catch(error => {\n      this.props.status = 'File Loading Failed';\n      return Promise.reject(error);\n    })\n    .then(() => {\n      this.props.loading = false;\n    });\n};\n\nconst setVolume = function(val) {\n  this.gainNode.gain.value = val;\n};\n\nexport class KaraokePlayer {\n  audio = null;\n  gainNode = null;\n  shifter = null;\n\n  wrapper = null;\n  player = null;\n  currentSize = SCALE_DEFAULT;\n  canvas = null;\n  ctx = null;\n\n  props = observable({\n    status: '',\n    loaded: false,\n    loading: false,\n    isPlaying: false,\n    timePlayed: START_TIME,\n    trackLength: START_TIME,\n    percentagePlayed: 0,\n    songVolume: 1,\n    destroy: false\n  });\n\n  constructor(selector) {\n    this.wrapper = document.querySelector(selector);\n    if (!this.wrapper) {\n      throw new Error(`CDGPlayer: and element was not found with the \"${selector}\" selector`);\n    }\n    this.wrapper.classList.add('cdg-video-wrapper');\n    this.canvas = createDisplayCanvas(WIDTH, HEIGHT);\n    this.canvas.classList.add('cdg-video-player');\n    this.ctx = createCanvasContext(this.canvas);\n    this.player = new CDGPlayer({\n      afterRender: context => copyContextToCanvas.call(this, context)\n    });\n    this.wrapper.appendChild(this.canvas);\n    const titleImage = document.createElement('div');\n    titleImage.classList.add('titleImage');\n    this.wrapper.appendChild(titleImage);\n    this.onloaded = this.props.on('loaded', val => {\n      if (val) {\n        titleImage.classList.add('hide');\n        return;\n      }\n      titleImage.classList.remove('hide');\n    });\n\n    this.audio = new (window.AudioContext || window.webkitAudioContext)();\n    this.gainNode = this.audio.createGain();\n    this.onvolume = this.props.on('songVolume', val => {\n      setVolume.call(this, val);\n    });\n    this.props.songVolume = GAIN_DEFAULT;\n  }\n\n  destroy() {\n    this.wrapper.classList.remove('cdg-video-wrapper');\n    this.stop();\n    this.gainNode.disconnect();\n    if (this.shifter) {\n      this.shifter.off();\n    }\n    this.shifter = null;\n    this.gainNode = null;\n    this.audio = null;\n    this.canvas.remove();\n    this.props.destroy = true;\n    this.props.off('onvolume');\n  }\n\n  load(filePath) {\n    this.stop();\n    clearCanvas(this.ctx, this.canvas);\n    this.props.loading = true;\n    let promise;\n    if (isString(filePath)) {\n      if (!filePath.toLowerCase().endsWith('.zip')) {\n        this.props.loading = false;\n        this.props.status = `${filePath} doesn't appear to be a \".zip\" file.`;\n\n        return Promise.reject(this.props.status);\n      }\n      this.props.status = 'Retrieving File...';\n      promise = CDGFileLoader.loadZipFile(filePath);\n    } else {\n      this.props.status = `Loading File...`;\n      promise = CDGFileLoader.loadFileBuffer(filePath);\n    }\n    return promise\n      .then(zipResponse => handleExtractedZip.call(this, zipResponse))\n      .catch(error => Promise.reject(error));\n  }\n\n  togglePlay() {\n    if (this.props.isPlaying) {\n      this.pause();\n    } else {\n      this.start();\n    }\n  }\n\n  start() {\n    clearCanvas.call(this, this.ctx, this.canvas);\n    this.shifter.connect(this.gainNode);\n    this.gainNode.connect(this.audio.destination);\n    // updates for autoplay issues\n    this.audio.resume().then(() => {\n      this.props.isPlaying = true;\n      this.player.play();\n    });\n  }\n\n  pause(playing = false) {\n    this.props.isPlaying = playing;\n    this.shifter.disconnect();\n    /*if (this.timeInterval) {\n      clearInterval(this.timeInterval);\n      this.timeInterval = null;\n    }*/\n    this.player.stop();\n  }\n\n  stop() {\n    if (this.shifter) {\n      this.pause();\n      this.changePlayerPosition(0);\n      drawTag.call(this);\n    }\n  }\n\n  changePlayerPosition(perc) {\n    perc = perc < 0 ? 0 : perc > 100 ? 100 : perc;\n    this.shifter.percentagePlayed = perc;\n    this.props.percentagePlayed = this.shifter.percentagePlayed;\n    this.props.timePlayed = this.shifter.formattedTimePlayed;\n    this.player.reset();\n    if (!perc) {\n      this.props.isPlaying = false;\n      this.props.timePlayed = START_TIME;\n    }\n  }\n\n  changeKey(pitchChange) {\n    pitchChange = pitchChange < -7 ? -7 : pitchChange > 7 ? 7 : pitchChange;\n    this.shifter.pitchSemitones = pitchChange;\n    this.shifter.tempo = 1; // keep the tempo straight\n  }\n\n  volume(change) {\n    const current = this.gainNode.gain.value;\n    const newValue = +(current + change).toFixed(2);\n    this.props.songVolume = newValue < 0 ? 0 : newValue > 1 ? 1 : newValue;\n  }\n\n  toggleMute() {\n    const fallback = this.gainNode.gain.value;\n    this.props.songVolume = fallback ? 0 : this.fallbackVolume;\n    this.fallbackVolume = fallback;\n  }\n}\n","import ctrlTemplate from './cdgcontrols.html';\nimport './cdgcontrols.scss';\nimport { PANEL_POSITION } from '../cdg/constants.js';\n\nconst playIcon = 'icofont-play-alt-1';\nconst pauseIcon = 'icofont-pause';\n\nconst htmlToElement = function(html) {\n  let template = document.createElement('template');\n  html = html.trim();\n  template.innerHTML = html;\n  return template.content.firstChild;\n};\n\nconst setupListeners = function() {\n  const props = this.player.props;\n  this.onloaded = props.on('loaded', val => {\n    if (val) {\n      this.playBtn.removeAttribute('disabled');\n      this.pitch.removeAttribute('disabled');\n      this.volumeBtn.removeAttribute('disabled');\n    } else {\n      this.playBtn.setAttribute('disabled', 'disabled');\n      this.pitch.setAttribute('disabled', 'disabled');\n      this.volumeBtn.setAttribute('disabled', 'disabled');\n    }\n  });\n  this.ontimeplayed = props.on('timePlayed', (val, prev) => {\n    if (val !== prev) {\n      this.timePlayed.innerHTML = val;\n    }\n  });\n  this.onpercentageplayed = props.on('percentagePlayed', (val, prev) => {\n    if (val !== prev) {\n      this.progress.value = val;\n    }\n  });\n  this.ontracklength = props.on('trackLength', (val, prev) => {\n    if (val !== prev) {\n      this.trackLength.innerHTML = val;\n    }\n  });\n  this.ondestroy = props.on('destroy', val => {\n    if (val) {\n      removeListeners.call(this);\n    }\n  });\n  this.onplay = props.on('isPlaying', val => {\n    this.playIcn.classList.remove(playIcon, pauseIcon);\n    this.playIcn.classList.add(val ? pauseIcon : playIcon);\n  });\n\n  this.onvolume = props.on('songVolume', val => {\n    const icn = this.volumeIcn;\n    this.volumeSlider.value = val;\n    if (val) {\n      if (icn.classList.contains('mute')) {\n        icn.classList.remove('mute');\n        return;\n      }\n      return;\n    }\n    icn.classList.add('mute');\n  });\n\n  this.playBtn.addEventListener('click', () => this.player.togglePlay());\n  this.progress.addEventListener('click', event => changePosition.call(this, event));\n  this.pitch.addEventListener('change', () => changeKey.call(this));\n  this.volumeSlider.addEventListener('change', () => changeVolume.call(this));\n};\n\nconst removeListeners = function() {\n  const props = this.player.props;\n  props.off(this.onloaded);\n  props.off(this.ontimeplayed);\n  props.off(this.onpercentageplayed);\n  props.off(this.ontracklength);\n  props.off(this.ondestroy);\n  props.off(this.onplay);\n  props.off(this.onvolume);\n  this.playBtn.removeEventListener('click', () => this.player.togglePlay());\n  this.progress.removeEventListener('click', event => changePosition.call(this, event));\n  this.pitch.removeEventListener('change', () => changeKey.call(this));\n  this.volumeSlider.removeEventListener('change', () => changeVolume.call(this));\n};\n\nconst changePosition = function(event) {\n  const pos = event.target.getBoundingClientRect();\n  const relX = event.pageX - pos.x;\n  const perc = relX / event.target.offsetWidth;\n  this.player.changePlayerPosition(perc);\n};\n\nconst changeKey = function() {\n  const val = this.pitch.value;\n  if (isNaN(val)) {\n    this.pitch.value = this.fallbackPitch;\n    return;\n  }\n  this.fallbackPitch = val < -7 ? -7 : val > 7 ? 7 : val;\n  this.player.changeKey(this.fallbackPitch);\n};\n\nconst changeVolume = function() {\n  this.player.props.songVolume = +(parseFloat(this.volumeSlider.value) + 0).toFixed(2);\n};\n\nexport default class CDGControls {\n  controls = htmlToElement(ctrlTemplate);\n  player = null;\n\n  playBtn = null;\n  playIcn = null;\n  timePlayed = null;\n  progress = null;\n  trackLength = null;\n  pitch = null;\n\n  constructor(selector, player, options = { position: 'bottom' }) {\n    const wrapper = document.querySelector(selector);\n    wrapper.appendChild(this.controls);\n    this.player = player;\n    const props = this.player.props;\n    this.playBtn = this.controls.querySelector('.playButton');\n    this.playIcn = this.playBtn.querySelector('i');\n    this.timePlayed = this.controls.querySelector('.timePlayed');\n    this.timePlayed.innerHTML = props.timePlayed;\n    this.progress = this.controls.querySelector('.progressMeter');\n    this.progress.value = props.percentagePlayed;\n    this.trackLength = this.controls.querySelector('.trackLength');\n    this.trackLength.innerHTML = props.trackLength;\n    this.pitch = this.controls.querySelector('.pitch');\n    this.fallbackPitch = 0;\n    if (!PANEL_POSITION.includes(options.position)) {\n      throw new Error(`Panel Position must be either 'top' or 'bottom'.`);\n    }\n    this.volumeBtn = this.controls.querySelector('#song_volume_button');\n    this.volumeIcn = this.volumeBtn.querySelector('i');\n    this.volumeSlider = this.controls.querySelector('#song_volume');\n    this.volumeSlider.value = props.songVolume;\n    if (options.position === 'top') {\n      const sliderContainer = this.controls.querySelector('.volumeSlider');\n      sliderContainer.classList.add('under');\n    }\n    setupListeners.call(this);\n  }\n}\n"],"names":["styleInject","css","ref","insertAt","document","head","getElementsByTagName","style","createElement","type","firstChild","insertBefore","appendChild","styleSheet","cssText","createTextNode","DISPLAY_BOUNDS","TILE_WIDTH","TILE_HEIGHT","BORDER_WIDTH","BORDER_HEIGHT","PANEL_POSITION","CDGContext","width","height","canvas","this","createCanvas","ctx","createCanvasContext","imageData","createImageData","Array","fill","WIDTH","getContext","mozImageSmoothingEnabled","webkitImageSmoothingEnabled","msImageSmoothingEnabled","imageSmoothingEnabled","hOffset","vOffset","keyColor","backgroundColor","borderColor","memoryColor","pixels","index","r","g","b","clut","map","c","x","y","colorIndex","offset","pixelIndex","data","putImageData","generateImageData","warn","console","CDGInstruction","bytes","slice","constructor","instruction","opcode","byte","toString","padStart","join","CDGNoopInstruction","CDGMemoryPresetInstruction","doff","color","repeat","context","CDGBorderPresetInstruction","left","top","right","bottom","setPixel","CDGTileBlockInstruction","colors","row","column","i","curbyte","j","op","CDGTileBlockXORInstruction","getPixel","CDGScrollPresetInstruction","hScroll","hCmd","vScroll","vCmd","Math","min","buffer","offx","offy","filter","v","CDGScrollCopyInstruction","CDGSetKeyColorInstruction","CDGLoadCLUTLowInstruction","cur","setCLUTEntry","clutOffset","_this7","CDGLoadCLUTHighInstruction","CDGParser","instructionClassByType","InstructionClass","command","createInstruction","instructions","bytesLength","length","push","parseInstruction","now","performance","process","hrtime","Date","requestFrame","callback","requestAnimationFrame","window","setTimeout","CDGPlayer","contextOptions","createContext","afterRender","timestamp","_this","pc","frameId","update","lastSyncPos","pos","lastTimestamp","newPc","floor","SECTORS_PER_SECOND","ffAmt","fastForward","render","options","parser","parseInstructions","reset","renderFrame","execute","executeInstruction","stop","count","max","step","id","cancelAnimationFrame","clearTimeout","ms","Deferred","Promise","defer","PromiseUtils","resolve","reject","promise","bind","Object","freeze","loadZipBuffer","fileBuffer","JSZip","loadAsync","catch","error","Error","getKaraokeFiles","zipFile","entries","relPath","endsWith","processZip","audio","entry","name","video","async","zipEntry","loadVideo","then","jsmediatags","Reader","setTagsToRead","read","onSuccess","tag","onError","parts","split","tags","album","trim","artist","title","getTagData","all","errors","CDGFileLoader","filePath","deferred","JSZipUtils","getBinaryContent","err","getDataFile","FifoSampleBuffer","_vector","Float32Array","_position","_frameCount","clear","receive","rewind","put","numFrames","putSamples","samples","position","sourceOffset","numSamples","ensureCapacity","destOffset","endIndex","vector","set","putBuffer","receiveSamples","output","startIndex","subarray","extract","minLength","parseInt","newVector","ensureAdditionalCapacity","PubSub","fns","any","e","fn","value","prev","concat","forEach","splice","on","method","prop","off","target","pub","observable","Proxy","get","fire","once","has","copyContextToCanvas","clearRect","drawImage","clearCanvas","loadAudio","shifter","decodeAudioData","audioBuffer","PitchShifter","detail","props","timePlayed","formattedTimePlayed","percentagePlayed","player","sync","pitch","trackLength","formattedDuration","load","from","wrapText","text","maxWidth","lineHeight","words","line","n","testLine","measureText","fillText","drawTag","cvs","font","fillStyle","textAlign","loadTag","call","handleExtractedZip","responseArr","_this2","status","loaded","loading","setVolume","val","gainNode","gain","KaraokePlayer","selector","isPlaying","songVolume","destroy","wrapper","querySelector","classList","add","_this3","titleImage","onloaded","remove","AudioContext","webkitAudioContext","createGain","onvolume","disconnect","toLowerCase","loadZipFile","loadFileBuffer","zipResponse","_this4","pause","start","connect","destination","resume","_this5","play","playing","changePlayerPosition","perc","pitchChange","pitchSemitones","tempo","change","newValue","toFixed","fallback","fallbackVolume","htmlToElement","html","template","innerHTML","content","setupListeners","playBtn","removeAttribute","volumeBtn","setAttribute","ontimeplayed","onpercentageplayed","progress","ontracklength","ondestroy","removeListeners","onplay","playIcn","icn","volumeIcn","volumeSlider","contains","addEventListener","togglePlay","event","changePosition","changeKey","changeVolume","removeEventListener","getBoundingClientRect","pageX","offsetWidth","isNaN","fallbackPitch","parseFloat","CDGControls","ctrlTemplate","controls","includes","sliderContainer"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;i6EAAA,SAASA,EAAYC,EAAKC,QACX,IAARA,IAAiBA,EAAM,QACxBC,EAAWD,EAAIC,YAEdF,GAA2B,oBAAbG,cAEfC,EAAOD,SAASC,MAAQD,SAASE,qBAAqB,QAAQ,GAC9DC,EAAQH,SAASI,cAAc,SACnCD,EAAME,KAAO,WAEI,QAAbN,GACEE,EAAKK,WACPL,EAAKM,aAAaJ,EAAOF,EAAKK,YAKhCL,EAAKO,YAAYL,GAGfA,EAAMM,WACRN,EAAMM,WAAWC,QAAUb,EAE3BM,EAAMK,YAAYR,SAASW,eAAed,uVChBvC,IAYMe,EAAiB,CAJFC,EACCC,GAM3BC,IACAC,KAsDWC,EAAiB,CAAC,MAAO,UCjEjBC,uFAwED,OALAC,MAAAA,aDlECN,UCmEDO,OAAAA,aDlEEN,UCmEFO,OAAAA,aAASC,KAAKC,aAAaJ,EAAOC,SAClCI,IAAAA,aAAMF,KAAKG,oBAAoBJ,SAC/BK,UAAAA,aAAYJ,KAAKK,gBAAgBN,EAAQG,EAAKL,EAAOC,gCAlE3D,oBAMA,qBAMC,mCAMW,2BAMR,2BAMA,oBAMN,IAAIQ,MAAM,IAAKC,KAAK,CAAC,EAAG,EAAG,qBAMzB,IAAID,MDlCYE,OCkCWD,KAAK,oBAMhC,IAAID,MDxCYE,OCwCWD,KAAK,SAoBjCR,OAASA,OACTG,IAAMA,OACNE,UAAYA,iDAURP,EAAOC,OACVC,EAASrB,SAASI,cAAc,iBACtCiB,EAAOF,MAAQA,EACfE,EAAOD,OAASA,EACTC,8CASSA,OACVG,EAAMH,EAAOU,WAAW,aAC9BP,EAAIQ,0BAA2B,EAC/BR,EAAIS,6BAA8B,EAClCT,EAAIU,yBAA0B,EAC9BV,EAAIW,uBAAwB,EACrBX,0CAYKH,EAAQG,OAAKL,yDAAQE,EAAOF,MAAOC,yDAASC,EAAOD,cACxDI,EAAIG,gBAAgBR,EAAOC,wCAO7BgB,QAAU,OACVC,QAAU,OACVC,SAAW,UACXC,gBAAkB,UAClBC,YAAc,UACdC,YAAc,UACdC,OAAOb,KAAK,wCAWRc,EAAOC,EAAGC,EAAGC,QACjBC,KAAKJ,GAAS,CAACC,EAAGC,EAAGC,GAAGE,KAAI,SAAAC,UAAS,GAAJA,sCAUjCC,EAAGC,EAAGC,QACNV,OAAOQ,EDxJCrC,ICwJIsC,GAAcC,mCAU1BF,EAAGC,UACD7B,KAAKoB,OAAOQ,EDnKNrC,ICmKWsC,mDAShB,QACkB,MAAjB7B,KAAKgB,gBACChB,KAAKgB,cACa,MAAxBhB,KAAKiB,uBACCjB,KAAKiB,qBACS,MAApBjB,KAAKmB,mBACCnB,KAAKmB,iBACS,MAApBnB,KAAKkB,mBACClB,KAAKkB,2BAEL,uDAWNU,EAD2B,EACjBA,EDjMNrC,ICiMiBqC,QACrB,IAAIC,EAF0B,EAEjBA,EDjMRrC,ICiMoBqC,IAAK,KAEzBE,EAAS,GAAKH,EDpMfrC,ICoMoBsC,GAInBG,GAFOJ,EAAI5B,KAAKc,QDtMjBvB,KAAAA,IAAAA,MCuMQsC,EAAI7B,KAAKe,QDtMhBvB,KAAAA,KCwMAsC,EAAa9B,KAAKoB,OAAOY,OACbhC,KAAKyB,KAAKK,MAArBR,OAAGC,OAAGC,YAERpB,UAAU6B,KAAKF,GAAUT,OACzBlB,UAAU6B,KAAKF,EAAS,GAAKR,OAC7BnB,UAAU6B,KAAKF,EAAS,GAAKP,OAC7BpB,UAAU6B,KAAKF,EAAS,GAAKD,IAAe9B,KAAKgB,SAAW,EAAO,WAGzEhB,KAAKI,qDAOPF,IAAIgC,aAAalC,KAAKmC,oBAAqB,EAAG,YChOpD,SAASC,UACZC,SAAWA,QAAQD,SAAQC,SAAQD,4BC0B1BE,wBAWGC,OAAOR,yDAAS,iBACnBQ,MAAQA,EAAMC,MAAMT,EAAQA,EHYd,yDGnBZ/B,KAAKyC,YAAYC,kDAGjB1C,KAAKyC,YAAYE,mGAUjB3C,KAAKuC,MAAMb,KAAI,SAAAkB,UAAQA,EAAKC,SAAS,IAAIC,SAAS,EAAG,QAAMC,KAAK,oDAIhE,6CAIA/C,KAAK0C,uBA1BPJ,gBACY,MADZA,WAEO,UAkCPU,kBAA2BV,kFAA3BU,gBACY,WADZA,WHnCW,OG8CXC,kBAAmCX,yBAIhCC,SAAOR,yDAAS,gBAElBmB,EAAOnB,EHnCG,uBGkCVQ,EAAOR,IAERoB,MAAsB,GAAdZ,EAAMW,KACdE,OAA2B,GAAlBb,EAAMW,EAAO,+CAGvBG,GACJA,EAAQlC,YAAcnB,KAAKmD,MAC3BE,EAAQpC,gBAAkBjB,KAAKmD,MAC/BE,EAAQjC,OAAOb,KAAKP,KAAKmD,8EAIFnD,KAAKmD,kBAlBvBF,gBACY,mBADZA,WH7CoB,OGyEpBK,kBAAmChB,yBAIhCC,SAAOR,yDAAS,kCAClBQ,EAAOR,IACRoB,MAAmC,GAA3BZ,EAAMR,EH/DH,+CGkEZsB,GACJA,EAAQnC,YAAclB,KAAKmD,MAC3BE,EAAQpC,gBAAkBjB,KAAKmD,kBACI7D,KAA5BiE,OAAMC,OAAKC,OAAOC,OAChB9B,EAAI,EAAGA,EH5GHrC,IG4GcqC,IAAK,KACvB,IAAIC,EAAI,EAAGA,EAAI2B,EAAK3B,IACrBwB,EAAQM,SAAS/B,EAAGC,EAAG7B,KAAKmD,WAE3B,IAAItB,EAAI6B,EAAS,EAAG7B,EH/GfrC,IG+G2BqC,IACjCwB,EAAQM,SAAS/B,EAAGC,EAAG7B,KAAKmD,WAG/B,IAAItB,EAAI2B,EAAK3B,GAAK6B,EAAQ7B,IAAK,KAC3B,IAAID,EAAI,EAAGA,EAAI2B,EAAM3B,IACtByB,EAAQM,SAAS/B,EAAGC,EAAG7B,KAAKmD,WAE3B,IAAIvB,EAAI6B,EAAQ,EAAG7B,EHxHfrC,IGwH0BqC,IAC/ByB,EAAQM,SAAS/B,EAAGC,EAAG7B,KAAKmD,+EAMbnD,KAAKmD,kBAhCvBG,gBACY,mBADZA,WHxEoB,OGkHpBM,kBAAgCtB,yBAI7BC,SAAOR,yDAAS,gBAElBmB,EAAOnB,EHzGG,uBGwGVQ,EAAOR,IAGR8B,OAAS,CAAe,GAAdtB,EAAMW,GAAgC,GAAlBX,EAAMW,EAAO,MAC3CY,IAAwB,GAAlBvB,EAAMW,EAAO,KACnBa,OAA2B,GAAlBxB,EAAMW,EAAO,KACtB9B,OAASmB,EAAMC,MAAMU,EAAO,EAAGA,EAAO,gDAGvCG,OAEEzB,EH/JY,EG+JR5B,KAAK+D,OACTlC,EH/Ja,GG+JT7B,KAAK8D,OAGXlC,EHnKc,EAMLrC,KG6JiBsC,EHlKX,GAMLrC,IG6JV4C,qCAAiCpC,KAAK8D,iBAAQ9D,KAAK+D,sBAIlD,IAAIC,EAAI,EAAGA,EHvKG,GGuKcA,YACvBC,EAAUjE,KAAKoB,OAAO4C,GACnBE,EAAI,EAAGA,EH1KF,EG0KkBA,IAAK,KAC3Bf,EAAQnD,KAAK6D,OAAQI,GAAY,EAAIC,EAAM,QAC5CC,GAAGd,EAASzB,EAAIsC,EAAGrC,EAAImC,EAAGb,+BAKxCE,EAASzB,EAAGC,EAAGsB,GACdE,EAAQM,SAAS/B,EAAGC,EAAGsB,kEAIRnD,KAAK8D,yBAAgB9D,KAAK+D,oCAA2B/D,KAAK6D,OAAOd,KAC5E,sBAxCCa,gBACY,gBADZA,WHjHiB,OGoKjBQ,kBAAmCR,yGAIzCP,EAASzB,EAAGC,EAAGsB,GAEdE,EAAQM,SAAS/B,EAAGC,EAAGwB,EAAQgB,SAASzC,EAAGC,GAAKsB,cAN3CiB,gBACY,sBADZA,WH9JqB,QG8KrBE,kBAAmChC,yBAIhCC,SAAOR,yDAAS,gBAElBmB,EAAOnB,EH5KG,iBG2KVQ,EAAOR,IAERoB,MAAsB,GAAdZ,EAAMW,OAEbqB,EAA4B,GAAlBhC,EAAMW,EAAO,KACxBsB,MAAkB,GAAVD,IAAmB,IAC3BzD,QAAoB,EAAVyD,MAETE,EAA4B,GAAlBlC,EAAMW,EAAO,YACxBwB,MAAkB,GAAVD,IAAmB,IAC3B1D,QAAoB,GAAV0D,8CAIXpB,GACJA,EAAQpC,gBAAkBjB,KAAKmD,MAC/BE,EAAQvC,QAAU6D,KAAKC,IAAI5E,KAAKc,QAASvB,GACzC8D,EAAQtC,QAAU4D,KAAKC,IAAI5E,KAAKe,QAASvB,QAErC+E,EAAU,SACNvE,KAAKwE,WHnMW,EGqMhBD,EH7OU,aAuCK,EGyMfA,GHhPU,MGuPdE,EAAU,SACNzE,KAAKwE,WH9MU,EGgNfC,EHzPW,cAwCE,EGoNbA,GH5PW,MGmQdF,GAAYE,OAIZ,IAAI7C,EAAI,EAAGA,EHlQHrC,IGkQcqC,QAClB,IAAIC,EAAI,EAAGA,EHlQNrC,IGkQkBqC,IACxBwB,EAAQwB,OAAOjD,EHpQVrC,IGoQcsC,GAAa7B,KAAKqE,SAAShB,EAASzB,EAAI2C,EAAS1C,EAAI4C,SAK7C,CAACpB,EAAQwB,OAAQxB,EAAQjC,QAA3DiC,EAAQjC,YAAQiC,EAAQwB,8CAGpBxB,EAASyB,EAAMC,UAChBD,EAAO,GAAKA,EH7QHvF,KG6QmBwF,EAAO,GAAKA,EH5Q9BvF,IG6QH6D,EAAQjC,OAAO0D,EH9QbvF,IG8QoBwF,GAE1B/E,KAAKmD,oDAIRsB,GAAU,EACVF,GAAU,SHlPO,IGmPjBvE,KAAK0E,KACLD,EAAU,KHnPS,IGoPZzE,KAAK0E,OACZD,EAAU,QHxPS,IG0PnBzE,KAAK0E,KACLH,EAAU,OH1PU,IG2PbvE,KAAK0E,OACZH,EAAU,SAEP,CAACE,EAASF,qBAAqBvE,KAAKe,4BAAuBf,KAAKc,UAClEkE,QAAO,SAAAC,UAAKA,KACZlC,KAAK,gBAtFLuB,gBACY,mBADZA,WHnLoB,QGmRpBY,kBAAiCZ,+GAIjCjB,EAASyB,EAAMC,UACpBD,GAAQA,EHjTKvF,KAAAA,IGkTbwF,GAAQA,EHjTMvF,KAAAA,IGkTP6D,EAAQjC,OAAO0D,EHnTTvF,IGmTgBwF,cAPxBG,gBACY,iBADZA,WHlRkB,QGmSlBC,kBAAkC7C,yBAI/BC,SAAOR,yDAAS,kCAClBQ,EAAOR,IACRoB,MAAmC,GAA3BZ,EAAMR,EH7RH,+CGgSZsB,GACJA,EAAQrC,SAAWhB,KAAKmD,6EAIDnD,KAAKmD,kBAdvBgC,gBACY,mBADZA,WHlSoB,QG0TpBC,kBAAkC9C,yBAQ/BC,SAAOR,yDAAS,gBAElBmB,EAAOnB,EHzTG,iBGwTVQ,EAAOR,IAER8B,OAAS,OACT,IAAIG,EAAI,EAAGA,EAAI,EAAGA,IAAK,KAClBqB,EAAMnC,EAAO,EAAIc,EACjBb,IAAuB,GAAbZ,EAAM8C,KAAgB,IAAuB,GAAjB9C,EAAM8C,EAAM,MAEnDxB,OAAOG,GAAK,CACbb,GAAS,GACA,IAARA,IAAiB,EACV,GAARA,gEAdD,yCAmBHE,OACC,IAAIW,EAAI,EAAGA,EAAI,EAAGA,IACnBX,EAAQiC,aACJtB,EAAIhE,KAAKuF,WACTvF,KAAK6D,OAAOG,GAAG,GACfhE,KAAK6D,OAAOG,GAAG,GACfhE,KAAK6D,OAAOG,GAAG,kFAMJhE,KAAK6D,OACnBnC,KACG,SAACyB,EAAOa,mBAASA,EAAIwB,EAAKD,yBAAgBpC,EAAMzB,KAAI,SAAAC,UAAKA,EAAEkB,SAAS,OAAKE,KAAK,QAEjFA,KAAK,sBAxCLqC,gBACY,qBADZA,WHzToB,QG2WpBK,kBAAmCL,wHAKjC,aALFK,gBACY,sBADZA,WH1WmB,QILXC,oEAoBQ1F,KAAKyC,YAAYkD,8EAQtBhD,EAAQiD,QACnBD,uBAAuBhD,GAAUiD,4CAWxBjD,EAAQJ,OAAOR,yDAAS,EAChCY,KAAU3C,KAAK2F,wBACjBvD,mDAA+CO,YAE7CiD,EAAmB5F,KAAK2F,uBAAuBhD,IAAWK,SACzD,IAAI4C,EAAiBrD,EAAOR,4CAUtBQ,OAAOR,yDAAS,EACvB8D,EJxCc,GIwCJtD,EAAMR,MJvCH,IIwCf8D,EAAyB,KACnBlD,EJ1CU,GI0CDJ,EAAMR,EAAS,UACvB/B,KAAK8F,kBAAkBnD,EAAQJ,EAAOR,UAE1C,IAAIiB,EAAmBT,EAAOR,6CASvBQ,WACRwD,EAAe,GACfC,EAAczD,EAAM0D,OACjBlE,EAAS,EAAGA,EAASiE,EAAajE,GJrDxB,GIsDfgE,EAAaG,KAAKlG,KAAKmG,iBAAiB5D,EAAOR,WAE5CgE,EAAaf,QAAO,SAAAtC,UAAeA,0EJ/E1B,EIMAM,OJLS,EIMAC,OJLA,EIMAK,OJLH,EIMAM,OJLG,GIMAU,OJLF,GIMAY,OJLE,GIMAC,OJLA,GIMAC,OJLD,GIMAK,OJLE,GIMArB,cCpClC,SAASgC,OACsB,oBAAhBC,aAA0D,mBAApBA,YAAYD,WAClDC,YAAYD,MAChB,GAAuB,oBAAZE,SAAqD,mBAAnBA,QAAQC,OAAuB,SAC/CD,QAAQC,mBACtB,cAAwB,WAEvCC,KAAKJ,MAGhB,SAASK,EAAaC,SACmB,mBAA1BC,sBACAC,OAAOD,sBAAsBD,GAEjCG,WAAWH,EAAU,QAgBXI,8FAsFD,OAHAC,eAAAA,aAAiB,SACjB1D,QAAAA,aAAUrD,KAAKgH,cAAcD,KAC7BE,IAAAA,4CAhFD,iBAMT,oBAMI,mBAMJ,wBAMQ,6BAME,uBAQP,eAACC,yDAAYd,QAED,IAAbe,EAAKC,UACED,EAIXA,EAAKE,QAAUZ,EAAaU,EAAKG,QAE7BH,EAAKI,YAELJ,EAAKK,IAAML,EAAKI,aAAeL,EAAYC,EAAKM,gBAGhDN,EAAKK,KAAON,EAAYC,EAAKM,cAC7BN,EAAKM,cAAgBP,OAKnBQ,EAAQ/C,KAAKgD,MAAiDR,EAAKK,IAAM,IAAtDI,KAEnBC,EAAQH,EAAQP,EAAKC,UACvBS,EAAQ,IACRV,EAAKW,YAAYD,GACjBV,EAAKY,UAGFZ,UAgBF9D,QAAUA,OACV4D,YAAcA,wDASTe,yDAAU,UACb,IAAIpI,EAAWoI,gCASrB/F,OACKgG,EAAS,IAAIvC,cACdK,aAAekC,EAAOC,kBAAkBjG,QACxCkG,QACEnI,iDASFoH,GAAK,OACLI,IAAM,OACND,YAAc,UACdlE,QAAQ8E,QACNnI,kDAQFqD,QAAQ+E,mBACRnB,aAAejH,KAAKiH,YAAYjH,KAAKqD,SACnCrD,gDASQ0C,UACXA,GAA8C,mBAAxBA,EAAY2F,SAClC3F,EAAY2F,QAAQrI,KAAKqD,SAEtBrD,2CASHA,KAAKoH,IAAM,GAAKpH,KAAKoH,GAAKpH,KAAK+F,aAAaE,aACvCqC,mBAAmBtI,KAAK+F,aAAa/F,KAAKoH,UAC1CA,IAAM,SAENA,IAAM,OACNmB,QAEFvI,mDASCwI,yDAAQ,EACVC,EAAMzI,KAAKoH,GAAKoB,EACfxI,KAAKoH,IAAM,GAAKpH,KAAKoH,GAAKqB,QACxBC,cAEF1I,2CASFA,KAAKqH,eACDA,QAAUZ,EAAazG,KAAKsH,aAC5BG,cAAgBrB,KAElBpG,oCA3Mf,IAAqB2I,SAAAA,EAoND3I,KAAKqH,QAnNe,mBAAzBuB,qBACAA,qBAAqBD,GAEzBE,aAAaF,QAiNXtB,QAAU,UACVE,YAAc,KACZvH,kCAWN8I,eACIvB,YAAcuB,OACdrB,cAAgBrB,IACdpG,cCvPT+I,EAAW,iBAEW,oBAAbC,SAA4BA,QAAQC,MAEpCD,QAAQC,QACiB,oBAAlBC,cAAkCA,aAAaD,MAEtDC,aAAaD,cASfE,QAAU,UASVC,OAAS,UAKTC,QAAU,IAAIL,QAAQ,SAASG,EAASC,QACpCD,QAAUA,OACVC,OAASA,GAChBE,KAAKtJ,YACPuJ,OAAOC,OAAOxJ,QC5BhByJ,EAAgB,SAASC,UACtBC,MAAMC,UAAUF,GAAYG,OAAM,SAAAC,UACvCd,QAAQI,OAAO,IAAIW,iDAAkDD,QA2CnEE,EAAkB,SAASC,OACzBC,EAAUD,EAAQjF,QAAO,SAAAmF,UAAWA,EAAQC,SAAS,SAAWD,EAAQC,SAAS,kBAChE,IAAnBF,EAAQjE,OACH+C,QAAQG,QAAQe,GAElBlB,QAAQI,+CAGXiB,EAAa,SAASH,OACpBI,EAAQJ,EAAQlF,QAAO,SAAAuF,UAASA,EAAMC,KAAKJ,SAAS,WACpDK,EAAQP,EAAQlF,QAAO,SAAAuF,UAASA,EAAMC,KAAKJ,SAAS,WACpD9D,EAAU,MACZgE,EAAMrE,QAAUwE,EAAMxE,cACxBK,EAAQJ,KAAeoE,EAAM,GAlD5BI,MAAM,eACNb,OAAM,kBAAMb,QAAQI,OAAO,IAAIW,4CAkDhCzD,EAAQJ,KApBM,SAASyE,UAClBA,EACJD,MAAM,cACNb,OAAM,kBAAMb,QAAQI,OAAO,IAAIW,2CAiBnBa,CAAUH,EAAM,KAC7BnE,EAAQJ,KAtCO,SAASyE,UACnBA,EACJD,MAAM,QACNG,MACC,SAAAhG,UACE,IAAImE,SAAQ,SAAAG,OACN2B,YAAYC,OAAOlG,GACpBmG,cAAc,CAAC,QAAS,SAAU,QAAS,QAAS,OAAQ,QAAS,YACrEC,KAAK,CACJC,UAAW,SAAAC,UAAOhC,EAAQgC,IAC1BC,QAAS,kBAAMjC,GApBOqB,EAoBoBG,EAASH,KAnBzDa,EAAQb,EAAKc,MAAM,QACnBH,EAAM,CAAEI,KAAM,KAEhBA,KAAKC,MAAQH,EAAM,GAAGI,OAC1BN,EAAII,KAAKG,OAASL,EAAM,GAAKA,EAAM,GAAGI,OAASN,EAAII,KAAKC,MACxDL,EAAII,KAAKI,MAAQN,EAAM,GAAKA,EAAM,GAAGI,OAASN,EAAII,KAAKG,OAChDP,IAPkB,IAASX,EAC5Ba,EACAF,WAsBHtB,OAAM,kBAAMb,QAAQI,OAAO,IAAIW,MAAM,gCAwBzB6B,CAAWtB,EAAM,KACvBtB,QAAQ6C,IAAIvF,GAASuD,OAAM,kBAChCb,QAAQI,OAAO,IAAIW,mDAGjB+B,EAAS,UACVxB,EAAMrE,QACT6F,EAAO5F,KAAK,8BAETuE,EAAMxE,QACT6F,EAAO5F,KAAK,8BAEP8C,QAAQI,OAAO,IAAIW,MAAM+B,EAAO/I,KAAK,QAGzBgJ,uFACAC,UAxFD,SAASA,OACrBC,EAAW,IAAIlD,SACrBmD,WAAWC,iBAAiBH,GAAU,SAACI,EAAKnK,GACtCmK,EACFH,EAAS7C,OAAO,IAAIW,8CAAuCiC,GAAYI,IAGzEH,EAAS9C,QAAQlH,MAEZgK,EAAS5C,QAgFPgD,CAAYL,GAChBnB,MAAK,SAAAnB,UAAcD,EAAcC,MACjCmB,MAAK,SAAAZ,UAAWD,EAAgBC,MAChCY,MAAK,SAAAX,UAAWG,EAAWH,MAC3BL,OAAM,SAAAC,UAASd,QAAQI,OAAOU,6CAGbJ,UACbD,EAAcC,GAClBmB,MAAK,SAAAZ,UAAWD,EAAgBC,MAChCY,MAAK,SAAAX,UAAWG,EAAWH,MAC3BL,OAAM,SAAAuC,UAAOpD,QAAQI,OAAOgD,eCpFpB,MAAAE,EACb7J,mBACE8J,QAAe,IAAfC,kBACAC,UAAA,OACAC,YAAA,sBAIO1M,KAAPuM,8BAIOvM,KAAPyM,kCAIA,EAAOzM,KAAAyM,kCAIAzM,KAAP0M,kCAIA,GAAQ1M,KAAAyM,UAAiBzM,KAAlB0M,aAGTC,aACEC,QAAa5M,KAAb0M,kBACAG,SAGFC,IAAGC,QACDL,aAAAK,EAGFC,WAAUC,EAAAC,EAAoBH,EAApB,SAEFI,EAAN,GADAD,EAAWA,GAAXA,GAEMH,GAAN,IACEA,GAAaE,EAAAA,OAADE,GAAZJ,SAEIK,EAAN,EAAmBL,OAEnBM,eAAoBN,EAAY/M,KAAhC0M,mBAEMY,EAAatN,KAAnBuN,cACAC,OAAAC,IACER,EAAAA,SAAAA,EAA+BE,EADjCC,GAAAE,QAKAZ,aAAAK,EAGFW,UAAS7I,EAAAqI,EAAmBH,EAAnB,GACPG,EAAWA,GAAXA,EACMH,GAAN,IACEA,EAAYlI,EAAAA,WAAZkI,QAEFC,WAAgBnI,EAAhB2I,OAA+B3I,EAAAA,SAA/BqI,EAAAH,GAGFH,QAAOG,GACCA,GAAF,KAAqBA,EAAY/M,KAArC0M,eACEK,EAAY/M,KAAZ+M,iBAEFL,aAAAK,OACAN,WAAAM,EAGFY,eAAcC,EAASb,EAAT,SACNK,EAAN,EAAmBL,EACbI,EAAenN,KAArB6N,WACAD,EAAAA,IAAW5N,KAAAuM,QAAAuB,SAAAX,EAAoCA,EAA/CS,SACAhB,QAAAG,GAGFgB,QAAOH,EAASV,EAAT,EAAuBH,EAAvB,SACCI,EAAenN,KAAA6N,WAArB,EAAuCX,EACjCE,EAAN,EAAmBL,EACnBa,EAAAA,IAAW5N,KAAAuM,QAAAuB,SAAAX,EAAoCA,EAA/CS,IAGFP,eAAeN,EAAD,SACNiB,EAAYC,SAAlB,EAA2BlB,MACvB/M,KAAAuM,QAAAtG,OAAJ+H,EAAqC,OAC7BE,EAAY,IAAA1B,aAAlBwB,GACAE,EAAAA,IAAclO,KAAAuM,QAAAuB,SAAsB9N,KAAtB6N,WAAuC7N,KAArDkO,gBACA3B,QAAA2B,OACAzB,UAAA,YAEAI,SAIJsB,yBAAyBpB,EAAD,QACtBM,eAAoBrN,KAAA0M,YAApBK,GAGFF,SACM7M,KAAAyM,UAAJ,SACEF,QAAAkB,IAAiBzN,KAAAuM,QAAAuB,SAAsB9N,KAAtB6N,WAAuC7N,KAAxDuN,gBACAd,UAAA,qsXC7HC,ICEM2B,yCAKAC,IAAM,CAAEC,IAAK,0CASlBC,UACQA,KAAKvO,KAAKqO,KAAOrO,KAAKqO,IAAIE,GAAGtI,OAAS,GAAMjG,KAAKqO,IAAIC,IAAIrI,OAAS,6BAU3EsI,EAAGC,UACED,KAAKvO,KAAKqO,MAAQ,SACbA,IAAIE,GAAK,SAEbF,IAAIE,GAAGrI,KAAKsI,GACVA,+BAWND,EAAGE,EAAOC,eACNL,IAAIC,IAAIK,OAAOJ,KAAKvO,KAAKqO,IAAMrO,KAAKqO,IAAIE,GAAK,IAAIK,SAAQ,SAAAJ,UAAMA,EAAGC,EAAOC,EAAMH,MAC7EvO,iCASPwO,OACK,IAAMD,KAAKvO,KAAKqO,YACXA,EAAMrO,KAAKqO,IAAIE,GACZvK,EAAI,EAAGA,EAAIqK,EAAIpI,OAAQjC,OACxBqK,EAAIrK,KAAOwK,SACXH,EAAIQ,OAAO7K,EAAG,IACP,SAIZ,+BAUNuK,EAAGC,0BAKCM,GAAGP,GAJO,SAATQ,EAAUN,EAAOC,EAAMM,GACzBR,EAAGC,EAAOC,EAAMM,GAChB7H,EAAK8H,IAAIF,MAGNP,sBCtEAU,MACPA,EAAOJ,IAAMI,EAAOD,WACbC,MAELC,EAAM,IAAIf,EACVgB,EAAa,IAAIC,MAAMH,EAAQ,CACjCI,IAAK,SAACJ,EAAQF,MACNA,KAAQE,EAAQ,IACZA,EAAOzM,cAAgBnC,MAAO,KAC1B2E,EAAImK,EACK,QAATJ,EACA/J,EAAIiK,EAAOA,EAAOjJ,OAAS,GACX,UAAT+I,IACP/J,EAAIiK,EAAO,IAEF,SAATF,GAA4B,WAATA,GACnBG,EAAII,KAAKP,EAAM/J,UAGhBiK,EAAOF,GACX,MAAa,OAATA,EACAG,EAAIL,GAAGxF,KAAK6F,GACH,SAATH,EACAG,EAAIK,KAAKlG,KAAK6F,GACL,QAATH,EACAG,EAAIF,IAAI3F,KAAK6F,QADjB,GAKX1B,IAAK,SAACyB,EAAQF,EAAM/J,UACZiK,EAAOzM,cAAgBnC,MACV,WAAT0O,GACAG,EAAII,KAAK,SAAUtK,GAEhBkK,EAAIM,IAAIT,IACfG,EAAII,KAAKP,EAAM/J,EAAGiK,EAAOF,IAE7BE,EAAOF,GAAQ/J,GACR,YAIRmK,GCnBLM,EAAsB,SAASrM,GAE/BA,EAAQrC,UAAY,QACjBd,IAAIyP,UAAU,EAAG,EAAG3P,KAAKD,OAAOF,MAAOG,KAAKD,OAAOD,aAGrDI,IAAI0P,UACPvM,EAAQtD,OACR,EACA,EACAsD,EAAQtD,OAAOF,MACfwD,EAAQtD,OAAOD,OACf,EACA,EACAE,KAAKD,OAAOF,MACZG,KAAKD,OAAOD,SAIV+P,EAAc,SAASxM,EAAStD,GACpCsD,EAAQsM,UAAU,EAAG,EAAG5P,EAAOF,MAAOE,EAAOD,SAGzCgQ,EAAY,SAASjL,qBACrB7E,KAAK+P,cACFA,QAAQd,MAERjP,KAAKsK,MACT0F,gBAAgBnL,GAChBgG,MAAK,SAAAoF,GACJ9I,EAAK4I,QAAUX,EACb,IAAIc,EAAa/I,EAAKmD,MAAO2F,EAAa,MAAM,WAC9C9I,EAAKoB,WAGTpB,EAAK4I,QAAQjB,GAAG,QAAQ,SAAAqB,GACtBhJ,EAAKiJ,MAAMC,WAAaF,EAAOG,oBAC/BnJ,EAAKiJ,MAAMG,iBAAmBJ,EAAOI,iBACrCpJ,EAAKqJ,OAAOC,KAAyB,IAApBN,EAAOE,WZAM,QYEhClJ,EAAK4I,QAAQW,MZTU,EYUvBvJ,EAAKiJ,MAAMO,YAAcxJ,EAAK4I,QAAQa,qBAEvC/G,OAAM,SAAAC,UAASd,QAAQI,OAAO,IAAIW,mDAAoDD,QAGrFc,GAAY,SAAS/F,OACnBoH,EAAW,IAAIlD,SACjBlE,QACG2L,OAAOK,KAAKvQ,MAAMwQ,KAAKjM,IAC5BoH,EAAS9C,WAET8C,EAAS7C,OAAO,IAAIW,MAAM,8CAErBkC,EAAS5C,SAGZ0H,GAAW,SAAS1N,EAAS2N,EAAMpP,EAAGC,EAAGoP,EAAUC,WACnDC,EAAQH,EAAK1F,MAAM,KACnB8F,EAAO,GAEFC,EAAI,EAAGA,EAAIF,EAAMlL,OAAQoL,IAAK,KACjCC,EAAWF,EAAOD,EAAME,GAAK,IACnBhO,EAAQkO,YAAYD,GACVzR,MACRoR,GAAYI,EAAI,GAC9BhO,EAAQmO,SAASJ,EAAK3F,OAAQ7J,EAAGC,GACjCuP,EAAOD,EAAME,GAAK,IAClBxP,GAAKqP,GAELE,EAAOE,EAGXjO,EAAQmO,SAASJ,EAAK3F,OAAQ7J,EAAGC,IAG7B4P,GAAU,eACRvR,EAAMF,KAAKE,IACXwR,EAAM1R,KAAKD,OACXkR,EAAWS,EAAI7R,MAAQ,GAEvB+B,EAAIqP,EAAW,EACjBpP,EAAI,GACR3B,EAAIyR,KAAO,kBACXzR,EAAI0R,UAAY,OAChB1R,EAAI2R,UAAY,SAChBd,GAAS7Q,EAAKF,KAAKmL,IAAIQ,MAAO/J,EAAGC,EAAGoP,EANnB,IAOjB/Q,EAAIyR,KAAO,kBACX9P,EAAI6P,EAAI5R,OAAS,GACjBiR,GAAS7Q,eAAWF,KAAKmL,IAAIO,QAAU9J,EAAGC,EAAGoP,EAT5B,KAYba,GAAU,SAAS3G,WAClBA,IAAMA,GAAOA,EAAII,KAClBvL,KAAKmL,WACAsG,GAAQM,KAAK/R,OAIlBgS,GAAqB,SAASC,cAC5B3L,EAAU,UAChBA,EAAQJ,KAAK4J,EAAUiC,KAAK/R,KAAMiS,EAAY,KAC9C3L,EAAQJ,KAAK0E,GAAUmH,KAAK/R,KAAMiS,EAAY,KACvCjJ,QAAQ6C,IAAIvF,GAChBuE,MAAK,WACJqH,EAAK9B,MAAM+B,OAAS,cACpBD,EAAK9B,MAAMgC,QAAS,EAEpBN,GAAQC,KAAKG,EAAMD,EAAY,OAEhCpI,OAAM,SAAAC,UACLoI,EAAK9B,MAAM+B,OAAS,sBACbnJ,QAAQI,OAAOU,MAEvBe,MAAK,WACJqH,EAAK9B,MAAMiC,SAAU,MAIrBC,GAAY,SAASC,QACpBC,SAASC,KAAKhE,MAAQ8D,GAGhBG,yBAuBCC,OAlKuB9S,EAAOC,EACpCC,qCA2IE,wBACG,uBACD,uBAEA,sBACD,2BZ5FkB,mBY8FlB,mBACH,qBAEEqP,EAAW,CACjB+C,OAAQ,GACRC,QAAQ,EACRC,SAAS,EACTO,WAAW,EACXvC,WZpGsB,OYqGtBM,YZrGsB,OYsGtBJ,iBAAkB,EAClBsC,WAAY,EACZC,SAAS,UAIJC,QAAUrU,SAASsU,cAAcL,IACjC3S,KAAK+S,cACF,IAAIhJ,+DAAwD4I,sBAE/DI,QAAQE,UAAUC,IAAI,0BACtBnT,QAxK4BF,EZJhBN,IYIuBO,EZHtBN,KYIdO,EAASrB,SAASI,cAAc,WAC/Be,MAAQA,EACfE,EAAOD,OAASA,EACTC,QAqKAA,OAAOkT,UAAUC,IAAI,yBACrBhT,IAnKmB,SAASH,OAC7BG,EAAMH,EAAOU,WAAW,aAC9BP,EAAIS,6BAA8B,EAClCT,EAAIQ,0BAA2B,EAC/BR,EAAIU,yBAA0B,EAC9BV,EAAIW,uBAAwB,EACrBX,EA6JMC,CAAoBH,KAAKD,aAC/ByQ,OAAS,IAAI1J,EAAU,CAC1BG,YAAa,SAAA5D,UAAWqM,EAAoBqC,KAAKoB,EAAM9P,WAEpD0P,QAAQ7T,YAAYc,KAAKD,YACxBqT,EAAa1U,SAASI,cAAc,OAC1CsU,EAAWH,UAAUC,IAAI,mBACpBH,QAAQ7T,YAAYkU,QACpBC,SAAWrT,KAAKoQ,MAAMtB,GAAG,UAAU,SAAAyD,GAClCA,EACFa,EAAWH,UAAUC,IAAI,QAG3BE,EAAWH,UAAUK,OAAO,gBAGzBhJ,MAAQ,IAAK1D,OAAO2M,cAAgB3M,OAAO4M,yBAC3ChB,SAAWxS,KAAKsK,MAAMmJ,kBACtBC,SAAW1T,KAAKoQ,MAAMtB,GAAG,cAAc,SAAAyD,GAC1CD,GAAUP,KAAKoB,EAAMZ,WAElBnC,MAAMyC,WZjJa,mDYqJnBE,QAAQE,UAAUK,OAAO,0BACzB/K,YACAiK,SAASmB,aACV3T,KAAK+P,cACFA,QAAQd,WAEVc,QAAU,UACVyC,SAAW,UACXlI,MAAQ,UACRvK,OAAOuT,cACPlD,MAAM0C,SAAU,OAChB1C,MAAMnB,IAAI,yCAGZjD,OAIC3C,iBAHCd,OACLsH,EAAY7P,KAAKE,IAAKF,KAAKD,aACtBqQ,MAAMiC,SAAU,EHpOG,iBGsOXrG,EAAW,KACjBA,EAAS4H,cAAcxJ,SAAS,oBAC9BgG,MAAMiC,SAAU,OAChBjC,MAAM+B,iBAAYnG,2CAEhBhD,QAAQI,OAAOpJ,KAAKoQ,MAAM+B,aAE9B/B,MAAM+B,OAAS,qBACpB9I,EAAU0C,EAAc8H,YAAY7H,aAE/BoE,MAAM+B,yBACX9I,EAAU0C,EAAc+H,eAAe9H,UAElC3C,EACJwB,MAAK,SAAAkJ,UAAe/B,GAAmBD,KAAKiC,EAAMD,MAClDlK,OAAM,SAAAC,UAASd,QAAQI,OAAOU,2CAI7B9J,KAAKoQ,MAAMwC,eACRqB,aAEAC,mDAKPrE,EAAYkC,KAAK/R,KAAMA,KAAKE,IAAKF,KAAKD,aACjCgQ,QAAQoE,QAAQnU,KAAKwS,eACrBA,SAAS2B,QAAQnU,KAAKsK,MAAM8J,kBAE5B9J,MAAM+J,SAASxJ,MAAK,WACvByJ,EAAKlE,MAAMwC,WAAY,EACvB0B,EAAK9D,OAAO+D,8CAIVC,+DACCpE,MAAMwC,UAAY4B,OAClBzE,QAAQ4D,kBAKRnD,OAAOjI,sCAIRvI,KAAK+P,eACFkE,aACAQ,qBAAqB,GAC1BhD,GAAQM,KAAK/R,oDAII0U,GACnBA,EAAOA,EAAO,EAAI,EAAIA,EAAO,IAAM,IAAMA,OACpC3E,QAAQQ,iBAAmBmE,OAC3BtE,MAAMG,iBAAmBvQ,KAAK+P,QAAQQ,sBACtCH,MAAMC,WAAarQ,KAAK+P,QAAQO,yBAChCE,OAAOrI,QACPuM,SACEtE,MAAMwC,WAAY,OAClBxC,MAAMC,WZ9NS,0CYkOdsE,GACRA,EAAcA,GAAe,GAAK,EAAIA,EAAc,EAAI,EAAIA,OACvD5E,QAAQ6E,eAAiBD,OACzB5E,QAAQ8E,MAAQ,iCAGhBC,OAECC,IADU/U,KAAKwS,SAASC,KAAKhE,MACNqG,GAAQE,QAAQ,QACxC5E,MAAMyC,WAAakC,EAAW,EAAI,EAAIA,EAAW,EAAI,EAAIA,2CAIxDE,EAAWjV,KAAKwS,SAASC,KAAKhE,WAC/B2B,MAAMyC,WAAaoC,EAAW,EAAIjV,KAAKkV,oBACvCA,eAAiBD,+rSCrT1B,IAGME,GAAgB,SAASC,OACzBC,EAAW3W,SAASI,cAAc,mBACtCsW,EAAOA,EAAK3J,OACZ4J,EAASC,UAAYF,EACdC,EAASE,QAAQvW,YAGpBwW,GAAiB,sBACfpF,EAAQpQ,KAAKwQ,OAAOJ,WACrBiD,SAAWjD,EAAMtB,GAAG,UAAU,SAAAyD,GAC7BA,GACFpL,EAAKsO,QAAQC,gBAAgB,YAC7BvO,EAAKuJ,MAAMgF,gBAAgB,YAC3BvO,EAAKwO,UAAUD,gBAAgB,cAE/BvO,EAAKsO,QAAQG,aAAa,WAAY,YACtCzO,EAAKuJ,MAAMkF,aAAa,WAAY,YACpCzO,EAAKwO,UAAUC,aAAa,WAAY,qBAGvCC,aAAezF,EAAMtB,GAAG,cAAc,SAACyD,EAAK7D,GAC3C6D,IAAQ7D,IACVvH,EAAKkJ,WAAWiF,UAAY/C,WAG3BuD,mBAAqB1F,EAAMtB,GAAG,oBAAoB,SAACyD,EAAK7D,GACvD6D,IAAQ7D,IACVvH,EAAK4O,SAAStH,MAAQ8D,WAGrByD,cAAgB5F,EAAMtB,GAAG,eAAe,SAACyD,EAAK7D,GAC7C6D,IAAQ7D,IACVvH,EAAKwJ,YAAY2E,UAAY/C,WAG5B0D,UAAY7F,EAAMtB,GAAG,WAAW,SAAAyD,GAC/BA,GACF2D,GAAgBnE,KAAK5K,WAGpBgP,OAAS/F,EAAMtB,GAAG,aAAa,SAAAyD,GAClCpL,EAAKiP,QAAQnD,UAAUK,OA5CV,qBACC,iBA4CdnM,EAAKiP,QAAQnD,UAAUC,IAAIX,EA5Cb,gBADD,8BAgDVmB,SAAWtD,EAAMtB,GAAG,cAAc,SAAAyD,OAC/B8D,EAAMlP,EAAKmP,aACjBnP,EAAKoP,aAAa9H,MAAQ8D,EACtBA,SACE8D,EAAIpD,UAAUuD,SAAS,aACzBH,EAAIpD,UAAUK,OAAO,eAKzB+C,EAAIpD,UAAUC,IAAI,gBAGfuC,QAAQgB,iBAAiB,SAAS,kBAAMtP,EAAKqJ,OAAOkG,qBACpDX,SAASU,iBAAiB,SAAS,SAAAE,UAASC,GAAe7E,KAAK5K,EAAMwP,WACtEjG,MAAM+F,iBAAiB,UAAU,kBAAMI,GAAU9E,KAAK5K,WACtDoP,aAAaE,iBAAiB,UAAU,kBAAMK,GAAa/E,KAAK5K,OAGjE+O,GAAkB,sBAChB9F,EAAQpQ,KAAKwQ,OAAOJ,MAC1BA,EAAMnB,IAAIjP,KAAKqT,UACfjD,EAAMnB,IAAIjP,KAAK6V,cACfzF,EAAMnB,IAAIjP,KAAK8V,oBACf1F,EAAMnB,IAAIjP,KAAKgW,eACf5F,EAAMnB,IAAIjP,KAAKiW,WACf7F,EAAMnB,IAAIjP,KAAKmW,QACf/F,EAAMnB,IAAIjP,KAAK0T,eACV+B,QAAQsB,oBAAoB,SAAS,kBAAM7E,EAAK1B,OAAOkG,qBACvDX,SAASgB,oBAAoB,SAAS,SAAAJ,UAASC,GAAe7E,KAAKG,EAAMyE,WACzEjG,MAAMqG,oBAAoB,UAAU,kBAAMF,GAAU9E,KAAKG,WACzDqE,aAAaQ,oBAAoB,UAAU,kBAAMD,GAAa/E,KAAKG,OAGpE0E,GAAiB,SAASD,OACxBnP,EAAMmP,EAAMzH,OAAO8H,wBAEnBtC,GADOiC,EAAMM,MAAQzP,EAAI5F,GACX+U,EAAMzH,OAAOgI,iBAC5B1G,OAAOiE,qBAAqBC,IAG7BmC,GAAY,eACVtE,EAAMvS,KAAK0Q,MAAMjC,MACnB0I,MAAM5E,QACH7B,MAAMjC,MAAQzO,KAAKoX,oBAGrBA,cAAgB7E,GAAO,GAAK,EAAIA,EAAM,EAAI,EAAIA,OAC9C/B,OAAOqG,UAAU7W,KAAKoX,iBAGvBN,GAAe,gBACdtG,OAAOJ,MAAMyC,aAAewE,WAAWrX,KAAKuW,aAAa9H,OAAS,GAAGuG,QAAQ,IAG/DsC,GAWnB,WAAY3E,EAAUnC,OAAQxI,yDAAU,CAAEkF,SAAU,sCAVzCiI,GAAcoC,qBAChB,uBAEC,uBACA,0BACG,wBACF,2BACG,qBACN,UAGAxE,EAAUrU,SAASsU,cAAcL,GACvCI,EAAQ7T,YAAYc,KAAKwX,eACpBhH,OAASA,MACRJ,EAAQpQ,KAAKwQ,OAAOJ,cACrBqF,QAAUzV,KAAKwX,SAASxE,cAAc,oBACtCoD,QAAUpW,KAAKyV,QAAQzC,cAAc,UACrC3C,WAAarQ,KAAKwX,SAASxE,cAAc,oBACzC3C,WAAWiF,UAAYlF,EAAMC,gBAC7B0F,SAAW/V,KAAKwX,SAASxE,cAAc,uBACvC+C,SAAStH,MAAQ2B,EAAMG,sBACvBI,YAAc3Q,KAAKwX,SAASxE,cAAc,qBAC1CrC,YAAY2E,UAAYlF,EAAMO,iBAC9BD,MAAQ1Q,KAAKwX,SAASxE,cAAc,eACpCoE,cAAgB,GAChBzX,EAAe8X,SAASzP,EAAQkF,gBAC7B,IAAInD,kEAEP4L,UAAY3V,KAAKwX,SAASxE,cAAc,4BACxCsD,UAAYtW,KAAK2V,UAAU3C,cAAc,UACzCuD,aAAevW,KAAKwX,SAASxE,cAAc,qBAC3CuD,aAAa9H,MAAQ2B,EAAMyC,WACP,QAArB7K,EAAQkF,SAAoB,KACxBwK,EAAkB1X,KAAKwX,SAASxE,cAAc,iBACpD0E,EAAgBzE,UAAUC,IAAI,SAEhCsC,GAAezD,KAAK/R"}