{"version":3,"file":"cdgplayer.js","sources":["../node_modules/style-inject/dist/style-inject.es.js","../src/cdg/constants.js","../src/cdg/CDGContext.js","../src/cdg/logger.js","../src/cdg/CDGInstruction.js","../src/cdg/CDGParser.js","../src/cdg/CDGPlayer.js","../src/utilities/deferred.js","../src/loader/CDGFileLoader.js","../node_modules/soundtouchjs/dist/soundtouch.js","../src/observable/pubsub.js","../src/observable/observable.js","../src/player/KaraokePlayer.js","../src/utilities/is.js","../src/controls/CDGControls.js"],"sourcesContent":["function styleInject(css, ref) {\n  if ( ref === void 0 ) ref = {};\n  var insertAt = ref.insertAt;\n\n  if (!css || typeof document === 'undefined') { return; }\n\n  var head = document.head || document.getElementsByTagName('head')[0];\n  var style = document.createElement('style');\n  style.type = 'text/css';\n\n  if (insertAt === 'top') {\n    if (head.firstChild) {\n      head.insertBefore(style, head.firstChild);\n    } else {\n      head.appendChild(style);\n    }\n  } else {\n    head.appendChild(style);\n  }\n\n  if (style.styleSheet) {\n    style.styleSheet.cssText = css;\n  } else {\n    style.appendChild(document.createTextNode(css));\n  }\n}\n\nexport default styleInject;\n","/**\n * CDG Context Constants\n * =====================\n *\n * These are used to set up the drawing context\n */\n\nexport const TILE_WIDTH = 6;\nexport const TILE_HEIGHT = 12;\nexport const TILES_X = 50;\nexport const TILES_Y = 18;\nexport const TILES_X_BORDER = 1;\nexport const TILES_Y_BORDER = 1;\nexport const WIDTH = TILE_WIDTH * TILES_X; // 300px\nexport const HEIGHT = TILE_HEIGHT * TILES_Y; // 216px\nexport const BORDER_WIDTH = TILE_WIDTH * TILES_X_BORDER;\nexport const BORDER_HEIGHT = TILE_HEIGHT * TILES_Y_BORDER;\nexport const DISPLAY_WIDTH = WIDTH - 2 * BORDER_WIDTH; // 288px\nexport const DISPLAY_HEIGHT = HEIGHT - 2 * BORDER_HEIGHT; // 192px\nexport const DISPLAY_BOUNDS = [\n  BORDER_WIDTH,\n  BORDER_HEIGHT,\n  BORDER_WIDTH + DISPLAY_WIDTH,\n  BORDER_HEIGHT + DISPLAY_HEIGHT\n];\nexport const DISPLAY_PIXELS = WIDTH * HEIGHT;\n\n/**\n * CDG Instruction Constants\n * =========================\n *\n * These are used for interpreting commands\n */\n\nexport const CDG_NOOP = 0;\nexport const CDG_MEMORY_PRESET = 1;\nexport const CDG_BORDER_PRESET = 2;\nexport const CDG_TILE_BLOCK = 6;\nexport const CDG_SCROLL_PRESET = 20;\nexport const CDG_SCROLL_COPY = 24;\nexport const CDG_SET_KEY_COLOR = 28;\nexport const CDG_LOAD_CLUT_LOW = 30;\nexport const CDG_LOAD_CLUT_HI = 31;\nexport const CDG_TILE_BLOCK_XOR = 38;\n\nexport const CDG_SCROLL_NONE = 0;\nexport const CDG_SCROLL_LEFT = 1;\nexport const CDG_SCROLL_RIGHT = 2;\nexport const CDG_SCROLL_UP = 1;\nexport const CDG_SCROLL_DOWN = 2;\n\nexport const CDG_DATA = 4;\n\nexport const COMMAND_MASK = 0x3f;\nexport const CDG_COMMAND = 0x09;\nexport const SECTORS_PER_SECOND = 75;\nexport const PACKETS_PER_SECTOR = 4;\nexport const PACKET_SIZE = 24;\n\n/**\n *  CDG Audio Constants\n */\n\nexport const GAIN_DEFAULT = 1.0;\nexport const PITCH_DEFAULT = 1;\n\n/**\n *  CDG Player Constants\n */\n\nexport const SCALE_DEFAULT = 1;\nexport const FILTER_PLAYBACK_OFFSET = 800;\nexport const START_TIME = '0:00';\n\n/**\n * CDG Controls Constants\n */\nexport const PANEL_POSITION = ['top', 'bottom'];\n","import {\n    WIDTH,\n    HEIGHT,\n    DISPLAY_PIXELS,\n} from './constants';\n\n/**\n * CDG Context\n * ===========\n *\n * CDG rendering context, maintaining the size and content of the screen and the color palette\n */\nexport default class CDGContext {\n    /**\n     * Horizontal offset\n     * @type {number}\n     */\n    hOffset = 0;\n\n    /**\n     * Vertical offset\n     * @type {number}\n     */\n    vOffset = 0;\n\n    /**\n     * Transparent index in the color lookup table\n     * @type {number}\n     */\n    keyColor = null;\n\n    /**\n     * Background index in the color lookup table\n     * @type {number}\n     */\n    backgroundContainer = null;\n\n    /**\n     * Last index in the color lookup table that was used as a border preset\n     * @type {number}\n     */\n    borderColor = null;\n\n    /**\n     * Last index in the color lookup table that was used as a memory preset\n     * @type {number}\n     */\n    memoryColor = null;\n\n    /**\n     * Color lookup table\n     * @type {Array}\n     */\n    clut = (new Array(16)).fill([0, 0, 0]);\n\n    /**\n     * Pixels\n     * @type {Array}\n     */\n    pixels = (new Array(DISPLAY_PIXELS)).fill(0);\n\n    /**\n     * Buffer\n     * @type {Array}\n     */\n    buffer = (new Array(DISPLAY_PIXELS)).fill(0);\n\n    /**\n     * Creates a CDG rendering context\n     *\n     * @constructor\n     * @param  {Object} [options] - context options\n     * @param  {number} [options.width] - width of the canvas\n     * @param  {number} [options.height] - height of the canvas\n     * @param  {HTMLCanvasElement} [options.canvas] - canvas element\n     * @param  {CanvasRenderingContext2D} [options.ctx] - canvas rendering context\n     * @param  {ImageData} [options.imageData] - pixel data\n     */\n    constructor({\n                    width = WIDTH,\n                    height = HEIGHT,\n                    canvas = this.createCanvas(width, height),\n                    ctx = this.createCanvasContext(canvas),\n                    imageData = this.createImageData(canvas, ctx, width, height),\n                } = {}) {\n        this.canvas = canvas;\n        this.ctx = ctx;\n        this.imageData = imageData;\n    }\n\n    /**\n     * Creates a canvas at the given size\n     *\n     * @param  {number} width - width of the canvas\n     * @param  {number} height - height of the canvas\n     * @return {HTMLCanvasElement} created canvas\n     */\n    createCanvas(width, height) {\n        const canvas = document.createElement('canvas');\n        canvas.width = width;\n        canvas.height = height;\n        return canvas;\n    }\n\n    /**\n     * Creates a new 2D context for a canvas\n     *\n     * @param  {HTMLCanvasElement} canvas - canvas element\n     * @return {CanvasRenderingContext2D} created context\n     */\n    createCanvasContext(canvas) {\n        const ctx = canvas.getContext('2d');\n        ctx.mozImageSmoothingEnabled = false;\n        ctx.webkitImageSmoothingEnabled = false;\n        ctx.msImageSmoothingEnabled = false;\n        ctx.imageSmoothingEnabled = false;\n        return ctx;\n    }\n\n    /**\n     * Creates image data to dump the pixel data for canvas rendering\n     *\n     * @param  {HTMLCanvasElement} canvas - canvas element\n     * @param  {CanvasRenderingContext2D} ctx - 2D canvas rendering context\n     * @param  {number} width - width of the canvas\n     * @param  {number} height - height of the canvas\n     * @return {ImageData} created image data\n     */\n    createImageData(canvas, ctx, width = canvas.width, height = canvas.height) {\n        return ctx.createImageData(width, height);\n    }\n\n    /**\n     * Resets the offset and key color\n     */\n    reset() {\n        this.hOffset = 0;\n        this.vOffset = 0;\n        this.keyColor = null;\n        this.backgroundColor = null;\n        this.borderColor = null;\n        this.memoryColor = null;\n        this.pixels.fill(0);\n    }\n\n    /**\n     * Sets an entry in the color lookup table\n     *\n     * @param  {Number} index - index in the palette\n     * @param  {number} r - red component of the color\n     * @param  {number} g - green component of the color\n     * @param  {number} b - blue component of the color\n     */\n    setCLUTEntry(index, r, g, b) {\n        this.clut[index] = [r, g, b].map(c => c * 17);\n    }\n\n    /**\n     * Sets a pixel's CLUT index value\n     *\n     * @param {number} x - x position of the pixel\n     * @param {number} y - y position of the pixel\n     * @param {number} colorIndex - CLUT index\n     */\n    setPixel(x, y, colorIndex) {\n        this.pixels[x + (y * WIDTH)] = colorIndex;\n    }\n\n    /**\n     * Gets a pixel's CLUT index value\n     *\n     * @param  {number} x - x position of the pixel\n     * @param  {number} y - y position of the pixel\n     * @return {number} CLUT index\n     */\n    getPixel(x, y) {\n        return this.pixels[x + (y * WIDTH)];\n    }\n\n    /**\n     * Gets the background color index from the CLUT based on the transparent or background color\n     *\n     * @return {number} CLUT index\n     */\n    getBackground() {\n        switch (true) {\n            case this.keyColor != null:\n                return this.keyColor;\n            case this.backgroundColor != null:\n                return this.backgroundColor;\n            case this.memoryColor != null:\n                return this.memoryColor;\n            case this.borderColor != null:\n                return this.borderColor;\n            default:\n                return 0;\n        }\n    }\n\n    /**\n     * Converts palette-based pixel data to image data\n     *\n     * @return {ImageData} generated imagedata\n     */\n    generateImageData() {\n        const [left, top, right, bottom] = [0, 0, WIDTH, HEIGHT];\n        for (let x = left; x < right; x++) {\n            for (let y = top; y < bottom; y++) {\n                // The offset is where we draw the pixel in the raster data\n                const offset = 4 * (x + (y * WIDTH));\n                // Respect the horizontal and vertical offsets for grabbing the pixel color\n                const px = ((x - this.hOffset) + WIDTH) % WIDTH;\n                const py = ((y - this.vOffset) + HEIGHT) % HEIGHT;\n                const pixelIndex = px + (py * WIDTH);\n                const colorIndex = this.pixels[pixelIndex];\n                const [r, g, b] = this.clut[colorIndex];\n                // Set the rgba values in the image data\n                this.imageData.data[offset] = r;\n                this.imageData.data[offset + 1] = g;\n                this.imageData.data[offset + 2] = b;\n                this.imageData.data[offset + 3] = colorIndex === this.keyColor ? 0x00 : 0xff;\n            }\n        }\n        return this.imageData;\n    }\n\n    /**\n     * Renders the pixel buffer\n     */\n    renderFrame() {\n        this.ctx.putImageData(this.generateImageData(), 0, 0);\n    }\n}\n","/* eslint-disable no-console */\n\nexport function log(...args) {\n    console && console.log && console.log(...args);\n}\n\nexport function warn(...args) {\n    console && console.warn && console.warn(...args);\n}\n\nexport function error(...args) {\n    console && console.error && console.error(...args);\n}\n\nexport default {\n    log,\n    warn,\n    error,\n};\n","import {\n    TILE_WIDTH,\n    TILE_HEIGHT,\n    WIDTH,\n    HEIGHT,\n    DISPLAY_BOUNDS,\n    CDG_NOOP,\n    CDG_MEMORY_PRESET,\n    CDG_BORDER_PRESET,\n    CDG_TILE_BLOCK,\n    CDG_SCROLL_PRESET,\n    CDG_SCROLL_COPY,\n    CDG_SET_KEY_COLOR,\n    CDG_LOAD_CLUT_LOW,\n    CDG_LOAD_CLUT_HI,\n    CDG_TILE_BLOCK_XOR,\n    CDG_SCROLL_NONE,\n    CDG_SCROLL_LEFT,\n    CDG_SCROLL_RIGHT,\n    CDG_SCROLL_UP,\n    CDG_SCROLL_DOWN,\n    CDG_DATA,\n    PACKET_SIZE\n} from './constants';\n\nimport { warn } from './logger';\n\n/**\n * CDG instruction base class\n * ==========================\n *\n * Does nothing\n */\nexport class CDGInstruction {\n    static instruction = '';\n    static opcode = null;\n\n    get instruction() {\n        return this.constructor.instruction;\n    }\n    get opcode() {\n        return this.constructor.opcode;\n    }\n\n    constructor(bytes, offset = 0) {\n        this.bytes = bytes.slice(offset, offset + PACKET_SIZE);\n    }\n\n    execute(/*context*/) {}\n\n    bytecodeToString() {\n        return this.bytes.map(byte => byte.toString(16).padStart(2, '0')).join('');\n    }\n\n    detailsToString() {\n        return '';\n    }\n\n    toString() {\n        return this.instruction;\n    }\n}\n\n/**\n * No-op instruction\n * =================\n *\n * Does nothing\n */\nexport class CDGNoopInstruction extends CDGInstruction {\n    static instruction = 'No-op';\n    static opcode = CDG_NOOP;\n}\n\n/**\n * Memory Preset instruction\n * =========================\n *\n * Set the screen to a particular color\n */\nexport class CDGMemoryPresetInstruction extends CDGInstruction {\n    static instruction = 'Memory Preset';\n    static opcode = CDG_MEMORY_PRESET;\n\n    constructor(bytes, offset = 0) {\n        super(bytes, offset);\n        const doff = offset + CDG_DATA;\n        this.color = bytes[doff] & 0x0f;\n        this.repeat = bytes[doff + 1] & 0x0f;\n    }\n\n    execute(context) {\n        context.memoryColor = this.color;\n        context.backgroundColor = this.color;\n        context.pixels.fill(this.color);\n    }\n\n    detailsToString() {\n        return `color index: ${this.color}`;\n    }\n}\n\n/**\n * Border Preset instruction\n * =========================\n *\n * Set the border of the screen to a particular color\n */\nexport class CDGBorderPresetInstruction extends CDGInstruction {\n    static instruction = 'Border Preset';\n    static opcode = CDG_BORDER_PRESET;\n\n    constructor(bytes, offset = 0) {\n        super(bytes, offset);\n        this.color = bytes[offset + CDG_DATA] & 0x0f;\n    }\n\n    execute(context) {\n        context.borderColor = this.color;\n        context.backgroundColor = this.color;\n        const [left, top, right, bottom] = DISPLAY_BOUNDS;\n        for (let x = 0; x < WIDTH; x++) {\n            for (let y = 0; y < top; y++) {\n                context.setPixel(x, y, this.color);\n            }\n            for (let y = bottom + 1; y < HEIGHT; y++) {\n                context.setPixel(x, y, this.color);\n            }\n        }\n        for (let y = top; y <= bottom; y++) {\n            for (let x = 0; x < left; x++) {\n                context.setPixel(x, y, this.color);\n            }\n            for (let x = right + 1; x < WIDTH; x++) {\n                context.setPixel(x, y, this.color);\n            }\n        }\n    }\n\n    detailsToString() {\n        return `color index: ${this.color}`;\n    }\n}\n\n/**\n * Tile Block (Normal) instruction\n * ===============================\n *\n * Load a 12 x 6, 2 color tile and display it normally.\n */\nexport class CDGTileBlockInstruction extends CDGInstruction {\n    static instruction = 'Tile Block';\n    static opcode = CDG_TILE_BLOCK;\n\n    constructor(bytes, offset = 0) {\n        super(bytes, offset);\n        const doff = offset + CDG_DATA;\n        // some players check bytes[doff+1] & 0x20 and ignores if it is set (?)\n        this.colors = [bytes[doff] & 0x0f, bytes[doff + 1] & 0x0f];\n        this.row = bytes[doff + 2] & 0x1f;\n        this.column = bytes[doff + 3] & 0x3f;\n        this.pixels = bytes.slice(doff + 4, doff + 16);\n    }\n\n    execute(context) {\n        /* blit a tile */\n        const x = this.column * TILE_WIDTH;\n        const y = this.row * TILE_HEIGHT;\n\n        // @TODO: These should be >= instead, I think...\n        if (x + TILE_WIDTH > WIDTH || y + TILE_HEIGHT > HEIGHT) {\n            warn(`TileBlock out of bounds (${this.row}, ${this.column})`);\n            return;\n        }\n\n        for (let i = 0; i < TILE_HEIGHT; i++) {\n            const curbyte = this.pixels[i];\n            for (let j = 0; j < TILE_WIDTH; j++) {\n                const color = this.colors[(curbyte >> (5 - j)) & 0x01];\n                this.op(context, x + j, y + i, color);\n            }\n        }\n    }\n\n    op(context, x, y, color) {\n        context.setPixel(x, y, color);\n    }\n\n    detailsToString() {\n        return `row: ${this.row}, column: ${this.column}, color indexes: [${this.colors.join(\n            ', '\n        )}]`;\n    }\n}\n\n/**\n * Tile Block (XOR) instruction\n * ============================\n *\n * Load a 12 x 6, 2 color tile and display it using the XOR method\n */\nexport class CDGTileBlockXORInstruction extends CDGTileBlockInstruction {\n    static instruction = 'Tile Block (XOR)';\n    static opcode = CDG_TILE_BLOCK_XOR;\n\n    op(context, x, y, color) {\n        // context.pixels[offset] = context.pixels[offset] ^ color;\n        context.setPixel(x, y, context.getPixel(x, y) ^ color);\n    }\n}\n\n/**\n * Scroll Preset instruction\n * =========================\n *\n * Scroll the image, filling in the new area with a color\n */\nexport class CDGScrollPresetInstruction extends CDGInstruction {\n    static instruction = 'Scroll Preset';\n    static opcode = CDG_SCROLL_PRESET;\n\n    constructor(bytes, offset = 0) {\n        super(bytes, offset);\n        const doff = offset + CDG_DATA;\n        this.color = bytes[doff] & 0x0f;\n\n        const hScroll = bytes[doff + 1] & 0x3f;\n        this.hCmd = (hScroll & 0x30) >> 4;\n        this.hOffset = hScroll & 0x07;\n\n        const vScroll = bytes[doff + 2] & 0x3f;\n        this.vCmd = (vScroll & 0x30) >> 4;\n        this.vOffset = vScroll & 0x0f;\n    }\n\n    // eslint-disable-next-line complexity\n    execute(context) {\n        context.backgroundColor = this.color;\n        context.hOffset = Math.min(this.hOffset, TILE_WIDTH - 1);\n        context.vOffset = Math.min(this.vOffset, TILE_HEIGHT - 1);\n\n        let hScroll = 0;\n        switch (this.hCmd) {\n            case CDG_SCROLL_RIGHT:\n                hScroll = TILE_WIDTH;\n                break;\n            case CDG_SCROLL_LEFT:\n                hScroll = -TILE_WIDTH;\n                break;\n            case CDG_SCROLL_NONE:\n            default:\n                break;\n        }\n\n        let vScroll = 0;\n        switch (this.hCmd) {\n            case CDG_SCROLL_DOWN:\n                vScroll = TILE_HEIGHT;\n                break;\n            case CDG_SCROLL_UP:\n                vScroll = -TILE_HEIGHT;\n                break;\n            case CDG_SCROLL_NONE:\n            default:\n                break;\n        }\n\n        if (!hScroll && !vScroll) {\n            return;\n        }\n\n        for (let x = 0; x < WIDTH; x++) {\n            for (let y = 0; y < HEIGHT; y++) {\n                context.buffer[x + y * WIDTH] = this.getPixel(context, x + hScroll, y + vScroll);\n            }\n        }\n\n        // Swap buffers\n        [context.pixels, context.buffer] = [context.buffer, context.pixels];\n    }\n\n    getPixel(context, offx, offy) {\n        if (offx > 0 && offx < WIDTH && offy > 0 && offy < HEIGHT) {\n            return context.pixels[offx + offy * WIDTH];\n        }\n        return this.color;\n    }\n\n    detailsToString() {\n        let vScroll = false;\n        let hScroll = false;\n        if (this.vCmd === CDG_SCROLL_UP) {\n            vScroll = 'up';\n        } else if (this.vCmd === CDG_SCROLL_DOWN) {\n            vScroll = 'down';\n        }\n        if (this.vCmd === CDG_SCROLL_LEFT) {\n            hScroll = 'left';\n        } else if (this.vCmd === CDG_SCROLL_RIGHT) {\n            hScroll = 'right';\n        }\n        return [vScroll, hScroll, `vOffset: ${this.vOffset}`, `hOffset: ${this.hOffset}`]\n            .filter(v => v)\n            .join(' ');\n    }\n}\n\n/**\n * Scroll Copy instruction\n * =======================\n *\n * Scroll the image, rotating the bits back around\n */\nexport class CDGScrollCopyInstruction extends CDGScrollPresetInstruction {\n    static instruction = 'Scroll Copy';\n    static opcode = CDG_SCROLL_COPY;\n\n    getPixel(context, offx, offy) {\n        offx = (offx + WIDTH) % WIDTH;\n        offy = (offy + HEIGHT) % HEIGHT;\n        return context.pixels[offx + offy * WIDTH];\n    }\n}\n\n/**\n * Set Key Color instruction\n * =========================\n *\n * Define a specific color as being transparent\n */\nexport class CDGSetKeyColorInstruction extends CDGInstruction {\n    static instruction = 'Set Key Color';\n    static opcode = CDG_SET_KEY_COLOR;\n\n    constructor(bytes, offset = 0) {\n        super(bytes, offset);\n        this.color = bytes[offset + CDG_DATA] & 0x0f;\n    }\n\n    execute(context) {\n        context.keyColor = this.color;\n    }\n\n    detailsToString() {\n        return `color index: ${this.color}`;\n    }\n}\n\n/**\n * Load Color Table (Low) instruction\n * ==================================\n *\n * Load in the lower 8 entries of the color table\n */\nexport class CDGLoadCLUTLowInstruction extends CDGInstruction {\n    static instruction = 'Load CLUT (Low)';\n    static opcode = CDG_LOAD_CLUT_LOW;\n\n    get clutOffset() {\n        return 0;\n    }\n\n    constructor(bytes, offset = 0) {\n        super(bytes, offset);\n        const doff = offset + CDG_DATA;\n        this.colors = [];\n        for (let i = 0; i < 8; i++) {\n            const cur = doff + 2 * i;\n            const color = ((bytes[cur] & 0x3f) << 6) + (bytes[cur + 1] & 0x3f);\n\n            this.colors[i] = [\n                color >> 8, // red\n                (color & 0xf0) >> 4, // green\n                color & 0x0f // blue\n            ];\n        }\n    }\n\n    execute(context) {\n        for (let i = 0; i < 8; i++) {\n            context.setCLUTEntry(\n                i + this.clutOffset,\n                this.colors[i][0],\n                this.colors[i][1],\n                this.colors[i][2]\n            );\n        }\n    }\n\n    detailsToString() {\n        return `colors: [${this.colors\n            .map(\n                (color, i) => `${i + this.clutOffset}: #${color.map(c => c.toString(16)).join('')}`\n            )\n            .join(', ')}]`;\n    }\n}\n\n/**\n * Load Color Table (High) instruction\n * ==================================\n *\n * Load in the upper 8 entries of the color table\n */\nexport class CDGLoadCLUTHighInstruction extends CDGLoadCLUTLowInstruction {\n    static instruction = 'Load CLUT (High)';\n    static opcode = CDG_LOAD_CLUT_HI;\n\n    get clutOffset() {\n        return 8;\n    }\n}\n","import {\n    CDG_NOOP,\n    CDG_MEMORY_PRESET,\n    CDG_BORDER_PRESET,\n    CDG_TILE_BLOCK,\n    CDG_SCROLL_PRESET,\n    CDG_SCROLL_COPY,\n    CDG_SET_KEY_COLOR,\n    CDG_LOAD_CLUT_LOW,\n    CDG_LOAD_CLUT_HI,\n    CDG_TILE_BLOCK_XOR,\n    COMMAND_MASK,\n    CDG_COMMAND,\n    PACKET_SIZE,\n} from './constants';\n\nimport { warn } from './logger';\n\nimport {\n    CDGNoopInstruction,\n    CDGMemoryPresetInstruction,\n    CDGBorderPresetInstruction,\n    CDGTileBlockInstruction,\n    CDGScrollPresetInstruction,\n    CDGScrollCopyInstruction,\n    CDGSetKeyColorInstruction,\n    CDGLoadCLUTLowInstruction,\n    CDGLoadCLUTHighInstruction,\n    CDGTileBlockXORInstruction,\n} from './CDGInstruction';\n\n/**\n * CDG Parser\n * ==========\n *\n * Instruction parser, converting bytecodes to arrays of CDGInstructions\n */\nexport default class CDGParser {\n    static get instructionClassByType() {\n        return {\n            [CDG_NOOP]: CDGNoopInstruction,\n            [CDG_MEMORY_PRESET]: CDGMemoryPresetInstruction,\n            [CDG_BORDER_PRESET]: CDGBorderPresetInstruction,\n            [CDG_TILE_BLOCK]: CDGTileBlockInstruction,\n            [CDG_SCROLL_PRESET]: CDGScrollPresetInstruction,\n            [CDG_SCROLL_COPY]: CDGScrollCopyInstruction,\n            [CDG_SET_KEY_COLOR]: CDGSetKeyColorInstruction,\n            [CDG_LOAD_CLUT_LOW]: CDGLoadCLUTLowInstruction,\n            [CDG_LOAD_CLUT_HI]: CDGLoadCLUTHighInstruction,\n            [CDG_TILE_BLOCK_XOR]: CDGTileBlockXORInstruction,\n        };\n    }\n\n    /**\n     * Maps commands to instruction classes\n     * @type {Object}\n     */\n    instructionClassByType = this.constructor.instructionClassByType;\n\n    /**\n     * Registers an instruction type\n     *\n     * @param  {string} opcode - CDG instruction opcode\n     * @param  {CDGInstruction} InstructionClass - CDG instruction subclass\n     */\n    registerInstruction(opcode, InstructionClass) {\n        this.instructionClassByType[opcode] = InstructionClass;\n    }\n\n    /**\n     * Creates an instruction\n     *\n     * @param  {string} opcode - CDG instruction opcode\n     * @param  {string} bytes - bytes with CDG instruction\n     * @param  {number} offset - a little piece of heaven\n     * @return {CDGInstruction}\n     */\n    createInstruction(opcode, bytes, offset = 0) {\n        if (!(opcode in this.instructionClassByType)) {\n            warn(`Unknown CDG instruction (instruction = ${opcode})`);\n        }\n        const InstructionClass = this.instructionClassByType[opcode] || CDGNoopInstruction;\n        return new InstructionClass(bytes, offset);\n    }\n\n    /**\n     * Parses a single CDG instruction packet\n     *\n     * @param  {string} bytes - bytes with CDG instruction\n     * @param  {number} offset - a little piece of heaven\n     * @return {CDGInstruction}\n     */\n    parseInstruction(bytes, offset = 0) {\n        const command = bytes[offset] & COMMAND_MASK;\n        if (command === CDG_COMMAND) {\n            const opcode = bytes[offset + 1] & COMMAND_MASK;\n            return this.createInstruction(opcode, bytes, offset);\n        }\n        return new CDGNoopInstruction(bytes, offset);\n    }\n\n    /**\n     * Parses all the CDG instruction packets\n     *\n     * @param {string} bytes - bytes with CDG instruction\n     * @return {CDGInstruction[]}\n     */\n    parseInstructions(bytes) {\n        const instructions = [];\n        const bytesLength = bytes.length;\n        for (let offset = 0; offset < bytesLength; offset += PACKET_SIZE) {\n            instructions.push(this.parseInstruction(bytes, offset));\n        }\n        return instructions.filter(instruction => instruction);\n    }\n}\n","import {\n    PACKETS_PER_SECTOR,\n    SECTORS_PER_SECOND,\n} from './constants';\n\nimport CDGContext from './CDGContext';\nimport CDGParser from './CDGParser';\n\n/**\n * Calculates current time for the sake of determining playback intervals\n *\n * @return {number} milliseconds\n */\nfunction now() {\n    if (typeof performance !== 'undefined' && typeof performance.now === 'function') {\n        return performance.now();\n    } else if (typeof process !== 'undefined' && typeof process.hrtime === 'function') {\n        const [seconds, microseconds] = process.hrtime();\n        return (seconds * 1000) + (microseconds / 1000000);\n    }\n    return Date.now();\n}\n\nfunction requestFrame(callback) {\n    if (typeof requestAnimationFrame === 'function') {\n        return window.requestAnimationFrame(callback);\n    }\n    return setTimeout(callback, 25);\n}\n\nfunction cancelFrame(id) {\n    if (typeof cancelAnimationFrame === 'function') {\n        return cancelAnimationFrame(id);\n    }\n    return clearTimeout(id);\n}\n\n/**\n * CDG Player\n * ==========\n *\n * Provides an interface for interpreting CDG instructions and rendering the results to a canvas\n */\nexport default class CDGPlayer {\n    /**\n     * CDG instructions\n     * @type {Array}\n     */\n    instructions = [];\n\n    /**\n     * Packet counter\n     * @type {Number}\n     */\n    pc = -1;\n\n    /**\n     * requestAnimationFrame unique ID\n     * @type {number}\n     */\n    frameId = null;\n\n    /**\n     * Current time (ms)\n     * @type {Number}\n     */\n    pos = 0;\n\n    /**\n     * Last sync time (ms)\n     * @type {number}\n     */\n    lastSyncPos = null;\n\n    /**\n     * Last sync timestamp\n     * @type {DOMHighResTimeStamp}\n     */\n    lastTimestamp = null;\n\n    /**\n     * Steps through however many frames are necessary to bring the context up-to-date with\n     *\n     * @param  {DOMHighResTimeStamp} timestamp\n     * @return {self}\n     */\n    update = (timestamp = now()) => {\n        // Packet counter says relax\n        if (this.pc === -1) {\n            return this;\n        }\n\n        // go ahead and request the next frame\n        this.frameId = requestFrame(this.update);\n\n        if (this.lastSyncPos) {\n            // last known audio position + time delta\n            this.pos = this.lastSyncPos + (timestamp - this.lastTimestamp);\n        } else {\n            // time delta only (unsynced)\n            this.pos += timestamp - this.lastTimestamp;\n            this.lastTimestamp = timestamp;\n        }\n\n        // determine packet we should be at, based on spec\n        // of 4 packets per sector @ 75 sectors per second\n        const newPc = Math.floor(SECTORS_PER_SECOND * PACKETS_PER_SECTOR * (this.pos / 1000));\n\n        const ffAmt = newPc - this.pc;\n        if (ffAmt > 0) {\n            this.fastForward(ffAmt);\n            this.render();\n        }\n\n        return this;\n    };\n\n    /**\n     * Creates CDGPlayer instance\n     *\n     * @constructor\n     * @param  {Object} [options] - CDG player options\n     * @param  {Object} [options.contextOptions] - options for the CDG context\n     * @param  {function} [options.afterRender] - function to call after rendering a frame\n     */\n    constructor({\n                    contextOptions = {},\n                    context = this.createContext(contextOptions),\n                    afterRender,\n                } = {}) {\n        this.context = context;\n        this.afterRender = afterRender;\n    }\n\n    /**\n     * Creates a CDG context instance for rendering\n     *\n     * @param  {Object} [options] - parameters passed to the context constructor\n     * @return {CDGContext} context instance\n     */\n    createContext(options = {}) {\n        return new CDGContext(options);\n    }\n\n    /**\n     * Loads CDG data and parses the instructions\n     *\n     * @param  {string} data - CDG instruction data\n     * @return {self}\n     */\n    load(data) {\n        const parser = new CDGParser();\n        this.instructions = parser.parseInstructions(data);\n        this.reset();\n        return this;\n    }\n\n    /**\n     * Resets the counters\n     *\n     * @return {self}\n     */\n    reset() {\n        this.pc = 0;\n        this.pos = 0;\n        this.lastSyncPos = null;\n        this.context.reset();\n        return this;\n    }\n\n    /**\n     * Renders the CDG context frame\n     * @return {self}\n     */\n    render() {\n        this.context.renderFrame();\n        this.afterRender && this.afterRender(this.context);\n        return this;\n    }\n\n    /**\n     * Executes an instruction on this player's context\n     *\n     * @param  {CDGInstruction} instruction - CDG instruction to run\n     * @return {self}\n     */\n    executeInstruction(instruction) {\n        if (instruction && typeof instruction.execute === 'function') {\n            instruction.execute(this.context);\n        }\n        return this;\n    }\n\n    /**\n     * Executes the next CDG instruction packet\n     *\n     * @return {self}\n     */\n    step() {\n        if (this.pc >= 0 && this.pc < this.instructions.length) {\n            this.executeInstruction(this.instructions[this.pc]);\n            this.pc += 1;\n        } else {\n            this.pc = -1;\n            this.stop();\n        }\n        return this;\n    }\n\n    /**\n     * Executes several CDG instructions\n     *\n     * @param  {number} [count]\n     * @return {self}\n     */\n    fastForward(count = 1) {\n        const max = this.pc + count;\n        while (this.pc >= 0 && this.pc < max) {\n            this.step();\n        }\n        return this;\n    }\n\n    /**\n     * Starts CDG playback\n     *\n     * @return {self}\n     */\n    play() {\n        if (!this.frameId) {\n            this.frameId = requestFrame(this.update);\n            this.lastTimestamp = now();\n        }\n        return this;\n    }\n\n    /**\n     * Stops CDG playback\n     *\n     * @return {self}\n     */\n    stop() {\n        cancelFrame(this.frameId);\n        this.frameId = null;\n        this.lastSyncPos = null;\n        return this;\n    }\n\n    /**\n     * Syncs playback with a timestamp\n     *\n     * This is used to sync with the current time of the audio track\n     *\n     * @param  {number} ms - sync timestamp\n     * @return {self}\n     */\n    sync(ms) {\n        this.lastSyncPos = ms;\n        this.lastTimestamp = now();\n        return this;\n    }\n}\n","/**\n * Deferred()\n * Is a shim, written by Mozilla. It's a backwards/forwards compatible helper object to account for the\n * elimination of the Deferred object while still having a need for the functionality.\n *\n * https://developer.mozilla.org/en-US/docs/Mozilla/JavaScript_code_modules/Promise.jsm/Deferred#backwards_forwards_compatible\n * (Usage example can be found at above link, but here's the basics)\n *\n * const deferred = new Deferred();\n * const promise = deferred.promise; // still just a promise\n */\n\nconst Deferred = function () {\n    // update 062115 for typeof\n    if (typeof(Promise) !== 'undefined' && Promise.defer) {\n        //need import of Promise.jsm for example: Cu.import('resource:/gree/modules/Promise.jsm');\n        return Promise.defer();\n    } else if (typeof(PromiseUtils) !== 'undefined'  && PromiseUtils.defer) { // eslint-disable-line no-undef\n        //need import of PromiseUtils.jsm for example: Cu.import('resource:/gree/modules/PromiseUtils.jsm');\n        return PromiseUtils.defer(); // eslint-disable-line no-undef\n    } else {\n        /* A method to resolve the associated Promise with the value passed.\n         * If the promise is already settled it does nothing.\n         *\n         * @param {anything} value : This value is used to resolve the promise\n         * If the value is a Promise then the associated promise assumes the state\n         * of Promise passed as value.\n         */\n        this.resolve = null;\n\n        /* A method to reject the assocaited Promise with the value passed.\n         * If the promise is already settled it does nothing.\n         *\n         * @param {anything} reason: The reason for the rejection of the Promise.\n         * Generally its an Error object. If however a Promise is passed, then the Promise\n         * itself will be the reason for rejection no matter the state of the Promise.\n         */\n        this.reject = null;\n\n        /* A newly created Promise object.\n         * Initially in pending state.\n         */\n        this.promise = new Promise(function(resolve, reject) {\n            this.resolve = resolve;\n            this.reject = reject;\n        }.bind(this));\n        Object.freeze(this);\n    }\n};\n\nexport default Deferred;","// JSZip and JSZipUtils are external dependencies\n//import * as JSZip from 'jszip';\n//import JSZipUtils from 'jszip-utils';\nimport Deferred from '../utilities/deferred.js';\n// import jsmediatags from 'jsmediatags';\n\nconst getDataFile = function(filePath) {\n  const deferred = new Deferred();\n  JSZipUtils.getBinaryContent(filePath, (err, data) => {\n    if (err) {\n      deferred.reject(new Error(`There was an error retrieving ${filePath}`, err));\n      return;\n    }\n    deferred.resolve(data);\n  });\n  return deferred.promise;\n};\n\nconst loadZipBuffer = function(fileBuffer) {\n  return JSZip.loadAsync(fileBuffer).catch(error =>\n    Promise.reject(new Error(`There was an error reading the zip file.`, error))\n  );\n};\n\nconst loadAudio = function(zipEntry) {\n  return zipEntry\n    .async('arraybuffer')\n    .catch(() => Promise.reject(new Error(`Unable to load the audio file`)));\n};\n\nconst getFallbackTagData = function(name) {\n  const parts = name.split(' - ');\n  const tag = { tags: {} };\n  // most downloaded cdgs have filenames 'album - artist - songtitle\n  tag.tags.album = parts[0].trim();\n  tag.tags.artist = parts[1] ? parts[1].trim() : tag.tags.album;\n  tag.tags.title = parts[2] ? parts[2].trim() : tag.tags.artist;\n  return tag;\n};\n\nconst getTagData = function(zipEntry) {\n  return zipEntry\n    .async('blob')\n    .then(\n      buffer =>\n        new Promise(resolve => {\n          new jsmediatags.Reader(buffer)\n            .setTagsToRead(['title', 'artist', 'album', 'track', 'year', 'genre', 'picture'])\n            .read({\n              onSuccess: tag => resolve(tag),\n              onError: () => resolve(getFallbackTagData(zipEntry.name))\n            });\n        })\n    )\n    .catch(() => Promise.reject(new Error('Unable to parse tag data')));\n};\n\nconst loadVideo = function(zipEntry) {\n  return zipEntry\n    .async('uint8array')\n    .catch(() => Promise.reject(new Error(`Unable to load the video file`)));\n};\n\nconst getKaraokeFiles = function(zipFile) {\n  const entries = zipFile.filter(relPath => relPath.endsWith('.cdg') || relPath.endsWith('.mp3'));\n  if (entries.length === 2) {\n    return Promise.resolve(entries);\n  }\n  return Promise.reject(`The file is not a karaoke .zip file`);\n};\n\nconst processZip = function(entries) {\n  const audio = entries.filter(entry => entry.name.endsWith('.mp3'));\n  const video = entries.filter(entry => entry.name.endsWith('.cdg'));\n  const process = [];\n  if (audio.length && video.length) {\n    process.push(loadAudio(audio[0]));\n    process.push(loadVideo(video[0]));\n    process.push(getTagData(audio[0]));\n    return Promise.all(process).catch(() =>\n      Promise.reject(new Error(`Processing audio and video failed`))\n    );\n  }\n  const errors = [];\n  if (!audio.length) {\n    errors.push('No mp3 audio file present.');\n  }\n  if (!video.length) {\n    errors.push('No cdg video file present.');\n  }\n  return Promise.reject(new Error(errors.join(' ')));\n};\n\nexport default class CDGFileLoader {\n  static loadZipFile(filePath) {\n    return getDataFile(filePath)\n      .then(fileBuffer => loadZipBuffer(fileBuffer))\n      .then(zipFile => getKaraokeFiles(zipFile))\n      .then(entries => processZip(entries))\n      .catch(error => Promise.reject(error));\n  }\n\n  static loadFileBuffer(fileBuffer) {\n    return loadZipBuffer(fileBuffer)\n      .then(zipFile => getKaraokeFiles(zipFile))\n      .then(entries => processZip(entries))\n      .catch(err => Promise.reject(err));\n  }\n}\n","/*\n * SoundTouch JS v0.1.5 audio processing library\n * Copyright (c) Olli Parviainen\n * Copyright (c) Ryan Berdeen\n * Copyright (c) Jakub Fiala\n * Copyright (c) Steve 'Cutter' Blades\n *\n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n */\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function\");\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) _setPrototypeOf(subClass, superClass);\n}\n\nfunction _getPrototypeOf(o) {\n  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return _getPrototypeOf(o);\n}\n\nfunction _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n\n  return _setPrototypeOf(o, p);\n}\n\nfunction _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return self;\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (call && (typeof call === \"object\" || typeof call === \"function\")) {\n    return call;\n  }\n\n  return _assertThisInitialized(self);\n}\n\nfunction _superPropBase(object, property) {\n  while (!Object.prototype.hasOwnProperty.call(object, property)) {\n    object = _getPrototypeOf(object);\n    if (object === null) break;\n  }\n\n  return object;\n}\n\nfunction _get(target, property, receiver) {\n  if (typeof Reflect !== \"undefined\" && Reflect.get) {\n    _get = Reflect.get;\n  } else {\n    _get = function _get(target, property, receiver) {\n      var base = _superPropBase(target, property);\n\n      if (!base) return;\n      var desc = Object.getOwnPropertyDescriptor(base, property);\n\n      if (desc.get) {\n        return desc.get.call(receiver);\n      }\n\n      return desc.value;\n    };\n  }\n\n  return _get(target, property, receiver || target);\n}\n\nvar FifoSampleBuffer =\nfunction () {\n  function FifoSampleBuffer() {\n    _classCallCheck(this, FifoSampleBuffer);\n    this._vector = new Float32Array();\n    this._position = 0;\n    this._frameCount = 0;\n  }\n  _createClass(FifoSampleBuffer, [{\n    key: \"clear\",\n    value: function clear() {\n      this.receive(this._frameCount);\n      this.rewind();\n    }\n  }, {\n    key: \"put\",\n    value: function put(numFrames) {\n      this._frameCount += numFrames;\n    }\n  }, {\n    key: \"putSamples\",\n    value: function putSamples(samples, position) {\n      var numFrames = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n      position = position || 0;\n      var sourceOffset = position * 2;\n      if (!(numFrames >= 0)) {\n        numFrames = (samples.length - sourceOffset) / 2;\n      }\n      var numSamples = numFrames * 2;\n      this.ensureCapacity(numFrames + this._frameCount);\n      var destOffset = this.endIndex;\n      this.vector.set(samples.subarray(sourceOffset, sourceOffset + numSamples), destOffset);\n      this._frameCount += numFrames;\n    }\n  }, {\n    key: \"putBuffer\",\n    value: function putBuffer(buffer, position) {\n      var numFrames = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n      position = position || 0;\n      if (!(numFrames >= 0)) {\n        numFrames = buffer.frameCount - position;\n      }\n      this.putSamples(buffer.vector, buffer.position + position, numFrames);\n    }\n  }, {\n    key: \"receive\",\n    value: function receive(numFrames) {\n      if (!(numFrames >= 0) || numFrames > this._frameCount) {\n        numFrames = this.frameCount;\n      }\n      this._frameCount -= numFrames;\n      this._position += numFrames;\n    }\n  }, {\n    key: \"receiveSamples\",\n    value: function receiveSamples(output) {\n      var numFrames = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      var numSamples = numFrames * 2;\n      var sourceOffset = this.startIndex;\n      output.set(this._vector.subarray(sourceOffset, sourceOffset + numSamples));\n      this.receive(numFrames);\n    }\n  }, {\n    key: \"extract\",\n    value: function extract(output) {\n      var position = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      var numFrames = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n      var sourceOffset = this.startIndex + position * 2;\n      var numSamples = numFrames * 2;\n      output.set(this._vector.subarray(sourceOffset, sourceOffset + numSamples));\n    }\n  }, {\n    key: \"ensureCapacity\",\n    value: function ensureCapacity() {\n      var numFrames = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n      var minLength = parseInt(numFrames * 2);\n      if (this._vector.length < minLength) {\n        var newVector = new Float32Array(minLength);\n        newVector.set(this._vector.subarray(this.startIndex, this.endIndex));\n        this._vector = newVector;\n        this._position = 0;\n      } else {\n        this.rewind();\n      }\n    }\n  }, {\n    key: \"ensureAdditionalCapacity\",\n    value: function ensureAdditionalCapacity() {\n      var numFrames = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n      this.ensureCapacity(this._frameCount + numFrames);\n    }\n  }, {\n    key: \"rewind\",\n    value: function rewind() {\n      if (this._position > 0) {\n        this._vector.set(this._vector.subarray(this.startIndex, this.endIndex));\n        this._position = 0;\n      }\n    }\n  }, {\n    key: \"vector\",\n    get: function get() {\n      return this._vector;\n    }\n  }, {\n    key: \"position\",\n    get: function get() {\n      return this._position;\n    }\n  }, {\n    key: \"startIndex\",\n    get: function get() {\n      return this._position * 2;\n    }\n  }, {\n    key: \"frameCount\",\n    get: function get() {\n      return this._frameCount;\n    }\n  }, {\n    key: \"endIndex\",\n    get: function get() {\n      return (this._position + this._frameCount) * 2;\n    }\n  }]);\n  return FifoSampleBuffer;\n}();\n\nvar AbstractFifoSamplePipe =\nfunction () {\n  function AbstractFifoSamplePipe(createBuffers) {\n    _classCallCheck(this, AbstractFifoSamplePipe);\n    if (createBuffers) {\n      this._inputBuffer = new FifoSampleBuffer();\n      this._outputBuffer = new FifoSampleBuffer();\n    } else {\n      this._inputBuffer = this._outputBuffer = null;\n    }\n  }\n  _createClass(AbstractFifoSamplePipe, [{\n    key: \"clear\",\n    value: function clear() {\n      this._inputBuffer.clear();\n      this._outputBuffer.clear();\n    }\n  }, {\n    key: \"inputBuffer\",\n    get: function get() {\n      return this._inputBuffer;\n    },\n    set: function set(inputBuffer) {\n      this._inputBuffer = inputBuffer;\n    }\n  }, {\n    key: \"outputBuffer\",\n    get: function get() {\n      return this._outputBuffer;\n    },\n    set: function set(outputBuffer) {\n      this._outputBuffer = outputBuffer;\n    }\n  }]);\n  return AbstractFifoSamplePipe;\n}();\n\nvar RateTransposer =\nfunction (_AbstractFifoSamplePi) {\n  _inherits(RateTransposer, _AbstractFifoSamplePi);\n  function RateTransposer(createBuffers) {\n    var _this;\n    _classCallCheck(this, RateTransposer);\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(RateTransposer).call(this, createBuffers));\n    _this.reset();\n    _this._rate = 1;\n    return _this;\n  }\n  _createClass(RateTransposer, [{\n    key: \"reset\",\n    value: function reset() {\n      this.slopeCount = 0;\n      this.prevSampleL = 0;\n      this.prevSampleR = 0;\n    }\n  }, {\n    key: \"clone\",\n    value: function clone() {\n      var result = new RateTransposer();\n      result.rate = this._rate;\n      return result;\n    }\n  }, {\n    key: \"process\",\n    value: function process() {\n      var numFrames = this._inputBuffer.frameCount;\n      this._outputBuffer.ensureAdditionalCapacity(numFrames / this._rate + 1);\n      var numFramesOutput = this.transpose(numFrames);\n      this._inputBuffer.receive();\n      this._outputBuffer.put(numFramesOutput);\n    }\n  }, {\n    key: \"transpose\",\n    value: function transpose() {\n      var numFrames = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n      if (numFrames === 0) {\n        return 0;\n      }\n      var src = this._inputBuffer.vector;\n      var srcOffset = this._inputBuffer.startIndex;\n      var dest = this._outputBuffer.vector;\n      var destOffset = this._outputBuffer.endIndex;\n      var used = 0;\n      var i = 0;\n      while (this.slopeCount < 1.0) {\n        dest[destOffset + 2 * i] = (1.0 - this.slopeCount) * this.prevSampleL + this.slopeCount * src[srcOffset];\n        dest[destOffset + 2 * i + 1] = (1.0 - this.slopeCount) * this.prevSampleR + this.slopeCount * src[srcOffset + 1];\n        i = i + 1;\n        this.slopeCount += this._rate;\n      }\n      this.slopeCount -= 1.0;\n      if (numFrames !== 1) {\n        out: while (true) {\n          while (this.slopeCount > 1.0) {\n            this.slopeCount -= 1.0;\n            used = used + 1;\n            if (used >= numFrames - 1) {\n              break out;\n            }\n          }\n          var srcIndex = srcOffset + 2 * used;\n          dest[destOffset + 2 * i] = (1.0 - this.slopeCount) * src[srcIndex] + this.slopeCount * src[srcIndex + 2];\n          dest[destOffset + 2 * i + 1] = (1.0 - this.slopeCount) * src[srcIndex + 1] + this.slopeCount * src[srcIndex + 3];\n          i = i + 1;\n          this.slopeCount += this._rate;\n        }\n      }\n      this.prevSampleL = src[srcOffset + 2 * numFrames - 2];\n      this.prevSampleR = src[srcOffset + 2 * numFrames - 1];\n      return i;\n    }\n  }, {\n    key: \"rate\",\n    set: function set(rate) {\n      this._rate = rate;\n    }\n  }]);\n  return RateTransposer;\n}(AbstractFifoSamplePipe);\n\nvar FilterSupport =\nfunction () {\n  function FilterSupport(pipe) {\n    _classCallCheck(this, FilterSupport);\n    this._pipe = pipe;\n  }\n  _createClass(FilterSupport, [{\n    key: \"fillInputBuffer\",\n    value: function fillInputBuffer()\n    {\n      throw new Error('fillInputBuffer() not overridden');\n    }\n  }, {\n    key: \"fillOutputBuffer\",\n    value: function fillOutputBuffer() {\n      var numFrames = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n      while (this.outputBuffer.frameCount < numFrames) {\n        var numInputFrames = 8192 * 2 - this.inputBuffer.frameCount;\n        this.fillInputBuffer(numInputFrames);\n        if (this.inputBuffer.frameCount < 8192 * 2) {\n          break;\n        }\n        this._pipe.process();\n      }\n    }\n  }, {\n    key: \"clear\",\n    value: function clear() {\n      this._pipe.clear();\n    }\n  }, {\n    key: \"pipe\",\n    get: function get() {\n      return this._pipe;\n    }\n  }, {\n    key: \"inputBuffer\",\n    get: function get() {\n      return this._pipe.inputBuffer;\n    }\n  }, {\n    key: \"outputBuffer\",\n    get: function get() {\n      return this._pipe.outputBuffer;\n    }\n  }]);\n  return FilterSupport;\n}();\n\nvar noop = function noop() {\n  return;\n};\n\nvar SimpleFilter =\nfunction (_FilterSupport) {\n  _inherits(SimpleFilter, _FilterSupport);\n  function SimpleFilter(sourceSound, pipe) {\n    var _this;\n    var callback = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : noop;\n    _classCallCheck(this, SimpleFilter);\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(SimpleFilter).call(this, pipe));\n    _this.callback = callback;\n    _this.sourceSound = sourceSound;\n    _this.historyBufferSize = 22050;\n    _this._sourcePosition = 0;\n    _this.outputBufferPosition = 0;\n    _this._position = 0;\n    return _this;\n  }\n  _createClass(SimpleFilter, [{\n    key: \"onEnd\",\n    value: function onEnd() {\n      this.callback();\n    }\n  }, {\n    key: \"fillInputBuffer\",\n    value: function fillInputBuffer() {\n      var numFrames = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n      var samples = new Float32Array(numFrames * 2);\n      var numFramesExtracted = this.sourceSound.extract(samples, numFrames, this._sourcePosition);\n      this._sourcePosition += numFramesExtracted;\n      this.inputBuffer.putSamples(samples, 0, numFramesExtracted);\n    }\n  }, {\n    key: \"extract\",\n    value: function extract(target) {\n      var numFrames = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      this.fillOutputBuffer(this.outputBufferPosition + numFrames);\n      var numFramesExtracted = Math.min(numFrames, this.outputBuffer.frameCount - this.outputBufferPosition);\n      this.outputBuffer.extract(target, this.outputBufferPosition, numFramesExtracted);\n      var currentFrames = this.outputBufferPosition + numFramesExtracted;\n      this.outputBufferPosition = Math.min(this.historyBufferSize, currentFrames);\n      this.outputBuffer.receive(Math.max(currentFrames - this.historyBufferSize, 0));\n      this._position += numFramesExtracted;\n      return numFramesExtracted;\n    }\n  }, {\n    key: \"handleSampleData\",\n    value: function handleSampleData(event) {\n      this.extract(event.data, 4096);\n    }\n  }, {\n    key: \"clear\",\n    value: function clear() {\n      _get(_getPrototypeOf(SimpleFilter.prototype), \"clear\", this).call(this);\n      this.outputBufferPosition = 0;\n    }\n  }, {\n    key: \"position\",\n    get: function get() {\n      return this._position;\n    },\n    set: function set(position) {\n      if (position > this._position) {\n        throw new RangeError('New position may not be greater than current position');\n      }\n      var newOutputBufferPosition = this.outputBufferPosition - (this._position - position);\n      if (newOutputBufferPosition < 0) {\n        throw new RangeError('New position falls outside of history buffer');\n      }\n      this.outputBufferPosition = newOutputBufferPosition;\n      this._position = position;\n    }\n  }, {\n    key: \"sourcePosition\",\n    get: function get() {\n      return this._sourcePosition;\n    },\n    set: function set(sourcePosition) {\n      this.clear();\n      this._sourcePosition = sourcePosition;\n    }\n  }]);\n  return SimpleFilter;\n}(FilterSupport);\n\nvar USE_AUTO_SEQUENCE_LEN = 0;\nvar DEFAULT_SEQUENCE_MS = USE_AUTO_SEQUENCE_LEN;\nvar USE_AUTO_SEEKWINDOW_LEN = 0;\nvar DEFAULT_SEEKWINDOW_MS = USE_AUTO_SEEKWINDOW_LEN;\nvar DEFAULT_OVERLAP_MS = 8;\nvar _SCAN_OFFSETS = [[124, 186, 248, 310, 372, 434, 496, 558, 620, 682, 744, 806, 868, 930, 992, 1054, 1116, 1178, 1240, 1302, 1364, 1426, 1488, 0], [-100, -75, -50, -25, 25, 50, 75, 100, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [-20, -15, -10, -5, 5, 10, 15, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [-4, -3, -2, -1, 1, 2, 3, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]];\nvar AUTOSEQ_TEMPO_LOW = 0.5;\nvar AUTOSEQ_TEMPO_TOP = 2.0;\nvar AUTOSEQ_AT_MIN = 125.0;\nvar AUTOSEQ_AT_MAX = 50.0;\nvar AUTOSEQ_K = (AUTOSEQ_AT_MAX - AUTOSEQ_AT_MIN) / (AUTOSEQ_TEMPO_TOP - AUTOSEQ_TEMPO_LOW);\nvar AUTOSEQ_C = AUTOSEQ_AT_MIN - AUTOSEQ_K * AUTOSEQ_TEMPO_LOW;\nvar AUTOSEEK_AT_MIN = 25.0;\nvar AUTOSEEK_AT_MAX = 15.0;\nvar AUTOSEEK_K = (AUTOSEEK_AT_MAX - AUTOSEEK_AT_MIN) / (AUTOSEQ_TEMPO_TOP - AUTOSEQ_TEMPO_LOW);\nvar AUTOSEEK_C = AUTOSEEK_AT_MIN - AUTOSEEK_K * AUTOSEQ_TEMPO_LOW;\nvar Stretch =\nfunction (_AbstractFifoSamplePi) {\n  _inherits(Stretch, _AbstractFifoSamplePi);\n  function Stretch(createBuffers) {\n    var _this;\n    _classCallCheck(this, Stretch);\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(Stretch).call(this, createBuffers));\n    _this._quickSeek = true;\n    _this.midBufferDirty = false;\n    _this.midBuffer = null;\n    _this.overlapLength = 0;\n    _this.autoSeqSetting = true;\n    _this.autoSeekSetting = true;\n    _this._tempo = 1;\n    _this.setParameters(44100, DEFAULT_SEQUENCE_MS, DEFAULT_SEEKWINDOW_MS, DEFAULT_OVERLAP_MS);\n    return _this;\n  }\n  _createClass(Stretch, [{\n    key: \"clear\",\n    value: function clear() {\n      _get(_getPrototypeOf(Stretch.prototype), \"clear\", this).call(this);\n      this.clearMidBuffer();\n    }\n  }, {\n    key: \"clearMidBuffer\",\n    value: function clearMidBuffer() {\n      if (this.midBufferDirty) {\n        this.midBufferDirty = false;\n        this.midBuffer = null;\n      }\n    }\n  }, {\n    key: \"setParameters\",\n    value: function setParameters(sampleRate, sequenceMs, seekWindowMs, overlapMs) {\n      if (sampleRate > 0) {\n        this.sampleRate = sampleRate;\n      }\n      if (overlapMs > 0) {\n        this.overlapMs = overlapMs;\n      }\n      if (sequenceMs > 0) {\n        this.sequenceMs = sequenceMs;\n        this.autoSeqSetting = false;\n      } else {\n        this.autoSeqSetting = true;\n      }\n      if (seekWindowMs > 0) {\n        this.seekWindowMs = seekWindowMs;\n        this.autoSeekSetting = false;\n      } else {\n        this.autoSeekSetting = true;\n      }\n      this.calculateSequenceParameters();\n      this.calculateOverlapLength(this.overlapMs);\n      this.tempo = this._tempo;\n    }\n  }, {\n    key: \"calculateOverlapLength\",\n    value: function calculateOverlapLength() {\n      var overlapInMsec = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n      var newOvl;\n      newOvl = this.sampleRate * overlapInMsec / 1000;\n      newOvl = newOvl < 16 ? 16 : newOvl;\n      newOvl -= newOvl % 8;\n      this.overlapLength = newOvl;\n      this.refMidBuffer = new Float32Array(this.overlapLength * 2);\n      this.midBuffer = new Float32Array(this.overlapLength * 2);\n    }\n  }, {\n    key: \"checkLimits\",\n    value: function checkLimits(x, mi, ma) {\n      return x < mi ? mi : x > ma ? ma : x;\n    }\n  }, {\n    key: \"calculateSequenceParameters\",\n    value: function calculateSequenceParameters() {\n      var seq;\n      var seek;\n      if (this.autoSeqSetting) {\n        seq = AUTOSEQ_C + AUTOSEQ_K * this._tempo;\n        seq = this.checkLimits(seq, AUTOSEQ_AT_MAX, AUTOSEQ_AT_MIN);\n        this.sequenceMs = Math.floor(seq + 0.5);\n      }\n      if (this.autoSeekSetting) {\n        seek = AUTOSEEK_C + AUTOSEEK_K * this._tempo;\n        seek = this.checkLimits(seek, AUTOSEEK_AT_MAX, AUTOSEEK_AT_MIN);\n        this.seekWindowMs = Math.floor(seek + 0.5);\n      }\n      this.seekWindowLength = Math.floor(this.sampleRate * this.sequenceMs / 1000);\n      this.seekLength = Math.floor(this.sampleRate * this.seekWindowMs / 1000);\n    }\n  }, {\n    key: \"clone\",\n    value: function clone() {\n      var result = new Stretch();\n      result.tempo = this._tempo;\n      result.setParameters(this.sampleRate, this.sequenceMs, this.seekWindowMs, this.overlapMs);\n      return result;\n    }\n  }, {\n    key: \"seekBestOverlapPosition\",\n    value: function seekBestOverlapPosition() {\n      return this._quickSeek ? this.seekBestOverlapPositionStereoQuick() : this.seekBestOverlapPositionStereo();\n    }\n  }, {\n    key: \"seekBestOverlapPositionStereo\",\n    value: function seekBestOverlapPositionStereo() {\n      var bestOffset;\n      var bestCorrelation;\n      var correlation;\n      var i = 0;\n      this.preCalculateCorrelationReferenceStereo();\n      bestOffset = 0;\n      bestCorrelation = Number.MIN_VALUE;\n      for (; i < this.seekLength; i = i + 1) {\n        correlation = this.calculateCrossCorrelationStereo(2 * i, this.refMidBuffer);\n        if (correlation > bestCorrelation) {\n          bestCorrelation = correlation;\n          bestOffset = i;\n        }\n      }\n      return bestOffset;\n    }\n  }, {\n    key: \"seekBestOverlapPositionStereoQuick\",\n    value: function seekBestOverlapPositionStereoQuick() {\n      var bestOffset;\n      var bestCorrelation;\n      var correlation;\n      var scanCount = 0;\n      var correlationOffset;\n      var tempOffset;\n      this.preCalculateCorrelationReferenceStereo();\n      bestCorrelation = Number.MIN_VALUE;\n      bestOffset = 0;\n      correlationOffset = 0;\n      tempOffset = 0;\n      for (; scanCount < 4; scanCount = scanCount + 1) {\n        var j = 0;\n        while (_SCAN_OFFSETS[scanCount][j]) {\n          tempOffset = correlationOffset + _SCAN_OFFSETS[scanCount][j];\n          if (tempOffset >= this.seekLength) {\n            break;\n          }\n          correlation = this.calculateCrossCorrelationStereo(2 * tempOffset, this.refMidBuffer);\n          if (correlation > bestCorrelation) {\n            bestCorrelation = correlation;\n            bestOffset = tempOffset;\n          }\n          j = j + 1;\n        }\n        correlationOffset = bestOffset;\n      }\n      return bestOffset;\n    }\n  }, {\n    key: \"preCalculateCorrelationReferenceStereo\",\n    value: function preCalculateCorrelationReferenceStereo() {\n      var i = 0;\n      var context;\n      var temp;\n      for (; i < this.overlapLength; i = i + 1) {\n        temp = i * (this.overlapLength - i);\n        context = i * 2;\n        this.refMidBuffer[context] = this.midBuffer[context] * temp;\n        this.refMidBuffer[context + 1] = this.midBuffer[context + 1] * temp;\n      }\n    }\n  }, {\n    key: \"calculateCrossCorrelationStereo\",\n    value: function calculateCrossCorrelationStereo(mixingPosition, compare) {\n      var mixing = this._inputBuffer.vector;\n      mixingPosition += this._inputBuffer.startIndex;\n      var correlation = 0;\n      var i = 2;\n      var calcLength = 2 * this.overlapLength;\n      var mixingOffset;\n      for (; i < calcLength; i = i + 2) {\n        mixingOffset = i + mixingPosition;\n        correlation += mixing[mixingOffset] * compare[i] + mixing[mixingOffset + 1] * compare[i + 1];\n      }\n      return correlation;\n    }\n  }, {\n    key: \"overlap\",\n    value: function overlap(overlapPosition) {\n      this.overlapStereo(2 * overlapPosition);\n    }\n  }, {\n    key: \"overlapStereo\",\n    value: function overlapStereo(inputPosition) {\n      var input = this._inputBuffer.vector;\n      inputPosition += this._inputBuffer.startIndex;\n      var output = this._outputBuffer.vector;\n      var outputPosition = this._outputBuffer.endIndex;\n      var i = 0;\n      var context;\n      var tempFrame;\n      var frameScale = 1 / this.overlapLength;\n      var fi;\n      var inputOffset;\n      var outputOffset;\n      for (; i < this.overlapLength; i = i + 1) {\n        tempFrame = (this.overlapLength - i) * frameScale;\n        fi = i * frameScale;\n        context = 2 * i;\n        inputOffset = context + inputPosition;\n        outputOffset = context + outputPosition;\n        output[outputOffset + 0] = input[inputOffset + 0] * fi + this.midBuffer[context + 0] * tempFrame;\n        output[outputOffset + 1] = input[inputOffset + 1] * fi + this.midBuffer[context + 1] * tempFrame;\n      }\n    }\n  }, {\n    key: \"process\",\n    value: function process() {\n      var offset;\n      var temp;\n      var overlapSkip;\n      if (this.midBuffer === null) {\n        if (this._inputBuffer.frameCount < this.overlapLength) {\n          return;\n        }\n        this.midBuffer = new Float32Array(this.overlapLength * 2);\n        this._inputBuffer.receiveSamples(this.midBuffer, this.overlapLength);\n      }\n      while (this._inputBuffer.frameCount >= this.sampleReq) {\n        offset = this.seekBestOverlapPosition();\n        this._outputBuffer.ensureAdditionalCapacity(this.overlapLength);\n        this.overlap(Math.floor(offset));\n        this._outputBuffer.put(this.overlapLength);\n        temp = this.seekWindowLength - 2 * this.overlapLength;\n        if (temp > 0) {\n          this._outputBuffer.putBuffer(this._inputBuffer, offset + this.overlapLength, temp);\n        }\n        var start = this._inputBuffer.startIndex + 2 * (offset + this.seekWindowLength - this.overlapLength);\n        this.midBuffer.set(this._inputBuffer.vector.subarray(start, start + 2 * this.overlapLength));\n        this.skipFract += this.nominalSkip;\n        overlapSkip = Math.floor(this.skipFract);\n        this.skipFract -= overlapSkip;\n        this._inputBuffer.receive(overlapSkip);\n      }\n    }\n  }, {\n    key: \"tempo\",\n    set: function set(newTempo) {\n      var intskip;\n      this._tempo = newTempo;\n      this.calculateSequenceParameters();\n      this.nominalSkip = this._tempo * (this.seekWindowLength - this.overlapLength);\n      this.skipFract = 0;\n      intskip = Math.floor(this.nominalSkip + 0.5);\n      this.sampleReq = Math.max(intskip + this.overlapLength, this.seekWindowLength) + this.seekLength;\n    },\n    get: function get() {\n      return this._tempo;\n    }\n  }, {\n    key: \"inputChunkSize\",\n    get: function get() {\n      return this.sampleReq;\n    }\n  }, {\n    key: \"outputChunkSize\",\n    get: function get() {\n      return this.overlapLength + Math.max(0, this.seekWindowLength - 2 * this.overlapLength);\n    }\n  }, {\n    key: \"quickSeek\",\n    set: function set(enable) {\n      this._quickSeek = enable;\n    }\n  }]);\n  return Stretch;\n}(AbstractFifoSamplePipe);\n\nvar testFloatEqual = function testFloatEqual(a, b) {\n  return (a > b ? a - b : b - a) > 1e-10;\n};\n\nvar SoundTouch =\nfunction () {\n  function SoundTouch() {\n    _classCallCheck(this, SoundTouch);\n    this.transposer = new RateTransposer(false);\n    this.stretch = new Stretch(false);\n    this._inputBuffer = new FifoSampleBuffer();\n    this._intermediateBuffer = new FifoSampleBuffer();\n    this._outputBuffer = new FifoSampleBuffer();\n    this._rate = 0;\n    this._tempo = 0;\n    this.virtualPitch = 1.0;\n    this.virtualRate = 1.0;\n    this.virtualTempo = 1.0;\n    this.calculateEffectiveRateAndTempo();\n  }\n  _createClass(SoundTouch, [{\n    key: \"clear\",\n    value: function clear() {\n      this.transposer.clear();\n      this.stretch.clear();\n    }\n  }, {\n    key: \"clone\",\n    value: function clone() {\n      var result = new SoundTouch();\n      result.rate = this.rate;\n      result.tempo = this.tempo;\n      return result;\n    }\n  }, {\n    key: \"calculateEffectiveRateAndTempo\",\n    value: function calculateEffectiveRateAndTempo() {\n      var previousTempo = this._tempo;\n      var previousRate = this._rate;\n      this._tempo = this.virtualTempo / this.virtualPitch;\n      this._rate = this.virtualRate * this.virtualPitch;\n      if (testFloatEqual(this._tempo, previousTempo)) {\n        this.stretch.tempo = this._tempo;\n      }\n      if (testFloatEqual(this._rate, previousRate)) {\n        this.transposer.rate = this._rate;\n      }\n      if (this._rate > 1.0) {\n        if (this._outputBuffer != this.transposer.outputBuffer) {\n          this.stretch.inputBuffer = this._inputBuffer;\n          this.stretch.outputBuffer = this._intermediateBuffer;\n          this.transposer.inputBuffer = this._intermediateBuffer;\n          this.transposer.outputBuffer = this._outputBuffer;\n        }\n      } else {\n        if (this._outputBuffer != this.stretch.outputBuffer) {\n          this.transposer.inputBuffer = this._inputBuffer;\n          this.transposer.outputBuffer = this._intermediateBuffer;\n          this.stretch.inputBuffer = this._intermediateBuffer;\n          this.stretch.outputBuffer = this._outputBuffer;\n        }\n      }\n    }\n  }, {\n    key: \"process\",\n    value: function process() {\n      if (this._rate > 1.0) {\n        this.stretch.process();\n        this.transposer.process();\n      } else {\n        this.transposer.process();\n        this.stretch.process();\n      }\n    }\n  }, {\n    key: \"rate\",\n    get: function get() {\n      return this._rate;\n    },\n    set: function set(rate) {\n      this.virtualRate = rate;\n      this.calculateEffectiveRateAndTempo();\n    }\n  }, {\n    key: \"rateChange\",\n    set: function set(rateChange) {\n      this._rate = 1.0 + 0.01 * rateChange;\n    }\n  }, {\n    key: \"tempo\",\n    get: function get() {\n      return this._tempo;\n    },\n    set: function set(tempo) {\n      this.virtualTempo = tempo;\n      this.calculateEffectiveRateAndTempo();\n    }\n  }, {\n    key: \"tempoChange\",\n    set: function set(tempoChange) {\n      this.tempo = 1.0 + 0.01 * tempoChange;\n    }\n  }, {\n    key: \"pitch\",\n    set: function set(pitch) {\n      this.virtualPitch = pitch;\n      this.calculateEffectiveRateAndTempo();\n    }\n  }, {\n    key: \"pitchOctaves\",\n    set: function set(pitchOctaves) {\n      this.pitch = Math.exp(0.69314718056 * pitchOctaves);\n      this.calculateEffectiveRateAndTempo();\n    }\n  }, {\n    key: \"pitchSemitones\",\n    set: function set(pitchSemitones) {\n      this.pitchOctaves = pitchSemitones / 12.0;\n    }\n  }, {\n    key: \"inputBuffer\",\n    get: function get() {\n      return this._inputBuffer;\n    }\n  }, {\n    key: \"outputBuffer\",\n    get: function get() {\n      return this._outputBuffer;\n    }\n  }]);\n  return SoundTouch;\n}();\n\nvar WebAudioBufferSource =\nfunction () {\n  function WebAudioBufferSource(buffer) {\n    _classCallCheck(this, WebAudioBufferSource);\n    this.buffer = buffer;\n    this._position = 0;\n  }\n  _createClass(WebAudioBufferSource, [{\n    key: \"extract\",\n    value: function extract(target) {\n      var numFrames = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      var position = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n      this.position = position;\n      var left = this.buffer.getChannelData(0);\n      var right = this.dualChannel ? this.buffer.getChannelData(1) : this.buffer.getChannelData(0);\n      var i = 0;\n      for (; i < numFrames; i++) {\n        target[i * 2] = left[i + position];\n        target[i * 2 + 1] = right[i + position];\n      }\n      return Math.min(numFrames, left.length - position);\n    }\n  }, {\n    key: \"dualChannel\",\n    get: function get() {\n      return this.buffer.numberOfChannels > 1;\n    }\n  }, {\n    key: \"position\",\n    get: function get() {\n      return this._position;\n    },\n    set: function set(value) {\n      this._position = value;\n    }\n  }]);\n  return WebAudioBufferSource;\n}();\n\nvar getWebAudioNode = function getWebAudioNode(context, filter) {\n  var sourcePositionCallback = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : noop;\n  var bufferSize = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 4096;\n  var node = context.createScriptProcessor(bufferSize, 2, 2);\n  var samples = new Float32Array(bufferSize * 2);\n  node.onaudioprocess = function (event) {\n    var left = event.outputBuffer.getChannelData(0);\n    var right = event.outputBuffer.getChannelData(1);\n    var framesExtracted = filter.extract(samples, bufferSize);\n    sourcePositionCallback(filter.sourcePosition);\n    if (framesExtracted === 0) {\n      filter.onEnd();\n    }\n    var i = 0;\n    for (; i < framesExtracted; i++) {\n      left[i] = samples[i * 2];\n      right[i] = samples[i * 2 + 1];\n    }\n  };\n  return node;\n};\n\nvar pad = function pad(n, width, z) {\n  z = z || '0';\n  n = n + '';\n  return n.length >= width ? n : new Array(width - n.length + 1).join(z) + n;\n};\nvar minsSecs = function minsSecs(secs) {\n  var mins = Math.floor(secs / 60);\n  var seconds = secs - mins * 60;\n  return \"\".concat(mins, \":\").concat(pad(parseInt(seconds), 2));\n};\n\nvar onUpdate = function onUpdate(sourcePosition) {\n  var currentTimePlayed = this.timePlayed;\n  var sampleRate = this.sampleRate;\n  this.sourcePosition = sourcePosition;\n  this.timePlayed = sourcePosition / sampleRate;\n  if (currentTimePlayed !== this.timePlayed) {\n    var timePlayed = new CustomEvent('play', {\n      detail: {\n        timePlayed: this.timePlayed,\n        formattedTimePlayed: this.formattedTimePlayed,\n        percentagePlayed: this.percentagePlayed\n      }\n    });\n    this._node.dispatchEvent(timePlayed);\n  }\n};\nvar PitchShifter =\nfunction () {\n  function PitchShifter(context, buffer, bufferSize) {\n    var _this = this;\n    var onEnd = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : noop;\n    _classCallCheck(this, PitchShifter);\n    this._soundtouch = new SoundTouch();\n    var source = new WebAudioBufferSource(buffer);\n    this.timePlayed = 0;\n    this.sourcePosition = 0;\n    this._filter = new SimpleFilter(source, this._soundtouch, onEnd);\n    this._node = getWebAudioNode(context, this._filter, function (sourcePostion) {\n      return onUpdate.call(_this, sourcePostion);\n    });\n    this.tempo = 1;\n    this.rate = 1;\n    this.duration = buffer.duration;\n    this.sampleRate = context.sampleRate;\n    this.listeners = [];\n  }\n  _createClass(PitchShifter, [{\n    key: \"connect\",\n    value: function connect(toNode) {\n      this._node.connect(toNode);\n    }\n  }, {\n    key: \"disconnect\",\n    value: function disconnect() {\n      this._node.disconnect();\n    }\n  }, {\n    key: \"on\",\n    value: function on(eventName, cb) {\n      this.listeners.push({\n        name: eventName,\n        cb: cb\n      });\n      this._node.addEventListener(eventName, function (event) {\n        return cb(event.detail);\n      });\n    }\n  }, {\n    key: \"off\",\n    value: function off() {\n      var _this2 = this;\n      var eventName = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n      var listeners = this.listeners;\n      if (eventName) {\n        listeners = listeners.filter(function (e) {\n          return e.name === eventName;\n        });\n      }\n      listeners.forEach(function (e) {\n        _this2._node.removeEventListener(e.name, function (event) {\n          return e.cb(event.detail);\n        });\n      });\n    }\n  }, {\n    key: \"formattedDuration\",\n    get: function get() {\n      return minsSecs(this.duration);\n    }\n  }, {\n    key: \"formattedTimePlayed\",\n    get: function get() {\n      return minsSecs(this.timePlayed);\n    }\n  }, {\n    key: \"percentagePlayed\",\n    get: function get() {\n      return 100 * this._filter.sourcePosition / (this.duration * this.sampleRate);\n    },\n    set: function set(perc) {\n      this._filter.sourcePosition = parseInt(perc * this.duration * this.sampleRate);\n    }\n  }, {\n    key: \"node\",\n    get: function get() {\n      return this._node;\n    }\n  }, {\n    key: \"pitch\",\n    set: function set(pitch) {\n      this._soundtouch.pitch = pitch;\n    }\n  }, {\n    key: \"pitchSemitones\",\n    set: function set(semitone) {\n      this._soundtouch.pitchSemitones = semitone;\n    }\n  }, {\n    key: \"rate\",\n    set: function set(rate) {\n      this._soundtouch.rate = rate;\n    }\n  }, {\n    key: \"tempo\",\n    set: function set(tempo) {\n      this._soundtouch.tempo = tempo;\n    }\n  }]);\n  return PitchShifter;\n}();\n\nexport { AbstractFifoSamplePipe, RateTransposer, SimpleFilter, Stretch, SoundTouch, WebAudioBufferSource, PitchShifter, getWebAudioNode };\n//# sourceMappingURL=soundtouch.js.map\n","// From https://github.com/AntonLapshin/proxy-observable#readme\n/* eslint-disable */\nexport class PubSub {\n    /**\n     * Creates an instance of PubSub\n     */\n    constructor() {\n        this.fns = { any: [] };\n    }\n\n    /**\n     * Checks if a event has at least one subscription\n     *\n     * @param {string} e Event name\n     * @returns {boolean}\n     */\n    has(e) {\n        return (e in this.fns && this.fns[e].length > 0) || this.fns.any.length > 0;\n    }\n\n    /**\n     * Subscribes on event\n     *\n     * @param {string} e Event name\n     * @param {function} fn Callback\n     * @returns {function} Input callback\n     */\n    on(e, fn) {\n        if (e in this.fns === false) {\n            this.fns[e] = [];\n        }\n        this.fns[e].push(fn);\n        return fn;\n    }\n\n    /**\n     * Calls the event's callbacks\n     *\n     * @param {string} e Event name\n     * @param {any} value New value\n     * @param {any} prev Previous value\n     * @returns {object} Observable\n     */\n    fire(e, value, prev) {\n        this.fns.any.concat(e in this.fns ? this.fns[e] : []).forEach(fn => fn(value, prev, e));\n        return this;\n    }\n\n    /**\n     * Unsubscribes from event\n     *\n     * @param {function} fn Callback\n     * @returns {boolean} true if successfully unsubscribed\n     */\n    off(fn) {\n        for (const e in this.fns) {\n            const fns = this.fns[e];\n            for (let i = 0; i < fns.length; i++) {\n                if (fns[i] === fn) {\n                    fns.splice(i, 1);\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Subscribes on event once\n     *\n     * @param {string} e Event name\n     * @param {function} fn Callback\n     * @returns {function} Input callback\n     */\n    once(e, fn) {\n        const method = (value, prev, prop) => {\n            fn(value, prev, prop);\n            this.off(method);\n        };\n        this.on(e, method);\n        return fn;\n    }\n}\n","// From https://github.com/AntonLapshin/proxy-observable#readme\n/* eslint-disable */\nimport { PubSub } from './pubsub.js';\n\n/**\n * Creates a proxy observable for an object or array\n *\n * @param {object|Observable} target Input Object\n * @returns {Observable} Observable (ES6 Proxy)\n */\nexport default target => {\n    if (target.on && target.off) {\n        return target;\n    }\n    const pub = new PubSub();\n    const observable = new Proxy(target, {\n        get: (target, prop) => {\n            if (prop in target) {\n                if (target.constructor === Array) {\n                    let v = observable;\n                    if (prop === 'pop') {\n                        v = target[target.length - 1];\n                    } else if (prop === 'shift') {\n                        v = target[0];\n                    }\n                    if (prop !== 'push' && prop !== 'length') {\n                        pub.fire(prop, v);\n                    }\n                }\n                return target[prop];\n            } else if (prop === 'on') {\n                return pub.on.bind(pub);\n            } else if (prop === 'once') {\n                return pub.once.bind(pub);\n            } else if (prop === 'off') {\n                return pub.off.bind(pub);\n            }\n            return undefined;\n        },\n        set: (target, prop, v) => {\n            if (target.constructor === Array) {\n                if (prop !== 'length') {\n                    pub.fire('change', v);\n                }\n            } else if (pub.has(prop)) {\n                pub.fire(prop, v, target[prop]);\n            }\n            target[prop] = v;\n            return true;\n        }\n    });\n\n    return observable;\n};\n","import './karaokeplayer.scss';\nimport CDGPlayer from '../cdg/CDGPlayer.js';\nimport CDGFileLoader from '../loader/CDGFileLoader.js';\nimport { PitchShifter } from 'soundtouchjs';\nimport Deferred from '../utilities/deferred.js';\nimport {\n  WIDTH,\n  HEIGHT,\n  GAIN_DEFAULT,\n  SCALE_DEFAULT,\n  PITCH_DEFAULT,\n  START_TIME,\n  FILTER_PLAYBACK_OFFSET\n} from '../cdg/constants';\nimport { isString } from '../utilities/is.js';\nimport observable from '../observable/observable.js';\n\nconst createDisplayCanvas = function(width, height) {\n  const canvas = document.createElement('canvas');\n  canvas.width = width;\n  canvas.height = height;\n  return canvas;\n};\n\nconst createCanvasContext = function(canvas) {\n  const ctx = canvas.getContext('2d');\n  ctx.webkitImageSmoothingEnabled = false;\n  ctx.mozImageSmoothingEnabled = false;\n  ctx.msImageSmoothingEnabled = false;\n  ctx.imageSmoothingEnabled = false;\n  return ctx;\n};\n\nconst copyContextToCanvas = function(context) {\n  // If there's transparency, clear the canvas first\n  if (context.keyColor >= 0) {\n    this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);\n  }\n  // Copy from source canvas to the target canvas\n  this.ctx.drawImage(\n    context.canvas,\n    0,\n    0,\n    context.canvas.width,\n    context.canvas.height,\n    0,\n    0,\n    this.canvas.width,\n    this.canvas.height\n  );\n};\n\nconst clearCanvas = function(context, canvas) {\n  context.clearRect(0, 0, canvas.width, canvas.height);\n};\n\nconst loadAudio = function(buffer) {\n  if (this.shifter) {\n    this.shifter.off();\n  }\n  return this.audio\n    .decodeAudioData(buffer)\n    .then(audioBuffer => {\n      this.shifter = observable(\n        new PitchShifter(this.audio, audioBuffer, 1024, () => {\n          this.stop();\n        })\n      );\n      this.shifter.on('play', detail => {\n        this.props.timePlayed = detail.formattedTimePlayed;\n        this.props.percentagePlayed = detail.percentagePlayed;\n        this.player.sync(detail.timePlayed * 1000 - FILTER_PLAYBACK_OFFSET);\n      });\n      this.shifter.pitch = PITCH_DEFAULT;\n      this.props.trackLength = this.shifter.formattedDuration;\n    })\n    .catch(error => Promise.reject(new Error(`There was an error decoding the audio file`, error)));\n};\n\nconst loadVideo = function(buffer) {\n  const deferred = new Deferred();\n  if (buffer) {\n    this.player.load(Array.from(buffer));\n    deferred.resolve();\n  } else {\n    deferred.reject(new Error('There was an error loading the video file'));\n  }\n  return deferred.promise;\n};\n\nconst wrapText = function(context, text, x, y, maxWidth, lineHeight) {\n  var words = text.split(' ');\n  var line = '';\n\n  for (var n = 0; n < words.length; n++) {\n    var testLine = line + words[n] + ' ';\n    var metrics = context.measureText(testLine);\n    var testWidth = metrics.width;\n    if (testWidth > maxWidth && n > 0) {\n      context.fillText(line.trim(), x, y);\n      line = words[n] + ' ';\n      y += lineHeight;\n    } else {\n      line = testLine;\n    }\n  }\n  context.fillText(line.trim(), x, y);\n};\n\nconst drawTag = function() {\n  const ctx = this.ctx;\n  const cvs = this.canvas;\n  const maxWidth = cvs.width - 10;\n  let lineHeight = 30;\n  const x = maxWidth / 2;\n  let y = 60;\n  ctx.font = '30px sans-serif';\n  ctx.fillStyle = '#fff';\n  ctx.textAlign = 'center';\n  wrapText(ctx, this.tag.title, x, y, maxWidth, lineHeight);\n  ctx.font = '20px sans-serif';\n  y = cvs.height - 60;\n  wrapText(ctx, `by ${this.tag.artist}`, x, y, maxWidth, lineHeight);\n};\n\nconst loadTag = function(tag) {\n  this.tag = tag && tag.tags;\n  if (this.tag) {\n    return drawTag.call(this);\n  }\n};\n\nconst handleExtractedZip = function(responseArr) {\n  const process = [];\n  process.push(loadAudio.call(this, responseArr[0])); // audio is always first\n  process.push(loadVideo.call(this, responseArr[1])); // video is always second\n  return Promise.all(process)\n    .then(() => {\n      this.props.status = 'File Loaded';\n      this.props.loaded = true;\n      // Display tag after marking player loaded\n      loadTag.call(this, responseArr[2]); // mp3 tag data is always last\n    })\n    .catch(error => {\n      this.props.status = 'File Loading Failed';\n      return Promise.reject(error);\n    })\n    .then(() => {\n      this.props.loading = false;\n    });\n};\n\nconst setVolume = function(val) {\n  this.gainNode.gain.value = val;\n};\n\nexport class KaraokePlayer {\n  audio = null;\n  gainNode = null;\n  shifter = null;\n\n  wrapper = null;\n  player = null;\n  currentSize = SCALE_DEFAULT;\n  canvas = null;\n  ctx = null;\n\n  props = observable({\n    status: '',\n    loaded: false,\n    loading: false,\n    isPlaying: false,\n    timePlayed: START_TIME,\n    trackLength: START_TIME,\n    percentagePlayed: 0,\n    songVolume: 1,\n    destroy: false\n  });\n\n  constructor(selector) {\n    this.wrapper = document.querySelector(selector);\n    if (!this.wrapper) {\n      throw new Error(`CDGPlayer: and element was not found with the \"${selector}\" selector`);\n    }\n    this.wrapper.classList.add('cdg-video-wrapper');\n    this.canvas = createDisplayCanvas(WIDTH, HEIGHT);\n    this.canvas.classList.add('cdg-video-player');\n    this.ctx = createCanvasContext(this.canvas);\n    this.player = new CDGPlayer({\n      afterRender: context => copyContextToCanvas.call(this, context)\n    });\n    this.wrapper.appendChild(this.canvas);\n    const titleImage = document.createElement('div');\n    titleImage.classList.add('titleImage');\n    this.wrapper.appendChild(titleImage);\n    this.onloaded = this.props.on('loaded', val => {\n      if (val) {\n        titleImage.classList.add('hide');\n        return;\n      }\n      titleImage.classList.remove('hide');\n    });\n\n    this.audio = new (window.AudioContext || window.webkitAudioContext)();\n    this.gainNode = this.audio.createGain();\n    this.onvolume = this.props.on('songVolume', val => {\n      setVolume.call(this, val);\n    });\n    this.props.songVolume = GAIN_DEFAULT;\n  }\n\n  destroy() {\n    this.wrapper.classList.remove('cdg-video-wrapper');\n    this.stop();\n    this.gainNode.disconnect();\n    if (this.shifter) {\n      this.shifter.off();\n    }\n    this.shifter = null;\n    this.gainNode = null;\n    this.audio = null;\n    this.canvas.remove();\n    this.props.destroy = true;\n    this.props.off('onvolume');\n  }\n\n  load(filePath) {\n    this.stop();\n    clearCanvas(this.ctx, this.canvas);\n    this.props.loading = true;\n    let promise;\n    if (isString(filePath)) {\n      if (!filePath.toLowerCase().endsWith('.zip')) {\n        this.props.loading = false;\n        this.props.status = `${filePath} doesn't appear to be a \".zip\" file.`;\n\n        return Promise.reject(this.props.status);\n      }\n      this.props.status = 'Retrieving File...';\n      promise = CDGFileLoader.loadZipFile(filePath);\n    } else {\n      this.props.status = `Loading File...`;\n      promise = CDGFileLoader.loadFileBuffer(filePath);\n    }\n    return promise\n      .then(zipResponse => handleExtractedZip.call(this, zipResponse))\n      .catch(error => Promise.reject(error));\n  }\n\n  togglePlay() {\n    if (this.props.isPlaying) {\n      this.pause();\n    } else {\n      this.start();\n    }\n  }\n\n  start() {\n    clearCanvas.call(this, this.ctx, this.canvas);\n    this.shifter.connect(this.gainNode);\n    this.gainNode.connect(this.audio.destination);\n    // updates for autoplay issues\n    this.audio.resume().then(() => {\n      this.props.isPlaying = true;\n      this.player.play();\n    });\n  }\n\n  pause(playing = false) {\n    this.props.isPlaying = playing;\n    this.shifter.disconnect();\n    /*if (this.timeInterval) {\n      clearInterval(this.timeInterval);\n      this.timeInterval = null;\n    }*/\n    this.player.stop();\n  }\n\n  stop() {\n    if (this.shifter) {\n      this.pause();\n      this.changePlayerPosition(0);\n      drawTag.call(this);\n    }\n  }\n\n  changePlayerPosition(perc) {\n    perc = perc < 0 ? 0 : perc > 100 ? 100 : perc;\n    this.shifter.percentagePlayed = perc;\n    this.props.percentagePlayed = this.shifter.percentagePlayed;\n    this.props.timePlayed = this.shifter.formattedTimePlayed;\n    this.player.reset();\n    if (!perc) {\n      this.props.isPlaying = false;\n      this.props.timePlayed = START_TIME;\n    }\n  }\n\n  changeKey(pitchChange) {\n    pitchChange = pitchChange < -7 ? -7 : pitchChange > 7 ? 7 : pitchChange;\n    this.shifter.pitchSemitones = pitchChange;\n    this.shifter.tempo = 1; // keep the tempo straight\n  }\n\n  volume(change) {\n    const current = this.gainNode.gain.value;\n    const newValue = +(current + change).toFixed(2);\n    this.props.songVolume = newValue < 0 ? 0 : newValue > 1 ? 1 : newValue;\n  }\n\n  toggleMute() {\n    const fallback = this.gainNode.gain.value;\n    this.props.songVolume = fallback ? 0 : this.fallbackVolume;\n    this.fallbackVolume = fallback;\n  }\n}\n","export const isString = function(value) {\n    return typeof value === 'string';\n};\n\nexport const isNumber = function(value) {\n    return typeof value === 'number';\n};\n\nexport const isDate = function(value) {\n    return toString.call(value) === '[object Date]';\n};\n\nexport const isArray = function(arr) {\n    return Array.isArray(arr);\n};\n\nexport const isFunction = function(value) {\n    return typeof value === 'function';\n};\n\nexport const isBoolean = function(value) {\n    return typeof value === 'boolean';\n};\n\nexport const isDefined = function(value) {\n    return typeof value !== 'undefined';\n};\n\nexport const isUndefined = function(value) {\n    return typeof value === 'undefined';\n};\n\nexport const isObject = function(value) {\n    return value !== null && typeof value === 'object';\n};\n\nexport const isPromise = function(obj) {\n    return (\n        !!obj &&\n        (typeof obj === 'object' || typeof obj === 'function') &&\n        typeof obj.then === 'function'\n    );\n};\n\nexport const isError = function(value) {\n    const tag = toString.call(value);\n    switch (tag) {\n        case '[object Error]':\n            return true;\n        case '[object Exception]':\n            return true;\n        case '[object DOMException]':\n            return true;\n        default:\n            return value instanceof Error;\n    }\n};\n","import ctrlTemplate from './cdgcontrols.html';\nimport './cdgcontrols.scss';\nimport { PANEL_POSITION } from '../cdg/constants.js';\n\nconst playIcon = 'icofont-play-alt-1';\nconst pauseIcon = 'icofont-pause';\n\nconst htmlToElement = function(html) {\n  let template = document.createElement('template');\n  html = html.trim();\n  template.innerHTML = html;\n  return template.content.firstChild;\n};\n\nconst setupListeners = function() {\n  const props = this.player.props;\n  this.onloaded = props.on('loaded', val => {\n    if (val) {\n      this.playBtn.removeAttribute('disabled');\n      this.pitch.removeAttribute('disabled');\n      this.volumeBtn.removeAttribute('disabled');\n    } else {\n      this.playBtn.setAttribute('disabled', 'disabled');\n      this.pitch.setAttribute('disabled', 'disabled');\n      this.volumeBtn.setAttribute('disabled', 'disabled');\n    }\n  });\n  this.ontimeplayed = props.on('timePlayed', (val, prev) => {\n    if (val !== prev) {\n      this.timePlayed.innerHTML = val;\n    }\n  });\n  this.onpercentageplayed = props.on('percentagePlayed', (val, prev) => {\n    if (val !== prev) {\n      this.progress.value = val;\n    }\n  });\n  this.ontracklength = props.on('trackLength', (val, prev) => {\n    if (val !== prev) {\n      this.trackLength.innerHTML = val;\n    }\n  });\n  this.ondestroy = props.on('destroy', val => {\n    if (val) {\n      removeListeners.call(this);\n    }\n  });\n  this.onplay = props.on('isPlaying', val => {\n    this.playIcn.classList.remove(playIcon, pauseIcon);\n    this.playIcn.classList.add(val ? pauseIcon : playIcon);\n  });\n\n  this.onvolume = props.on('songVolume', val => {\n    const icn = this.volumeIcn;\n    this.volumeSlider.value = val;\n    if (val) {\n      if (icn.classList.contains('mute')) {\n        icn.classList.remove('mute');\n        return;\n      }\n      return;\n    }\n    icn.classList.add('mute');\n  });\n\n  this.playBtn.addEventListener('click', () => this.player.togglePlay());\n  this.progress.addEventListener('click', event => changePosition.call(this, event));\n  this.pitch.addEventListener('change', () => changeKey.call(this));\n  this.volumeSlider.addEventListener('change', () => changeVolume.call(this));\n};\n\nconst removeListeners = function() {\n  const props = this.player.props;\n  props.off(this.onloaded);\n  props.off(this.ontimeplayed);\n  props.off(this.onpercentageplayed);\n  props.off(this.ontracklength);\n  props.off(this.ondestroy);\n  props.off(this.onplay);\n  props.off(this.onvolume);\n  this.playBtn.removeEventListener('click', () => this.player.togglePlay());\n  this.progress.removeEventListener('click', event => changePosition.call(this, event));\n  this.pitch.removeEventListener('change', () => changeKey.call(this));\n  this.volumeSlider.removeEventListener('change', () => changeVolume.call(this));\n};\n\nconst changePosition = function(event) {\n  const pos = event.target.getBoundingClientRect();\n  const relX = event.pageX - pos.x;\n  const perc = relX / event.target.offsetWidth;\n  this.player.changePlayerPosition(perc);\n};\n\nconst changeKey = function() {\n  const val = this.pitch.value;\n  if (isNaN(val)) {\n    this.pitch.value = this.fallbackPitch;\n    return;\n  }\n  this.fallbackPitch = val < -7 ? -7 : val > 7 ? 7 : val;\n  this.player.changeKey(this.fallbackPitch);\n};\n\nconst changeVolume = function() {\n  this.player.props.songVolume = +(parseFloat(this.volumeSlider.value) + 0).toFixed(2);\n};\n\nexport default class CDGControls {\n  controls = htmlToElement(ctrlTemplate);\n  player = null;\n\n  playBtn = null;\n  playIcn = null;\n  timePlayed = null;\n  progress = null;\n  trackLength = null;\n  pitch = null;\n\n  constructor(selector, player, options = { position: 'bottom' }) {\n    const wrapper = document.querySelector(selector);\n    wrapper.appendChild(this.controls);\n    this.player = player;\n    const props = this.player.props;\n    this.playBtn = this.controls.querySelector('.playButton');\n    this.playIcn = this.playBtn.querySelector('i');\n    this.timePlayed = this.controls.querySelector('.timePlayed');\n    this.timePlayed.innerHTML = props.timePlayed;\n    this.progress = this.controls.querySelector('.progressMeter');\n    this.progress.value = props.percentagePlayed;\n    this.trackLength = this.controls.querySelector('.trackLength');\n    this.trackLength.innerHTML = props.trackLength;\n    this.pitch = this.controls.querySelector('.pitch');\n    this.fallbackPitch = 0;\n    if (!PANEL_POSITION.includes(options.position)) {\n      throw new Error(`Panel Position must be either 'top' or 'bottom'.`);\n    }\n    this.volumeBtn = this.controls.querySelector('#song_volume_button');\n    this.volumeIcn = this.volumeBtn.querySelector('i');\n    this.volumeSlider = this.controls.querySelector('#song_volume');\n    this.volumeSlider.value = props.songVolume;\n    if (options.position === 'top') {\n      const sliderContainer = this.controls.querySelector('.volumeSlider');\n      sliderContainer.classList.add('under');\n    }\n    setupListeners.call(this);\n  }\n}\n"],"names":["styleInject","css","ref","insertAt","document","head","getElementsByTagName","style","createElement","type","firstChild","insertBefore","appendChild","styleSheet","cssText","createTextNode","WIDTH","TILE_WIDTH","HEIGHT","TILE_HEIGHT","DISPLAY_BOUNDS","DISPLAY_PIXELS","CDG_DATA","SECTORS_PER_SECOND","PACKETS_PER_SECTOR","PACKET_SIZE","GAIN_DEFAULT","SCALE_DEFAULT","START_TIME","PANEL_POSITION","CDGContext","width","height","canvas","this","createCanvas","ctx","createCanvasContext","imageData","createImageData","Array","fill","getContext","mozImageSmoothingEnabled","webkitImageSmoothingEnabled","msImageSmoothingEnabled","imageSmoothingEnabled","hOffset","vOffset","keyColor","backgroundColor","borderColor","memoryColor","pixels","index","r","g","b","clut","map","c","x","y","colorIndex","right","bottom","offset","pixelIndex","data","putImageData","generateImageData","warn","console","CDGInstruction","bytes","slice","constructor","instruction","opcode","byte","toString","padStart","join","CDGNoopInstruction","CDGMemoryPresetInstruction","doff","color","repeat","context","CDGBorderPresetInstruction","left","top","setPixel","CDGTileBlockInstruction","colors","row","column","i","curbyte","j","op","CDGTileBlockXORInstruction","getPixel","CDGScrollPresetInstruction","hScroll","hCmd","vScroll","vCmd","Math","min","buffer","offx","offy","filter","v","CDGScrollCopyInstruction","CDGSetKeyColorInstruction","CDGLoadCLUTLowInstruction","cur","setCLUTEntry","clutOffset","_this7","CDGLoadCLUTHighInstruction","CDGParser","instructionClassByType","InstructionClass","createInstruction","instructions","bytesLength","length","push","parseInstruction","now","performance","process","hrtime","Date","requestFrame","callback","requestAnimationFrame","window","setTimeout","CDGPlayer","contextOptions","createContext","afterRender","timestamp","_this","pc","frameId","update","lastSyncPos","pos","lastTimestamp","ffAmt","floor","fastForward","render","options","parser","parseInstructions","reset","renderFrame","execute","executeInstruction","stop","count","max","step","id","cancelAnimationFrame","clearTimeout","ms","Deferred","Promise","defer","PromiseUtils","resolve","reject","promise","bind","Object","freeze","loadZipBuffer","fileBuffer","JSZip","loadAsync","catch","error","Error","getKaraokeFiles","zipFile","entries","relPath","endsWith","processZip","audio","entry","name","video","async","zipEntry","loadVideo","then","jsmediatags","Reader","setTagsToRead","read","onSuccess","tag","onError","parts","split","tags","album","trim","artist","title","getTagData","all","errors","CDGFileLoader","filePath","deferred","JSZipUtils","getBinaryContent","err","getDataFile","FifoSampleBuffer","_vector","Float32Array","_position","_frameCount","receive","rewind","numFrames","samples","position","arguments","undefined","sourceOffset","numSamples","ensureCapacity","destOffset","endIndex","vector","set","putSamples","output","startIndex","subarray","minLength","parseInt","newVector","PubSub","fns","any","e","fn","value","prev","concat","forEach","splice","on","method","prop","off","target","pub","observable","Proxy","get","fire","once","has","createDisplayCanvas","copyContextToCanvas","clearRect","drawImage","clearCanvas","wrapText","text","maxWidth","lineHeight","words","line","n","testLine","measureText","fillText","drawTag","cvs","font","fillStyle","textAlign","handleExtractedZip","responseArr","shifter","decodeAudioData","audioBuffer","PitchShifter","detail","props","timePlayed","formattedTimePlayed","percentagePlayed","player","sync","pitch","trackLength","formattedDuration","call","load","from","_this2","status","loaded","loading","setVolume","val","gainNode","gain","KaraokePlayer","selector","isPlaying","songVolume","destroy","wrapper","querySelector","classList","add","_this3","titleImage","onloaded","remove","AudioContext","webkitAudioContext","createGain","onvolume","disconnect","toLowerCase","loadZipFile","loadFileBuffer","zipResponse","_this4","pause","start","connect","destination","resume","_this5","play","playing","changePlayerPosition","perc","pitchChange","pitchSemitones","tempo","change","newValue","toFixed","fallback","fallbackVolume","removeListeners","ontimeplayed","onpercentageplayed","ontracklength","ondestroy","onplay","playBtn","removeEventListener","togglePlay","progress","event","changePosition","changeKey","volumeSlider","changeVolume","getBoundingClientRect","pageX","offsetWidth","isNaN","fallbackPitch","parseFloat","CDGControls","html","template","innerHTML","content","controls","playIcn","includes","volumeBtn","volumeIcn","removeAttribute","setAttribute","icn","contains","addEventListener"],"mappings":"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"}